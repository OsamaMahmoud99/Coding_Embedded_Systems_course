
FSM_RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000033ae  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000048  00800060  000033ae  00003442  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002fe  008000a8  008000a8  0000348a  2**0
                  ALLOC
  3 .stab         0000540c  00000000  00000000  0000348c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003209  00000000  00000000  00008898  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 97 07 	jmp	0xf2e	; 0xf2e <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee ea       	ldi	r30, 0xAE	; 174
      68:	f3 e3       	ldi	r31, 0x33	; 51
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 3a       	cpi	r26, 0xA8	; 168
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a8 ea       	ldi	r26, 0xA8	; 168
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a6 3a       	cpi	r26, 0xA6	; 166
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 71 19 	call	0x32e2	; 0x32e2 <main>
      8a:	0c 94 d5 19 	jmp	0x33aa	; 0x33aa <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <xCoRoutineCreate>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	27 97       	sbiw	r28, 0x07	; 7
      9c:	0f b6       	in	r0, 0x3f	; 63
      9e:	f8 94       	cli
      a0:	de bf       	out	0x3e, r29	; 62
      a2:	0f be       	out	0x3f, r0	; 63
      a4:	cd bf       	out	0x3d, r28	; 61
      a6:	9d 83       	std	Y+5, r25	; 0x05
      a8:	8c 83       	std	Y+4, r24	; 0x04
      aa:	6e 83       	std	Y+6, r22	; 0x06
      ac:	4f 83       	std	Y+7, r20	; 0x07
      ae:	8a e1       	ldi	r24, 0x1A	; 26
      b0:	90 e0       	ldi	r25, 0x00	; 0
      b2:	0e 94 21 03 	call	0x642	; 0x642 <pvPortMalloc>
      b6:	9a 83       	std	Y+2, r25	; 0x02
      b8:	89 83       	std	Y+1, r24	; 0x01
      ba:	89 81       	ldd	r24, Y+1	; 0x01
      bc:	9a 81       	ldd	r25, Y+2	; 0x02
      be:	00 97       	sbiw	r24, 0x00	; 0
      c0:	09 f4       	brne	.+2      	; 0xc4 <xCoRoutineCreate+0x32>
      c2:	6f c0       	rjmp	.+222    	; 0x1a2 <xCoRoutineCreate+0x110>
      c4:	80 91 a8 00 	lds	r24, 0x00A8
      c8:	90 91 a9 00 	lds	r25, 0x00A9
      cc:	00 97       	sbiw	r24, 0x00	; 0
      ce:	41 f4       	brne	.+16     	; 0xe0 <xCoRoutineCreate+0x4e>
      d0:	89 81       	ldd	r24, Y+1	; 0x01
      d2:	9a 81       	ldd	r25, Y+2	; 0x02
      d4:	90 93 a9 00 	sts	0x00A9, r25
      d8:	80 93 a8 00 	sts	0x00A8, r24
      dc:	0e 94 b0 02 	call	0x560	; 0x560 <prvInitialiseCoRoutineLists>
      e0:	8e 81       	ldd	r24, Y+6	; 0x06
      e2:	82 30       	cpi	r24, 0x02	; 2
      e4:	10 f0       	brcs	.+4      	; 0xea <xCoRoutineCreate+0x58>
      e6:	81 e0       	ldi	r24, 0x01	; 1
      e8:	8e 83       	std	Y+6, r24	; 0x06
      ea:	e9 81       	ldd	r30, Y+1	; 0x01
      ec:	fa 81       	ldd	r31, Y+2	; 0x02
      ee:	11 8e       	std	Z+25, r1	; 0x19
      f0:	10 8e       	std	Z+24, r1	; 0x18
      f2:	e9 81       	ldd	r30, Y+1	; 0x01
      f4:	fa 81       	ldd	r31, Y+2	; 0x02
      f6:	8e 81       	ldd	r24, Y+6	; 0x06
      f8:	86 8b       	std	Z+22, r24	; 0x16
      fa:	e9 81       	ldd	r30, Y+1	; 0x01
      fc:	fa 81       	ldd	r31, Y+2	; 0x02
      fe:	8f 81       	ldd	r24, Y+7	; 0x07
     100:	87 8b       	std	Z+23, r24	; 0x17
     102:	e9 81       	ldd	r30, Y+1	; 0x01
     104:	fa 81       	ldd	r31, Y+2	; 0x02
     106:	8c 81       	ldd	r24, Y+4	; 0x04
     108:	9d 81       	ldd	r25, Y+5	; 0x05
     10a:	91 83       	std	Z+1, r25	; 0x01
     10c:	80 83       	st	Z, r24
     10e:	89 81       	ldd	r24, Y+1	; 0x01
     110:	9a 81       	ldd	r25, Y+2	; 0x02
     112:	02 96       	adiw	r24, 0x02	; 2
     114:	0e 94 b7 03 	call	0x76e	; 0x76e <vListInitialiseItem>
     118:	89 81       	ldd	r24, Y+1	; 0x01
     11a:	9a 81       	ldd	r25, Y+2	; 0x02
     11c:	0c 96       	adiw	r24, 0x0c	; 12
     11e:	0e 94 b7 03 	call	0x76e	; 0x76e <vListInitialiseItem>
     122:	e9 81       	ldd	r30, Y+1	; 0x01
     124:	fa 81       	ldd	r31, Y+2	; 0x02
     126:	89 81       	ldd	r24, Y+1	; 0x01
     128:	9a 81       	ldd	r25, Y+2	; 0x02
     12a:	91 87       	std	Z+9, r25	; 0x09
     12c:	80 87       	std	Z+8, r24	; 0x08
     12e:	e9 81       	ldd	r30, Y+1	; 0x01
     130:	fa 81       	ldd	r31, Y+2	; 0x02
     132:	89 81       	ldd	r24, Y+1	; 0x01
     134:	9a 81       	ldd	r25, Y+2	; 0x02
     136:	93 8b       	std	Z+19, r25	; 0x13
     138:	82 8b       	std	Z+18, r24	; 0x12
     13a:	8e 81       	ldd	r24, Y+6	; 0x06
     13c:	28 2f       	mov	r18, r24
     13e:	30 e0       	ldi	r19, 0x00	; 0
     140:	85 e0       	ldi	r24, 0x05	; 5
     142:	90 e0       	ldi	r25, 0x00	; 0
     144:	82 1b       	sub	r24, r18
     146:	93 0b       	sbc	r25, r19
     148:	e9 81       	ldd	r30, Y+1	; 0x01
     14a:	fa 81       	ldd	r31, Y+2	; 0x02
     14c:	95 87       	std	Z+13, r25	; 0x0d
     14e:	84 87       	std	Z+12, r24	; 0x0c
     150:	e9 81       	ldd	r30, Y+1	; 0x01
     152:	fa 81       	ldd	r31, Y+2	; 0x02
     154:	96 89       	ldd	r25, Z+22	; 0x16
     156:	80 91 aa 00 	lds	r24, 0x00AA
     15a:	89 17       	cp	r24, r25
     15c:	28 f4       	brcc	.+10     	; 0x168 <xCoRoutineCreate+0xd6>
     15e:	e9 81       	ldd	r30, Y+1	; 0x01
     160:	fa 81       	ldd	r31, Y+2	; 0x02
     162:	86 89       	ldd	r24, Z+22	; 0x16
     164:	80 93 aa 00 	sts	0x00AA, r24
     168:	e9 81       	ldd	r30, Y+1	; 0x01
     16a:	fa 81       	ldd	r31, Y+2	; 0x02
     16c:	86 89       	ldd	r24, Z+22	; 0x16
     16e:	28 2f       	mov	r18, r24
     170:	30 e0       	ldi	r19, 0x00	; 0
     172:	c9 01       	movw	r24, r18
     174:	88 0f       	add	r24, r24
     176:	99 1f       	adc	r25, r25
     178:	88 0f       	add	r24, r24
     17a:	99 1f       	adc	r25, r25
     17c:	88 0f       	add	r24, r24
     17e:	99 1f       	adc	r25, r25
     180:	82 0f       	add	r24, r18
     182:	93 1f       	adc	r25, r19
     184:	ac 01       	movw	r20, r24
     186:	4f 54       	subi	r20, 0x4F	; 79
     188:	5f 4f       	sbci	r21, 0xFF	; 255
     18a:	89 81       	ldd	r24, Y+1	; 0x01
     18c:	9a 81       	ldd	r25, Y+2	; 0x02
     18e:	9c 01       	movw	r18, r24
     190:	2e 5f       	subi	r18, 0xFE	; 254
     192:	3f 4f       	sbci	r19, 0xFF	; 255
     194:	ca 01       	movw	r24, r20
     196:	b9 01       	movw	r22, r18
     198:	0e 94 c7 03 	call	0x78e	; 0x78e <vListInsertEnd>
     19c:	81 e0       	ldi	r24, 0x01	; 1
     19e:	8b 83       	std	Y+3, r24	; 0x03
     1a0:	02 c0       	rjmp	.+4      	; 0x1a6 <xCoRoutineCreate+0x114>
     1a2:	8f ef       	ldi	r24, 0xFF	; 255
     1a4:	8b 83       	std	Y+3, r24	; 0x03
     1a6:	8b 81       	ldd	r24, Y+3	; 0x03
     1a8:	27 96       	adiw	r28, 0x07	; 7
     1aa:	0f b6       	in	r0, 0x3f	; 63
     1ac:	f8 94       	cli
     1ae:	de bf       	out	0x3e, r29	; 62
     1b0:	0f be       	out	0x3f, r0	; 63
     1b2:	cd bf       	out	0x3d, r28	; 61
     1b4:	cf 91       	pop	r28
     1b6:	df 91       	pop	r29
     1b8:	08 95       	ret

000001ba <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     1ba:	df 93       	push	r29
     1bc:	cf 93       	push	r28
     1be:	00 d0       	rcall	.+0      	; 0x1c0 <vCoRoutineAddToDelayedList+0x6>
     1c0:	00 d0       	rcall	.+0      	; 0x1c2 <vCoRoutineAddToDelayedList+0x8>
     1c2:	00 d0       	rcall	.+0      	; 0x1c4 <vCoRoutineAddToDelayedList+0xa>
     1c4:	cd b7       	in	r28, 0x3d	; 61
     1c6:	de b7       	in	r29, 0x3e	; 62
     1c8:	9c 83       	std	Y+4, r25	; 0x04
     1ca:	8b 83       	std	Y+3, r24	; 0x03
     1cc:	7e 83       	std	Y+6, r23	; 0x06
     1ce:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     1d0:	20 91 ab 00 	lds	r18, 0x00AB
     1d4:	30 91 ac 00 	lds	r19, 0x00AC
     1d8:	8b 81       	ldd	r24, Y+3	; 0x03
     1da:	9c 81       	ldd	r25, Y+4	; 0x04
     1dc:	82 0f       	add	r24, r18
     1de:	93 1f       	adc	r25, r19
     1e0:	9a 83       	std	Y+2, r25	; 0x02
     1e2:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1e4:	80 91 a8 00 	lds	r24, 0x00A8
     1e8:	90 91 a9 00 	lds	r25, 0x00A9
     1ec:	02 96       	adiw	r24, 0x02	; 2
     1ee:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     1f2:	e0 91 a8 00 	lds	r30, 0x00A8
     1f6:	f0 91 a9 00 	lds	r31, 0x00A9
     1fa:	89 81       	ldd	r24, Y+1	; 0x01
     1fc:	9a 81       	ldd	r25, Y+2	; 0x02
     1fe:	93 83       	std	Z+3, r25	; 0x03
     200:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     202:	20 91 ab 00 	lds	r18, 0x00AB
     206:	30 91 ac 00 	lds	r19, 0x00AC
     20a:	89 81       	ldd	r24, Y+1	; 0x01
     20c:	9a 81       	ldd	r25, Y+2	; 0x02
     20e:	82 17       	cp	r24, r18
     210:	93 07       	cpc	r25, r19
     212:	70 f4       	brcc	.+28     	; 0x230 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     214:	80 91 d7 00 	lds	r24, 0x00D7
     218:	90 91 d8 00 	lds	r25, 0x00D8
     21c:	20 91 a8 00 	lds	r18, 0x00A8
     220:	30 91 a9 00 	lds	r19, 0x00A9
     224:	2e 5f       	subi	r18, 0xFE	; 254
     226:	3f 4f       	sbci	r19, 0xFF	; 255
     228:	b9 01       	movw	r22, r18
     22a:	0e 94 13 04 	call	0x826	; 0x826 <vListInsert>
     22e:	0d c0       	rjmp	.+26     	; 0x24a <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     230:	80 91 d5 00 	lds	r24, 0x00D5
     234:	90 91 d6 00 	lds	r25, 0x00D6
     238:	20 91 a8 00 	lds	r18, 0x00A8
     23c:	30 91 a9 00 	lds	r19, 0x00A9
     240:	2e 5f       	subi	r18, 0xFE	; 254
     242:	3f 4f       	sbci	r19, 0xFF	; 255
     244:	b9 01       	movw	r22, r18
     246:	0e 94 13 04 	call	0x826	; 0x826 <vListInsert>
	}

	if( pxEventList )
     24a:	8d 81       	ldd	r24, Y+5	; 0x05
     24c:	9e 81       	ldd	r25, Y+6	; 0x06
     24e:	00 97       	sbiw	r24, 0x00	; 0
     250:	61 f0       	breq	.+24     	; 0x26a <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     252:	80 91 a8 00 	lds	r24, 0x00A8
     256:	90 91 a9 00 	lds	r25, 0x00A9
     25a:	9c 01       	movw	r18, r24
     25c:	24 5f       	subi	r18, 0xF4	; 244
     25e:	3f 4f       	sbci	r19, 0xFF	; 255
     260:	8d 81       	ldd	r24, Y+5	; 0x05
     262:	9e 81       	ldd	r25, Y+6	; 0x06
     264:	b9 01       	movw	r22, r18
     266:	0e 94 13 04 	call	0x826	; 0x826 <vListInsert>
	}
}
     26a:	26 96       	adiw	r28, 0x06	; 6
     26c:	0f b6       	in	r0, 0x3f	; 63
     26e:	f8 94       	cli
     270:	de bf       	out	0x3e, r29	; 62
     272:	0f be       	out	0x3f, r0	; 63
     274:	cd bf       	out	0x3d, r28	; 61
     276:	cf 91       	pop	r28
     278:	df 91       	pop	r29
     27a:	08 95       	ret

0000027c <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     27c:	df 93       	push	r29
     27e:	cf 93       	push	r28
     280:	00 d0       	rcall	.+0      	; 0x282 <prvCheckPendingReadyList+0x6>
     282:	cd b7       	in	r28, 0x3d	; 61
     284:	de b7       	in	r29, 0x3e	; 62
     286:	3a c0       	rjmp	.+116    	; 0x2fc <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     288:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     28a:	e0 91 de 00 	lds	r30, 0x00DE
     28e:	f0 91 df 00 	lds	r31, 0x00DF
     292:	86 81       	ldd	r24, Z+6	; 0x06
     294:	97 81       	ldd	r25, Z+7	; 0x07
     296:	9a 83       	std	Y+2, r25	; 0x02
     298:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     29a:	89 81       	ldd	r24, Y+1	; 0x01
     29c:	9a 81       	ldd	r25, Y+2	; 0x02
     29e:	0c 96       	adiw	r24, 0x0c	; 12
     2a0:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListRemove>
		}
		portENABLE_INTERRUPTS();
     2a4:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     2a6:	89 81       	ldd	r24, Y+1	; 0x01
     2a8:	9a 81       	ldd	r25, Y+2	; 0x02
     2aa:	02 96       	adiw	r24, 0x02	; 2
     2ac:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     2b0:	e9 81       	ldd	r30, Y+1	; 0x01
     2b2:	fa 81       	ldd	r31, Y+2	; 0x02
     2b4:	96 89       	ldd	r25, Z+22	; 0x16
     2b6:	80 91 aa 00 	lds	r24, 0x00AA
     2ba:	89 17       	cp	r24, r25
     2bc:	28 f4       	brcc	.+10     	; 0x2c8 <prvCheckPendingReadyList+0x4c>
     2be:	e9 81       	ldd	r30, Y+1	; 0x01
     2c0:	fa 81       	ldd	r31, Y+2	; 0x02
     2c2:	86 89       	ldd	r24, Z+22	; 0x16
     2c4:	80 93 aa 00 	sts	0x00AA, r24
     2c8:	e9 81       	ldd	r30, Y+1	; 0x01
     2ca:	fa 81       	ldd	r31, Y+2	; 0x02
     2cc:	86 89       	ldd	r24, Z+22	; 0x16
     2ce:	28 2f       	mov	r18, r24
     2d0:	30 e0       	ldi	r19, 0x00	; 0
     2d2:	c9 01       	movw	r24, r18
     2d4:	88 0f       	add	r24, r24
     2d6:	99 1f       	adc	r25, r25
     2d8:	88 0f       	add	r24, r24
     2da:	99 1f       	adc	r25, r25
     2dc:	88 0f       	add	r24, r24
     2de:	99 1f       	adc	r25, r25
     2e0:	82 0f       	add	r24, r18
     2e2:	93 1f       	adc	r25, r19
     2e4:	ac 01       	movw	r20, r24
     2e6:	4f 54       	subi	r20, 0x4F	; 79
     2e8:	5f 4f       	sbci	r21, 0xFF	; 255
     2ea:	89 81       	ldd	r24, Y+1	; 0x01
     2ec:	9a 81       	ldd	r25, Y+2	; 0x02
     2ee:	9c 01       	movw	r18, r24
     2f0:	2e 5f       	subi	r18, 0xFE	; 254
     2f2:	3f 4f       	sbci	r19, 0xFF	; 255
     2f4:	ca 01       	movw	r24, r20
     2f6:	b9 01       	movw	r22, r18
     2f8:	0e 94 c7 03 	call	0x78e	; 0x78e <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     2fc:	80 91 d9 00 	lds	r24, 0x00D9
     300:	88 23       	and	r24, r24
     302:	09 f0       	breq	.+2      	; 0x306 <prvCheckPendingReadyList+0x8a>
     304:	c1 cf       	rjmp	.-126    	; 0x288 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     306:	0f 90       	pop	r0
     308:	0f 90       	pop	r0
     30a:	cf 91       	pop	r28
     30c:	df 91       	pop	r29
     30e:	08 95       	ret

00000310 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     310:	df 93       	push	r29
     312:	cf 93       	push	r28
     314:	00 d0       	rcall	.+0      	; 0x316 <prvCheckDelayedList+0x6>
     316:	00 d0       	rcall	.+0      	; 0x318 <prvCheckDelayedList+0x8>
     318:	cd b7       	in	r28, 0x3d	; 61
     31a:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     31c:	0e 94 ed 0e 	call	0x1dda	; 0x1dda <xTaskGetTickCount>
     320:	20 91 ad 00 	lds	r18, 0x00AD
     324:	30 91 ae 00 	lds	r19, 0x00AE
     328:	82 1b       	sub	r24, r18
     32a:	93 0b       	sbc	r25, r19
     32c:	90 93 b0 00 	sts	0x00B0, r25
     330:	80 93 af 00 	sts	0x00AF, r24
     334:	85 c0       	rjmp	.+266    	; 0x440 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     336:	80 91 ab 00 	lds	r24, 0x00AB
     33a:	90 91 ac 00 	lds	r25, 0x00AC
     33e:	01 96       	adiw	r24, 0x01	; 1
     340:	90 93 ac 00 	sts	0x00AC, r25
     344:	80 93 ab 00 	sts	0x00AB, r24
		xPassedTicks--;
     348:	80 91 af 00 	lds	r24, 0x00AF
     34c:	90 91 b0 00 	lds	r25, 0x00B0
     350:	01 97       	sbiw	r24, 0x01	; 1
     352:	90 93 b0 00 	sts	0x00B0, r25
     356:	80 93 af 00 	sts	0x00AF, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     35a:	80 91 ab 00 	lds	r24, 0x00AB
     35e:	90 91 ac 00 	lds	r25, 0x00AC
     362:	00 97       	sbiw	r24, 0x00	; 0
     364:	09 f0       	breq	.+2      	; 0x368 <prvCheckDelayedList+0x58>
     366:	64 c0       	rjmp	.+200    	; 0x430 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     368:	80 91 d5 00 	lds	r24, 0x00D5
     36c:	90 91 d6 00 	lds	r25, 0x00D6
     370:	9a 83       	std	Y+2, r25	; 0x02
     372:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     374:	80 91 d7 00 	lds	r24, 0x00D7
     378:	90 91 d8 00 	lds	r25, 0x00D8
     37c:	90 93 d6 00 	sts	0x00D6, r25
     380:	80 93 d5 00 	sts	0x00D5, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     384:	89 81       	ldd	r24, Y+1	; 0x01
     386:	9a 81       	ldd	r25, Y+2	; 0x02
     388:	90 93 d8 00 	sts	0x00D8, r25
     38c:	80 93 d7 00 	sts	0x00D7, r24
     390:	4f c0       	rjmp	.+158    	; 0x430 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     392:	e0 91 d5 00 	lds	r30, 0x00D5
     396:	f0 91 d6 00 	lds	r31, 0x00D6
     39a:	05 80       	ldd	r0, Z+5	; 0x05
     39c:	f6 81       	ldd	r31, Z+6	; 0x06
     39e:	e0 2d       	mov	r30, r0
     3a0:	86 81       	ldd	r24, Z+6	; 0x06
     3a2:	97 81       	ldd	r25, Z+7	; 0x07
     3a4:	9c 83       	std	Y+4, r25	; 0x04
     3a6:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     3a8:	eb 81       	ldd	r30, Y+3	; 0x03
     3aa:	fc 81       	ldd	r31, Y+4	; 0x04
     3ac:	22 81       	ldd	r18, Z+2	; 0x02
     3ae:	33 81       	ldd	r19, Z+3	; 0x03
     3b0:	80 91 ab 00 	lds	r24, 0x00AB
     3b4:	90 91 ac 00 	lds	r25, 0x00AC
     3b8:	82 17       	cp	r24, r18
     3ba:	93 07       	cpc	r25, r19
     3bc:	08 f4       	brcc	.+2      	; 0x3c0 <prvCheckDelayedList+0xb0>
     3be:	40 c0       	rjmp	.+128    	; 0x440 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     3c0:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     3c2:	8b 81       	ldd	r24, Y+3	; 0x03
     3c4:	9c 81       	ldd	r25, Y+4	; 0x04
     3c6:	02 96       	adiw	r24, 0x02	; 2
     3c8:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     3cc:	eb 81       	ldd	r30, Y+3	; 0x03
     3ce:	fc 81       	ldd	r31, Y+4	; 0x04
     3d0:	84 89       	ldd	r24, Z+20	; 0x14
     3d2:	95 89       	ldd	r25, Z+21	; 0x15
     3d4:	00 97       	sbiw	r24, 0x00	; 0
     3d6:	29 f0       	breq	.+10     	; 0x3e2 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     3d8:	8b 81       	ldd	r24, Y+3	; 0x03
     3da:	9c 81       	ldd	r25, Y+4	; 0x04
     3dc:	0c 96       	adiw	r24, 0x0c	; 12
     3de:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     3e2:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     3e4:	eb 81       	ldd	r30, Y+3	; 0x03
     3e6:	fc 81       	ldd	r31, Y+4	; 0x04
     3e8:	96 89       	ldd	r25, Z+22	; 0x16
     3ea:	80 91 aa 00 	lds	r24, 0x00AA
     3ee:	89 17       	cp	r24, r25
     3f0:	28 f4       	brcc	.+10     	; 0x3fc <prvCheckDelayedList+0xec>
     3f2:	eb 81       	ldd	r30, Y+3	; 0x03
     3f4:	fc 81       	ldd	r31, Y+4	; 0x04
     3f6:	86 89       	ldd	r24, Z+22	; 0x16
     3f8:	80 93 aa 00 	sts	0x00AA, r24
     3fc:	eb 81       	ldd	r30, Y+3	; 0x03
     3fe:	fc 81       	ldd	r31, Y+4	; 0x04
     400:	86 89       	ldd	r24, Z+22	; 0x16
     402:	28 2f       	mov	r18, r24
     404:	30 e0       	ldi	r19, 0x00	; 0
     406:	c9 01       	movw	r24, r18
     408:	88 0f       	add	r24, r24
     40a:	99 1f       	adc	r25, r25
     40c:	88 0f       	add	r24, r24
     40e:	99 1f       	adc	r25, r25
     410:	88 0f       	add	r24, r24
     412:	99 1f       	adc	r25, r25
     414:	82 0f       	add	r24, r18
     416:	93 1f       	adc	r25, r19
     418:	ac 01       	movw	r20, r24
     41a:	4f 54       	subi	r20, 0x4F	; 79
     41c:	5f 4f       	sbci	r21, 0xFF	; 255
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	9c 81       	ldd	r25, Y+4	; 0x04
     422:	9c 01       	movw	r18, r24
     424:	2e 5f       	subi	r18, 0xFE	; 254
     426:	3f 4f       	sbci	r19, 0xFF	; 255
     428:	ca 01       	movw	r24, r20
     42a:	b9 01       	movw	r22, r18
     42c:	0e 94 c7 03 	call	0x78e	; 0x78e <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     430:	e0 91 d5 00 	lds	r30, 0x00D5
     434:	f0 91 d6 00 	lds	r31, 0x00D6
     438:	80 81       	ld	r24, Z
     43a:	88 23       	and	r24, r24
     43c:	09 f0       	breq	.+2      	; 0x440 <prvCheckDelayedList+0x130>
     43e:	a9 cf       	rjmp	.-174    	; 0x392 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     440:	80 91 af 00 	lds	r24, 0x00AF
     444:	90 91 b0 00 	lds	r25, 0x00B0
     448:	00 97       	sbiw	r24, 0x00	; 0
     44a:	09 f0       	breq	.+2      	; 0x44e <prvCheckDelayedList+0x13e>
     44c:	74 cf       	rjmp	.-280    	; 0x336 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     44e:	80 91 ab 00 	lds	r24, 0x00AB
     452:	90 91 ac 00 	lds	r25, 0x00AC
     456:	90 93 ae 00 	sts	0x00AE, r25
     45a:	80 93 ad 00 	sts	0x00AD, r24
}
     45e:	0f 90       	pop	r0
     460:	0f 90       	pop	r0
     462:	0f 90       	pop	r0
     464:	0f 90       	pop	r0
     466:	cf 91       	pop	r28
     468:	df 91       	pop	r29
     46a:	08 95       	ret

0000046c <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     46c:	df 93       	push	r29
     46e:	cf 93       	push	r28
     470:	00 d0       	rcall	.+0      	; 0x472 <vCoRoutineSchedule+0x6>
     472:	cd b7       	in	r28, 0x3d	; 61
     474:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     476:	0e 94 3e 01 	call	0x27c	; 0x27c <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     47a:	0e 94 88 01 	call	0x310	; 0x310 <prvCheckDelayedList>
     47e:	0a c0       	rjmp	.+20     	; 0x494 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     480:	80 91 aa 00 	lds	r24, 0x00AA
     484:	88 23       	and	r24, r24
     486:	09 f4       	brne	.+2      	; 0x48a <vCoRoutineSchedule+0x1e>
     488:	66 c0       	rjmp	.+204    	; 0x556 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     48a:	80 91 aa 00 	lds	r24, 0x00AA
     48e:	81 50       	subi	r24, 0x01	; 1
     490:	80 93 aa 00 	sts	0x00AA, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     494:	80 91 aa 00 	lds	r24, 0x00AA
     498:	28 2f       	mov	r18, r24
     49a:	30 e0       	ldi	r19, 0x00	; 0
     49c:	c9 01       	movw	r24, r18
     49e:	88 0f       	add	r24, r24
     4a0:	99 1f       	adc	r25, r25
     4a2:	88 0f       	add	r24, r24
     4a4:	99 1f       	adc	r25, r25
     4a6:	88 0f       	add	r24, r24
     4a8:	99 1f       	adc	r25, r25
     4aa:	82 0f       	add	r24, r18
     4ac:	93 1f       	adc	r25, r19
     4ae:	fc 01       	movw	r30, r24
     4b0:	ef 54       	subi	r30, 0x4F	; 79
     4b2:	ff 4f       	sbci	r31, 0xFF	; 255
     4b4:	80 81       	ld	r24, Z
     4b6:	88 23       	and	r24, r24
     4b8:	19 f3       	breq	.-58     	; 0x480 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     4ba:	80 91 aa 00 	lds	r24, 0x00AA
     4be:	28 2f       	mov	r18, r24
     4c0:	30 e0       	ldi	r19, 0x00	; 0
     4c2:	c9 01       	movw	r24, r18
     4c4:	88 0f       	add	r24, r24
     4c6:	99 1f       	adc	r25, r25
     4c8:	88 0f       	add	r24, r24
     4ca:	99 1f       	adc	r25, r25
     4cc:	88 0f       	add	r24, r24
     4ce:	99 1f       	adc	r25, r25
     4d0:	82 0f       	add	r24, r18
     4d2:	93 1f       	adc	r25, r19
     4d4:	8f 54       	subi	r24, 0x4F	; 79
     4d6:	9f 4f       	sbci	r25, 0xFF	; 255
     4d8:	9a 83       	std	Y+2, r25	; 0x02
     4da:	89 83       	std	Y+1, r24	; 0x01
     4dc:	e9 81       	ldd	r30, Y+1	; 0x01
     4de:	fa 81       	ldd	r31, Y+2	; 0x02
     4e0:	01 80       	ldd	r0, Z+1	; 0x01
     4e2:	f2 81       	ldd	r31, Z+2	; 0x02
     4e4:	e0 2d       	mov	r30, r0
     4e6:	82 81       	ldd	r24, Z+2	; 0x02
     4e8:	93 81       	ldd	r25, Z+3	; 0x03
     4ea:	e9 81       	ldd	r30, Y+1	; 0x01
     4ec:	fa 81       	ldd	r31, Y+2	; 0x02
     4ee:	92 83       	std	Z+2, r25	; 0x02
     4f0:	81 83       	std	Z+1, r24	; 0x01
     4f2:	e9 81       	ldd	r30, Y+1	; 0x01
     4f4:	fa 81       	ldd	r31, Y+2	; 0x02
     4f6:	21 81       	ldd	r18, Z+1	; 0x01
     4f8:	32 81       	ldd	r19, Z+2	; 0x02
     4fa:	89 81       	ldd	r24, Y+1	; 0x01
     4fc:	9a 81       	ldd	r25, Y+2	; 0x02
     4fe:	03 96       	adiw	r24, 0x03	; 3
     500:	28 17       	cp	r18, r24
     502:	39 07       	cpc	r19, r25
     504:	59 f4       	brne	.+22     	; 0x51c <vCoRoutineSchedule+0xb0>
     506:	e9 81       	ldd	r30, Y+1	; 0x01
     508:	fa 81       	ldd	r31, Y+2	; 0x02
     50a:	01 80       	ldd	r0, Z+1	; 0x01
     50c:	f2 81       	ldd	r31, Z+2	; 0x02
     50e:	e0 2d       	mov	r30, r0
     510:	82 81       	ldd	r24, Z+2	; 0x02
     512:	93 81       	ldd	r25, Z+3	; 0x03
     514:	e9 81       	ldd	r30, Y+1	; 0x01
     516:	fa 81       	ldd	r31, Y+2	; 0x02
     518:	92 83       	std	Z+2, r25	; 0x02
     51a:	81 83       	std	Z+1, r24	; 0x01
     51c:	e9 81       	ldd	r30, Y+1	; 0x01
     51e:	fa 81       	ldd	r31, Y+2	; 0x02
     520:	01 80       	ldd	r0, Z+1	; 0x01
     522:	f2 81       	ldd	r31, Z+2	; 0x02
     524:	e0 2d       	mov	r30, r0
     526:	86 81       	ldd	r24, Z+6	; 0x06
     528:	97 81       	ldd	r25, Z+7	; 0x07
     52a:	90 93 a9 00 	sts	0x00A9, r25
     52e:	80 93 a8 00 	sts	0x00A8, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     532:	e0 91 a8 00 	lds	r30, 0x00A8
     536:	f0 91 a9 00 	lds	r31, 0x00A9
     53a:	40 81       	ld	r20, Z
     53c:	51 81       	ldd	r21, Z+1	; 0x01
     53e:	80 91 a8 00 	lds	r24, 0x00A8
     542:	90 91 a9 00 	lds	r25, 0x00A9
     546:	e0 91 a8 00 	lds	r30, 0x00A8
     54a:	f0 91 a9 00 	lds	r31, 0x00A9
     54e:	27 89       	ldd	r18, Z+23	; 0x17
     550:	62 2f       	mov	r22, r18
     552:	fa 01       	movw	r30, r20
     554:	09 95       	icall

	return;
}
     556:	0f 90       	pop	r0
     558:	0f 90       	pop	r0
     55a:	cf 91       	pop	r28
     55c:	df 91       	pop	r29
     55e:	08 95       	ret

00000560 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     560:	df 93       	push	r29
     562:	cf 93       	push	r28
     564:	0f 92       	push	r0
     566:	cd b7       	in	r28, 0x3d	; 61
     568:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     56a:	19 82       	std	Y+1, r1	; 0x01
     56c:	13 c0       	rjmp	.+38     	; 0x594 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     56e:	89 81       	ldd	r24, Y+1	; 0x01
     570:	28 2f       	mov	r18, r24
     572:	30 e0       	ldi	r19, 0x00	; 0
     574:	c9 01       	movw	r24, r18
     576:	88 0f       	add	r24, r24
     578:	99 1f       	adc	r25, r25
     57a:	88 0f       	add	r24, r24
     57c:	99 1f       	adc	r25, r25
     57e:	88 0f       	add	r24, r24
     580:	99 1f       	adc	r25, r25
     582:	82 0f       	add	r24, r18
     584:	93 1f       	adc	r25, r19
     586:	8f 54       	subi	r24, 0x4F	; 79
     588:	9f 4f       	sbci	r25, 0xFF	; 255
     58a:	0e 94 8d 03 	call	0x71a	; 0x71a <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     58e:	89 81       	ldd	r24, Y+1	; 0x01
     590:	8f 5f       	subi	r24, 0xFF	; 255
     592:	89 83       	std	Y+1, r24	; 0x01
     594:	89 81       	ldd	r24, Y+1	; 0x01
     596:	82 30       	cpi	r24, 0x02	; 2
     598:	50 f3       	brcs	.-44     	; 0x56e <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     59a:	83 ec       	ldi	r24, 0xC3	; 195
     59c:	90 e0       	ldi	r25, 0x00	; 0
     59e:	0e 94 8d 03 	call	0x71a	; 0x71a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     5a2:	8c ec       	ldi	r24, 0xCC	; 204
     5a4:	90 e0       	ldi	r25, 0x00	; 0
     5a6:	0e 94 8d 03 	call	0x71a	; 0x71a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     5aa:	89 ed       	ldi	r24, 0xD9	; 217
     5ac:	90 e0       	ldi	r25, 0x00	; 0
     5ae:	0e 94 8d 03 	call	0x71a	; 0x71a <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     5b2:	83 ec       	ldi	r24, 0xC3	; 195
     5b4:	90 e0       	ldi	r25, 0x00	; 0
     5b6:	90 93 d6 00 	sts	0x00D6, r25
     5ba:	80 93 d5 00 	sts	0x00D5, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     5be:	8c ec       	ldi	r24, 0xCC	; 204
     5c0:	90 e0       	ldi	r25, 0x00	; 0
     5c2:	90 93 d8 00 	sts	0x00D8, r25
     5c6:	80 93 d7 00 	sts	0x00D7, r24
}
     5ca:	0f 90       	pop	r0
     5cc:	cf 91       	pop	r28
     5ce:	df 91       	pop	r29
     5d0:	08 95       	ret

000005d2 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     5d2:	df 93       	push	r29
     5d4:	cf 93       	push	r28
     5d6:	00 d0       	rcall	.+0      	; 0x5d8 <xCoRoutineRemoveFromEventList+0x6>
     5d8:	00 d0       	rcall	.+0      	; 0x5da <xCoRoutineRemoveFromEventList+0x8>
     5da:	0f 92       	push	r0
     5dc:	cd b7       	in	r28, 0x3d	; 61
     5de:	de b7       	in	r29, 0x3e	; 62
     5e0:	9d 83       	std	Y+5, r25	; 0x05
     5e2:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     5e4:	ec 81       	ldd	r30, Y+4	; 0x04
     5e6:	fd 81       	ldd	r31, Y+5	; 0x05
     5e8:	05 80       	ldd	r0, Z+5	; 0x05
     5ea:	f6 81       	ldd	r31, Z+6	; 0x06
     5ec:	e0 2d       	mov	r30, r0
     5ee:	86 81       	ldd	r24, Z+6	; 0x06
     5f0:	97 81       	ldd	r25, Z+7	; 0x07
     5f2:	9b 83       	std	Y+3, r25	; 0x03
     5f4:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     5f6:	8a 81       	ldd	r24, Y+2	; 0x02
     5f8:	9b 81       	ldd	r25, Y+3	; 0x03
     5fa:	0c 96       	adiw	r24, 0x0c	; 12
     5fc:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     600:	8a 81       	ldd	r24, Y+2	; 0x02
     602:	9b 81       	ldd	r25, Y+3	; 0x03
     604:	9c 01       	movw	r18, r24
     606:	24 5f       	subi	r18, 0xF4	; 244
     608:	3f 4f       	sbci	r19, 0xFF	; 255
     60a:	89 ed       	ldi	r24, 0xD9	; 217
     60c:	90 e0       	ldi	r25, 0x00	; 0
     60e:	b9 01       	movw	r22, r18
     610:	0e 94 c7 03 	call	0x78e	; 0x78e <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     614:	ea 81       	ldd	r30, Y+2	; 0x02
     616:	fb 81       	ldd	r31, Y+3	; 0x03
     618:	96 89       	ldd	r25, Z+22	; 0x16
     61a:	e0 91 a8 00 	lds	r30, 0x00A8
     61e:	f0 91 a9 00 	lds	r31, 0x00A9
     622:	86 89       	ldd	r24, Z+22	; 0x16
     624:	98 17       	cp	r25, r24
     626:	18 f0       	brcs	.+6      	; 0x62e <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     628:	81 e0       	ldi	r24, 0x01	; 1
     62a:	89 83       	std	Y+1, r24	; 0x01
     62c:	01 c0       	rjmp	.+2      	; 0x630 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     62e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     630:	89 81       	ldd	r24, Y+1	; 0x01
}
     632:	0f 90       	pop	r0
     634:	0f 90       	pop	r0
     636:	0f 90       	pop	r0
     638:	0f 90       	pop	r0
     63a:	0f 90       	pop	r0
     63c:	cf 91       	pop	r28
     63e:	df 91       	pop	r29
     640:	08 95       	ret

00000642 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     642:	df 93       	push	r29
     644:	cf 93       	push	r28
     646:	00 d0       	rcall	.+0      	; 0x648 <pvPortMalloc+0x6>
     648:	00 d0       	rcall	.+0      	; 0x64a <pvPortMalloc+0x8>
     64a:	cd b7       	in	r28, 0x3d	; 61
     64c:	de b7       	in	r29, 0x3e	; 62
     64e:	9c 83       	std	Y+4, r25	; 0x04
     650:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     652:	1a 82       	std	Y+2, r1	; 0x02
     654:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     656:	0e 94 57 0e 	call	0x1cae	; 0x1cae <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     65a:	80 91 e2 00 	lds	r24, 0x00E2
     65e:	90 91 e3 00 	lds	r25, 0x00E3
     662:	2b 81       	ldd	r18, Y+3	; 0x03
     664:	3c 81       	ldd	r19, Y+4	; 0x04
     666:	82 0f       	add	r24, r18
     668:	93 1f       	adc	r25, r19
     66a:	22 e0       	ldi	r18, 0x02	; 2
     66c:	88 35       	cpi	r24, 0x58	; 88
     66e:	92 07       	cpc	r25, r18
     670:	18 f5       	brcc	.+70     	; 0x6b8 <pvPortMalloc+0x76>
     672:	20 91 e2 00 	lds	r18, 0x00E2
     676:	30 91 e3 00 	lds	r19, 0x00E3
     67a:	8b 81       	ldd	r24, Y+3	; 0x03
     67c:	9c 81       	ldd	r25, Y+4	; 0x04
     67e:	28 0f       	add	r18, r24
     680:	39 1f       	adc	r19, r25
     682:	80 91 e2 00 	lds	r24, 0x00E2
     686:	90 91 e3 00 	lds	r25, 0x00E3
     68a:	82 17       	cp	r24, r18
     68c:	93 07       	cpc	r25, r19
     68e:	a0 f4       	brcc	.+40     	; 0x6b8 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     690:	80 91 e2 00 	lds	r24, 0x00E2
     694:	90 91 e3 00 	lds	r25, 0x00E3
     698:	8c 51       	subi	r24, 0x1C	; 28
     69a:	9f 4f       	sbci	r25, 0xFF	; 255
     69c:	9a 83       	std	Y+2, r25	; 0x02
     69e:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     6a0:	20 91 e2 00 	lds	r18, 0x00E2
     6a4:	30 91 e3 00 	lds	r19, 0x00E3
     6a8:	8b 81       	ldd	r24, Y+3	; 0x03
     6aa:	9c 81       	ldd	r25, Y+4	; 0x04
     6ac:	82 0f       	add	r24, r18
     6ae:	93 1f       	adc	r25, r19
     6b0:	90 93 e3 00 	sts	0x00E3, r25
     6b4:	80 93 e2 00 	sts	0x00E2, r24
		}	
	}
	xTaskResumeAll();
     6b8:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     6bc:	89 81       	ldd	r24, Y+1	; 0x01
     6be:	9a 81       	ldd	r25, Y+2	; 0x02
}
     6c0:	0f 90       	pop	r0
     6c2:	0f 90       	pop	r0
     6c4:	0f 90       	pop	r0
     6c6:	0f 90       	pop	r0
     6c8:	cf 91       	pop	r28
     6ca:	df 91       	pop	r29
     6cc:	08 95       	ret

000006ce <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     6ce:	df 93       	push	r29
     6d0:	cf 93       	push	r28
     6d2:	00 d0       	rcall	.+0      	; 0x6d4 <vPortFree+0x6>
     6d4:	cd b7       	in	r28, 0x3d	; 61
     6d6:	de b7       	in	r29, 0x3e	; 62
     6d8:	9a 83       	std	Y+2, r25	; 0x02
     6da:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     6dc:	0f 90       	pop	r0
     6de:	0f 90       	pop	r0
     6e0:	cf 91       	pop	r28
     6e2:	df 91       	pop	r29
     6e4:	08 95       	ret

000006e6 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     6e6:	df 93       	push	r29
     6e8:	cf 93       	push	r28
     6ea:	cd b7       	in	r28, 0x3d	; 61
     6ec:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     6ee:	10 92 e3 00 	sts	0x00E3, r1
     6f2:	10 92 e2 00 	sts	0x00E2, r1
}
     6f6:	cf 91       	pop	r28
     6f8:	df 91       	pop	r29
     6fa:	08 95       	ret

000006fc <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     6fc:	df 93       	push	r29
     6fe:	cf 93       	push	r28
     700:	cd b7       	in	r28, 0x3d	; 61
     702:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     704:	20 91 e2 00 	lds	r18, 0x00E2
     708:	30 91 e3 00 	lds	r19, 0x00E3
     70c:	88 e5       	ldi	r24, 0x58	; 88
     70e:	92 e0       	ldi	r25, 0x02	; 2
     710:	82 1b       	sub	r24, r18
     712:	93 0b       	sbc	r25, r19
}
     714:	cf 91       	pop	r28
     716:	df 91       	pop	r29
     718:	08 95       	ret

0000071a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     71a:	df 93       	push	r29
     71c:	cf 93       	push	r28
     71e:	00 d0       	rcall	.+0      	; 0x720 <vListInitialise+0x6>
     720:	cd b7       	in	r28, 0x3d	; 61
     722:	de b7       	in	r29, 0x3e	; 62
     724:	9a 83       	std	Y+2, r25	; 0x02
     726:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     728:	89 81       	ldd	r24, Y+1	; 0x01
     72a:	9a 81       	ldd	r25, Y+2	; 0x02
     72c:	03 96       	adiw	r24, 0x03	; 3
     72e:	e9 81       	ldd	r30, Y+1	; 0x01
     730:	fa 81       	ldd	r31, Y+2	; 0x02
     732:	92 83       	std	Z+2, r25	; 0x02
     734:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     736:	e9 81       	ldd	r30, Y+1	; 0x01
     738:	fa 81       	ldd	r31, Y+2	; 0x02
     73a:	8f ef       	ldi	r24, 0xFF	; 255
     73c:	9f ef       	ldi	r25, 0xFF	; 255
     73e:	94 83       	std	Z+4, r25	; 0x04
     740:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     742:	89 81       	ldd	r24, Y+1	; 0x01
     744:	9a 81       	ldd	r25, Y+2	; 0x02
     746:	03 96       	adiw	r24, 0x03	; 3
     748:	e9 81       	ldd	r30, Y+1	; 0x01
     74a:	fa 81       	ldd	r31, Y+2	; 0x02
     74c:	96 83       	std	Z+6, r25	; 0x06
     74e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     750:	89 81       	ldd	r24, Y+1	; 0x01
     752:	9a 81       	ldd	r25, Y+2	; 0x02
     754:	03 96       	adiw	r24, 0x03	; 3
     756:	e9 81       	ldd	r30, Y+1	; 0x01
     758:	fa 81       	ldd	r31, Y+2	; 0x02
     75a:	90 87       	std	Z+8, r25	; 0x08
     75c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     75e:	e9 81       	ldd	r30, Y+1	; 0x01
     760:	fa 81       	ldd	r31, Y+2	; 0x02
     762:	10 82       	st	Z, r1
}
     764:	0f 90       	pop	r0
     766:	0f 90       	pop	r0
     768:	cf 91       	pop	r28
     76a:	df 91       	pop	r29
     76c:	08 95       	ret

0000076e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     76e:	df 93       	push	r29
     770:	cf 93       	push	r28
     772:	00 d0       	rcall	.+0      	; 0x774 <vListInitialiseItem+0x6>
     774:	cd b7       	in	r28, 0x3d	; 61
     776:	de b7       	in	r29, 0x3e	; 62
     778:	9a 83       	std	Y+2, r25	; 0x02
     77a:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     77c:	e9 81       	ldd	r30, Y+1	; 0x01
     77e:	fa 81       	ldd	r31, Y+2	; 0x02
     780:	11 86       	std	Z+9, r1	; 0x09
     782:	10 86       	std	Z+8, r1	; 0x08
}
     784:	0f 90       	pop	r0
     786:	0f 90       	pop	r0
     788:	cf 91       	pop	r28
     78a:	df 91       	pop	r29
     78c:	08 95       	ret

0000078e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     78e:	df 93       	push	r29
     790:	cf 93       	push	r28
     792:	00 d0       	rcall	.+0      	; 0x794 <vListInsertEnd+0x6>
     794:	00 d0       	rcall	.+0      	; 0x796 <vListInsertEnd+0x8>
     796:	00 d0       	rcall	.+0      	; 0x798 <vListInsertEnd+0xa>
     798:	cd b7       	in	r28, 0x3d	; 61
     79a:	de b7       	in	r29, 0x3e	; 62
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	8b 83       	std	Y+3, r24	; 0x03
     7a0:	7e 83       	std	Y+6, r23	; 0x06
     7a2:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     7a4:	eb 81       	ldd	r30, Y+3	; 0x03
     7a6:	fc 81       	ldd	r31, Y+4	; 0x04
     7a8:	81 81       	ldd	r24, Z+1	; 0x01
     7aa:	92 81       	ldd	r25, Z+2	; 0x02
     7ac:	9a 83       	std	Y+2, r25	; 0x02
     7ae:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     7b0:	e9 81       	ldd	r30, Y+1	; 0x01
     7b2:	fa 81       	ldd	r31, Y+2	; 0x02
     7b4:	82 81       	ldd	r24, Z+2	; 0x02
     7b6:	93 81       	ldd	r25, Z+3	; 0x03
     7b8:	ed 81       	ldd	r30, Y+5	; 0x05
     7ba:	fe 81       	ldd	r31, Y+6	; 0x06
     7bc:	93 83       	std	Z+3, r25	; 0x03
     7be:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     7c0:	eb 81       	ldd	r30, Y+3	; 0x03
     7c2:	fc 81       	ldd	r31, Y+4	; 0x04
     7c4:	81 81       	ldd	r24, Z+1	; 0x01
     7c6:	92 81       	ldd	r25, Z+2	; 0x02
     7c8:	ed 81       	ldd	r30, Y+5	; 0x05
     7ca:	fe 81       	ldd	r31, Y+6	; 0x06
     7cc:	95 83       	std	Z+5, r25	; 0x05
     7ce:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     7d0:	e9 81       	ldd	r30, Y+1	; 0x01
     7d2:	fa 81       	ldd	r31, Y+2	; 0x02
     7d4:	02 80       	ldd	r0, Z+2	; 0x02
     7d6:	f3 81       	ldd	r31, Z+3	; 0x03
     7d8:	e0 2d       	mov	r30, r0
     7da:	8d 81       	ldd	r24, Y+5	; 0x05
     7dc:	9e 81       	ldd	r25, Y+6	; 0x06
     7de:	95 83       	std	Z+5, r25	; 0x05
     7e0:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     7e2:	8d 81       	ldd	r24, Y+5	; 0x05
     7e4:	9e 81       	ldd	r25, Y+6	; 0x06
     7e6:	e9 81       	ldd	r30, Y+1	; 0x01
     7e8:	fa 81       	ldd	r31, Y+2	; 0x02
     7ea:	93 83       	std	Z+3, r25	; 0x03
     7ec:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     7ee:	8d 81       	ldd	r24, Y+5	; 0x05
     7f0:	9e 81       	ldd	r25, Y+6	; 0x06
     7f2:	eb 81       	ldd	r30, Y+3	; 0x03
     7f4:	fc 81       	ldd	r31, Y+4	; 0x04
     7f6:	92 83       	std	Z+2, r25	; 0x02
     7f8:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     7fa:	ed 81       	ldd	r30, Y+5	; 0x05
     7fc:	fe 81       	ldd	r31, Y+6	; 0x06
     7fe:	8b 81       	ldd	r24, Y+3	; 0x03
     800:	9c 81       	ldd	r25, Y+4	; 0x04
     802:	91 87       	std	Z+9, r25	; 0x09
     804:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     806:	eb 81       	ldd	r30, Y+3	; 0x03
     808:	fc 81       	ldd	r31, Y+4	; 0x04
     80a:	80 81       	ld	r24, Z
     80c:	8f 5f       	subi	r24, 0xFF	; 255
     80e:	eb 81       	ldd	r30, Y+3	; 0x03
     810:	fc 81       	ldd	r31, Y+4	; 0x04
     812:	80 83       	st	Z, r24
}
     814:	26 96       	adiw	r28, 0x06	; 6
     816:	0f b6       	in	r0, 0x3f	; 63
     818:	f8 94       	cli
     81a:	de bf       	out	0x3e, r29	; 62
     81c:	0f be       	out	0x3f, r0	; 63
     81e:	cd bf       	out	0x3d, r28	; 61
     820:	cf 91       	pop	r28
     822:	df 91       	pop	r29
     824:	08 95       	ret

00000826 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     826:	df 93       	push	r29
     828:	cf 93       	push	r28
     82a:	cd b7       	in	r28, 0x3d	; 61
     82c:	de b7       	in	r29, 0x3e	; 62
     82e:	28 97       	sbiw	r28, 0x08	; 8
     830:	0f b6       	in	r0, 0x3f	; 63
     832:	f8 94       	cli
     834:	de bf       	out	0x3e, r29	; 62
     836:	0f be       	out	0x3f, r0	; 63
     838:	cd bf       	out	0x3d, r28	; 61
     83a:	9e 83       	std	Y+6, r25	; 0x06
     83c:	8d 83       	std	Y+5, r24	; 0x05
     83e:	78 87       	std	Y+8, r23	; 0x08
     840:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     842:	ef 81       	ldd	r30, Y+7	; 0x07
     844:	f8 85       	ldd	r31, Y+8	; 0x08
     846:	80 81       	ld	r24, Z
     848:	91 81       	ldd	r25, Z+1	; 0x01
     84a:	9a 83       	std	Y+2, r25	; 0x02
     84c:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     84e:	89 81       	ldd	r24, Y+1	; 0x01
     850:	9a 81       	ldd	r25, Y+2	; 0x02
     852:	2f ef       	ldi	r18, 0xFF	; 255
     854:	8f 3f       	cpi	r24, 0xFF	; 255
     856:	92 07       	cpc	r25, r18
     858:	39 f4       	brne	.+14     	; 0x868 <__stack+0x9>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     85a:	ed 81       	ldd	r30, Y+5	; 0x05
     85c:	fe 81       	ldd	r31, Y+6	; 0x06
     85e:	87 81       	ldd	r24, Z+7	; 0x07
     860:	90 85       	ldd	r25, Z+8	; 0x08
     862:	9c 83       	std	Y+4, r25	; 0x04
     864:	8b 83       	std	Y+3, r24	; 0x03
     866:	18 c0       	rjmp	.+48     	; 0x898 <__stack+0x39>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     868:	8d 81       	ldd	r24, Y+5	; 0x05
     86a:	9e 81       	ldd	r25, Y+6	; 0x06
     86c:	03 96       	adiw	r24, 0x03	; 3
     86e:	9c 83       	std	Y+4, r25	; 0x04
     870:	8b 83       	std	Y+3, r24	; 0x03
     872:	06 c0       	rjmp	.+12     	; 0x880 <__stack+0x21>
     874:	eb 81       	ldd	r30, Y+3	; 0x03
     876:	fc 81       	ldd	r31, Y+4	; 0x04
     878:	82 81       	ldd	r24, Z+2	; 0x02
     87a:	93 81       	ldd	r25, Z+3	; 0x03
     87c:	9c 83       	std	Y+4, r25	; 0x04
     87e:	8b 83       	std	Y+3, r24	; 0x03
     880:	eb 81       	ldd	r30, Y+3	; 0x03
     882:	fc 81       	ldd	r31, Y+4	; 0x04
     884:	02 80       	ldd	r0, Z+2	; 0x02
     886:	f3 81       	ldd	r31, Z+3	; 0x03
     888:	e0 2d       	mov	r30, r0
     88a:	20 81       	ld	r18, Z
     88c:	31 81       	ldd	r19, Z+1	; 0x01
     88e:	89 81       	ldd	r24, Y+1	; 0x01
     890:	9a 81       	ldd	r25, Y+2	; 0x02
     892:	82 17       	cp	r24, r18
     894:	93 07       	cpc	r25, r19
     896:	70 f7       	brcc	.-36     	; 0x874 <__stack+0x15>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     898:	eb 81       	ldd	r30, Y+3	; 0x03
     89a:	fc 81       	ldd	r31, Y+4	; 0x04
     89c:	82 81       	ldd	r24, Z+2	; 0x02
     89e:	93 81       	ldd	r25, Z+3	; 0x03
     8a0:	ef 81       	ldd	r30, Y+7	; 0x07
     8a2:	f8 85       	ldd	r31, Y+8	; 0x08
     8a4:	93 83       	std	Z+3, r25	; 0x03
     8a6:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     8a8:	ef 81       	ldd	r30, Y+7	; 0x07
     8aa:	f8 85       	ldd	r31, Y+8	; 0x08
     8ac:	02 80       	ldd	r0, Z+2	; 0x02
     8ae:	f3 81       	ldd	r31, Z+3	; 0x03
     8b0:	e0 2d       	mov	r30, r0
     8b2:	8f 81       	ldd	r24, Y+7	; 0x07
     8b4:	98 85       	ldd	r25, Y+8	; 0x08
     8b6:	95 83       	std	Z+5, r25	; 0x05
     8b8:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     8ba:	ef 81       	ldd	r30, Y+7	; 0x07
     8bc:	f8 85       	ldd	r31, Y+8	; 0x08
     8be:	8b 81       	ldd	r24, Y+3	; 0x03
     8c0:	9c 81       	ldd	r25, Y+4	; 0x04
     8c2:	95 83       	std	Z+5, r25	; 0x05
     8c4:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     8c6:	8f 81       	ldd	r24, Y+7	; 0x07
     8c8:	98 85       	ldd	r25, Y+8	; 0x08
     8ca:	eb 81       	ldd	r30, Y+3	; 0x03
     8cc:	fc 81       	ldd	r31, Y+4	; 0x04
     8ce:	93 83       	std	Z+3, r25	; 0x03
     8d0:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8d2:	ef 81       	ldd	r30, Y+7	; 0x07
     8d4:	f8 85       	ldd	r31, Y+8	; 0x08
     8d6:	8d 81       	ldd	r24, Y+5	; 0x05
     8d8:	9e 81       	ldd	r25, Y+6	; 0x06
     8da:	91 87       	std	Z+9, r25	; 0x09
     8dc:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     8de:	ed 81       	ldd	r30, Y+5	; 0x05
     8e0:	fe 81       	ldd	r31, Y+6	; 0x06
     8e2:	80 81       	ld	r24, Z
     8e4:	8f 5f       	subi	r24, 0xFF	; 255
     8e6:	ed 81       	ldd	r30, Y+5	; 0x05
     8e8:	fe 81       	ldd	r31, Y+6	; 0x06
     8ea:	80 83       	st	Z, r24
}
     8ec:	28 96       	adiw	r28, 0x08	; 8
     8ee:	0f b6       	in	r0, 0x3f	; 63
     8f0:	f8 94       	cli
     8f2:	de bf       	out	0x3e, r29	; 62
     8f4:	0f be       	out	0x3f, r0	; 63
     8f6:	cd bf       	out	0x3d, r28	; 61
     8f8:	cf 91       	pop	r28
     8fa:	df 91       	pop	r29
     8fc:	08 95       	ret

000008fe <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     8fe:	df 93       	push	r29
     900:	cf 93       	push	r28
     902:	00 d0       	rcall	.+0      	; 0x904 <vListRemove+0x6>
     904:	00 d0       	rcall	.+0      	; 0x906 <vListRemove+0x8>
     906:	cd b7       	in	r28, 0x3d	; 61
     908:	de b7       	in	r29, 0x3e	; 62
     90a:	9c 83       	std	Y+4, r25	; 0x04
     90c:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     90e:	eb 81       	ldd	r30, Y+3	; 0x03
     910:	fc 81       	ldd	r31, Y+4	; 0x04
     912:	a2 81       	ldd	r26, Z+2	; 0x02
     914:	b3 81       	ldd	r27, Z+3	; 0x03
     916:	eb 81       	ldd	r30, Y+3	; 0x03
     918:	fc 81       	ldd	r31, Y+4	; 0x04
     91a:	84 81       	ldd	r24, Z+4	; 0x04
     91c:	95 81       	ldd	r25, Z+5	; 0x05
     91e:	15 96       	adiw	r26, 0x05	; 5
     920:	9c 93       	st	X, r25
     922:	8e 93       	st	-X, r24
     924:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     926:	eb 81       	ldd	r30, Y+3	; 0x03
     928:	fc 81       	ldd	r31, Y+4	; 0x04
     92a:	a4 81       	ldd	r26, Z+4	; 0x04
     92c:	b5 81       	ldd	r27, Z+5	; 0x05
     92e:	eb 81       	ldd	r30, Y+3	; 0x03
     930:	fc 81       	ldd	r31, Y+4	; 0x04
     932:	82 81       	ldd	r24, Z+2	; 0x02
     934:	93 81       	ldd	r25, Z+3	; 0x03
     936:	13 96       	adiw	r26, 0x03	; 3
     938:	9c 93       	st	X, r25
     93a:	8e 93       	st	-X, r24
     93c:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     93e:	eb 81       	ldd	r30, Y+3	; 0x03
     940:	fc 81       	ldd	r31, Y+4	; 0x04
     942:	80 85       	ldd	r24, Z+8	; 0x08
     944:	91 85       	ldd	r25, Z+9	; 0x09
     946:	9a 83       	std	Y+2, r25	; 0x02
     948:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     94a:	e9 81       	ldd	r30, Y+1	; 0x01
     94c:	fa 81       	ldd	r31, Y+2	; 0x02
     94e:	21 81       	ldd	r18, Z+1	; 0x01
     950:	32 81       	ldd	r19, Z+2	; 0x02
     952:	8b 81       	ldd	r24, Y+3	; 0x03
     954:	9c 81       	ldd	r25, Y+4	; 0x04
     956:	28 17       	cp	r18, r24
     958:	39 07       	cpc	r19, r25
     95a:	41 f4       	brne	.+16     	; 0x96c <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     95c:	eb 81       	ldd	r30, Y+3	; 0x03
     95e:	fc 81       	ldd	r31, Y+4	; 0x04
     960:	84 81       	ldd	r24, Z+4	; 0x04
     962:	95 81       	ldd	r25, Z+5	; 0x05
     964:	e9 81       	ldd	r30, Y+1	; 0x01
     966:	fa 81       	ldd	r31, Y+2	; 0x02
     968:	92 83       	std	Z+2, r25	; 0x02
     96a:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     96c:	eb 81       	ldd	r30, Y+3	; 0x03
     96e:	fc 81       	ldd	r31, Y+4	; 0x04
     970:	11 86       	std	Z+9, r1	; 0x09
     972:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     974:	e9 81       	ldd	r30, Y+1	; 0x01
     976:	fa 81       	ldd	r31, Y+2	; 0x02
     978:	80 81       	ld	r24, Z
     97a:	81 50       	subi	r24, 0x01	; 1
     97c:	e9 81       	ldd	r30, Y+1	; 0x01
     97e:	fa 81       	ldd	r31, Y+2	; 0x02
     980:	80 83       	st	Z, r24
}
     982:	0f 90       	pop	r0
     984:	0f 90       	pop	r0
     986:	0f 90       	pop	r0
     988:	0f 90       	pop	r0
     98a:	cf 91       	pop	r28
     98c:	df 91       	pop	r29
     98e:	08 95       	ret

00000990 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
     990:	df 93       	push	r29
     992:	cf 93       	push	r28
     994:	cd b7       	in	r28, 0x3d	; 61
     996:	de b7       	in	r29, 0x3e	; 62
     998:	28 97       	sbiw	r28, 0x08	; 8
     99a:	0f b6       	in	r0, 0x3f	; 63
     99c:	f8 94       	cli
     99e:	de bf       	out	0x3e, r29	; 62
     9a0:	0f be       	out	0x3f, r0	; 63
     9a2:	cd bf       	out	0x3d, r28	; 61
     9a4:	9c 83       	std	Y+4, r25	; 0x04
     9a6:	8b 83       	std	Y+3, r24	; 0x03
     9a8:	7e 83       	std	Y+6, r23	; 0x06
     9aa:	6d 83       	std	Y+5, r22	; 0x05
     9ac:	58 87       	std	Y+8, r21	; 0x08
     9ae:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     9b0:	eb 81       	ldd	r30, Y+3	; 0x03
     9b2:	fc 81       	ldd	r31, Y+4	; 0x04
     9b4:	81 e1       	ldi	r24, 0x11	; 17
     9b6:	80 83       	st	Z, r24
	pxTopOfStack--;
     9b8:	8b 81       	ldd	r24, Y+3	; 0x03
     9ba:	9c 81       	ldd	r25, Y+4	; 0x04
     9bc:	01 97       	sbiw	r24, 0x01	; 1
     9be:	9c 83       	std	Y+4, r25	; 0x04
     9c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     9c2:	eb 81       	ldd	r30, Y+3	; 0x03
     9c4:	fc 81       	ldd	r31, Y+4	; 0x04
     9c6:	82 e2       	ldi	r24, 0x22	; 34
     9c8:	80 83       	st	Z, r24
	pxTopOfStack--;
     9ca:	8b 81       	ldd	r24, Y+3	; 0x03
     9cc:	9c 81       	ldd	r25, Y+4	; 0x04
     9ce:	01 97       	sbiw	r24, 0x01	; 1
     9d0:	9c 83       	std	Y+4, r25	; 0x04
     9d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     9d4:	eb 81       	ldd	r30, Y+3	; 0x03
     9d6:	fc 81       	ldd	r31, Y+4	; 0x04
     9d8:	83 e3       	ldi	r24, 0x33	; 51
     9da:	80 83       	st	Z, r24
	pxTopOfStack--;
     9dc:	8b 81       	ldd	r24, Y+3	; 0x03
     9de:	9c 81       	ldd	r25, Y+4	; 0x04
     9e0:	01 97       	sbiw	r24, 0x01	; 1
     9e2:	9c 83       	std	Y+4, r25	; 0x04
     9e4:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
     9e6:	8d 81       	ldd	r24, Y+5	; 0x05
     9e8:	9e 81       	ldd	r25, Y+6	; 0x06
     9ea:	9a 83       	std	Y+2, r25	; 0x02
     9ec:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     9ee:	89 81       	ldd	r24, Y+1	; 0x01
     9f0:	eb 81       	ldd	r30, Y+3	; 0x03
     9f2:	fc 81       	ldd	r31, Y+4	; 0x04
     9f4:	80 83       	st	Z, r24
	pxTopOfStack--;
     9f6:	8b 81       	ldd	r24, Y+3	; 0x03
     9f8:	9c 81       	ldd	r25, Y+4	; 0x04
     9fa:	01 97       	sbiw	r24, 0x01	; 1
     9fc:	9c 83       	std	Y+4, r25	; 0x04
     9fe:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     a00:	89 81       	ldd	r24, Y+1	; 0x01
     a02:	9a 81       	ldd	r25, Y+2	; 0x02
     a04:	89 2f       	mov	r24, r25
     a06:	99 27       	eor	r25, r25
     a08:	9a 83       	std	Y+2, r25	; 0x02
     a0a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     a0c:	89 81       	ldd	r24, Y+1	; 0x01
     a0e:	eb 81       	ldd	r30, Y+3	; 0x03
     a10:	fc 81       	ldd	r31, Y+4	; 0x04
     a12:	80 83       	st	Z, r24
	pxTopOfStack--;
     a14:	8b 81       	ldd	r24, Y+3	; 0x03
     a16:	9c 81       	ldd	r25, Y+4	; 0x04
     a18:	01 97       	sbiw	r24, 0x01	; 1
     a1a:	9c 83       	std	Y+4, r25	; 0x04
     a1c:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     a1e:	eb 81       	ldd	r30, Y+3	; 0x03
     a20:	fc 81       	ldd	r31, Y+4	; 0x04
     a22:	10 82       	st	Z, r1
	pxTopOfStack--;
     a24:	8b 81       	ldd	r24, Y+3	; 0x03
     a26:	9c 81       	ldd	r25, Y+4	; 0x04
     a28:	01 97       	sbiw	r24, 0x01	; 1
     a2a:	9c 83       	std	Y+4, r25	; 0x04
     a2c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     a2e:	eb 81       	ldd	r30, Y+3	; 0x03
     a30:	fc 81       	ldd	r31, Y+4	; 0x04
     a32:	80 e8       	ldi	r24, 0x80	; 128
     a34:	80 83       	st	Z, r24
	pxTopOfStack--;
     a36:	8b 81       	ldd	r24, Y+3	; 0x03
     a38:	9c 81       	ldd	r25, Y+4	; 0x04
     a3a:	01 97       	sbiw	r24, 0x01	; 1
     a3c:	9c 83       	std	Y+4, r25	; 0x04
     a3e:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     a40:	eb 81       	ldd	r30, Y+3	; 0x03
     a42:	fc 81       	ldd	r31, Y+4	; 0x04
     a44:	10 82       	st	Z, r1
	pxTopOfStack--;
     a46:	8b 81       	ldd	r24, Y+3	; 0x03
     a48:	9c 81       	ldd	r25, Y+4	; 0x04
     a4a:	01 97       	sbiw	r24, 0x01	; 1
     a4c:	9c 83       	std	Y+4, r25	; 0x04
     a4e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     a50:	eb 81       	ldd	r30, Y+3	; 0x03
     a52:	fc 81       	ldd	r31, Y+4	; 0x04
     a54:	82 e0       	ldi	r24, 0x02	; 2
     a56:	80 83       	st	Z, r24
	pxTopOfStack--;
     a58:	8b 81       	ldd	r24, Y+3	; 0x03
     a5a:	9c 81       	ldd	r25, Y+4	; 0x04
     a5c:	01 97       	sbiw	r24, 0x01	; 1
     a5e:	9c 83       	std	Y+4, r25	; 0x04
     a60:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     a62:	eb 81       	ldd	r30, Y+3	; 0x03
     a64:	fc 81       	ldd	r31, Y+4	; 0x04
     a66:	83 e0       	ldi	r24, 0x03	; 3
     a68:	80 83       	st	Z, r24
	pxTopOfStack--;
     a6a:	8b 81       	ldd	r24, Y+3	; 0x03
     a6c:	9c 81       	ldd	r25, Y+4	; 0x04
     a6e:	01 97       	sbiw	r24, 0x01	; 1
     a70:	9c 83       	std	Y+4, r25	; 0x04
     a72:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     a74:	eb 81       	ldd	r30, Y+3	; 0x03
     a76:	fc 81       	ldd	r31, Y+4	; 0x04
     a78:	84 e0       	ldi	r24, 0x04	; 4
     a7a:	80 83       	st	Z, r24
	pxTopOfStack--;
     a7c:	8b 81       	ldd	r24, Y+3	; 0x03
     a7e:	9c 81       	ldd	r25, Y+4	; 0x04
     a80:	01 97       	sbiw	r24, 0x01	; 1
     a82:	9c 83       	std	Y+4, r25	; 0x04
     a84:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     a86:	eb 81       	ldd	r30, Y+3	; 0x03
     a88:	fc 81       	ldd	r31, Y+4	; 0x04
     a8a:	85 e0       	ldi	r24, 0x05	; 5
     a8c:	80 83       	st	Z, r24
	pxTopOfStack--;
     a8e:	8b 81       	ldd	r24, Y+3	; 0x03
     a90:	9c 81       	ldd	r25, Y+4	; 0x04
     a92:	01 97       	sbiw	r24, 0x01	; 1
     a94:	9c 83       	std	Y+4, r25	; 0x04
     a96:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     a98:	eb 81       	ldd	r30, Y+3	; 0x03
     a9a:	fc 81       	ldd	r31, Y+4	; 0x04
     a9c:	86 e0       	ldi	r24, 0x06	; 6
     a9e:	80 83       	st	Z, r24
	pxTopOfStack--;
     aa0:	8b 81       	ldd	r24, Y+3	; 0x03
     aa2:	9c 81       	ldd	r25, Y+4	; 0x04
     aa4:	01 97       	sbiw	r24, 0x01	; 1
     aa6:	9c 83       	std	Y+4, r25	; 0x04
     aa8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     aaa:	eb 81       	ldd	r30, Y+3	; 0x03
     aac:	fc 81       	ldd	r31, Y+4	; 0x04
     aae:	87 e0       	ldi	r24, 0x07	; 7
     ab0:	80 83       	st	Z, r24
	pxTopOfStack--;
     ab2:	8b 81       	ldd	r24, Y+3	; 0x03
     ab4:	9c 81       	ldd	r25, Y+4	; 0x04
     ab6:	01 97       	sbiw	r24, 0x01	; 1
     ab8:	9c 83       	std	Y+4, r25	; 0x04
     aba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     abc:	eb 81       	ldd	r30, Y+3	; 0x03
     abe:	fc 81       	ldd	r31, Y+4	; 0x04
     ac0:	88 e0       	ldi	r24, 0x08	; 8
     ac2:	80 83       	st	Z, r24
	pxTopOfStack--;
     ac4:	8b 81       	ldd	r24, Y+3	; 0x03
     ac6:	9c 81       	ldd	r25, Y+4	; 0x04
     ac8:	01 97       	sbiw	r24, 0x01	; 1
     aca:	9c 83       	std	Y+4, r25	; 0x04
     acc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     ace:	eb 81       	ldd	r30, Y+3	; 0x03
     ad0:	fc 81       	ldd	r31, Y+4	; 0x04
     ad2:	89 e0       	ldi	r24, 0x09	; 9
     ad4:	80 83       	st	Z, r24
	pxTopOfStack--;
     ad6:	8b 81       	ldd	r24, Y+3	; 0x03
     ad8:	9c 81       	ldd	r25, Y+4	; 0x04
     ada:	01 97       	sbiw	r24, 0x01	; 1
     adc:	9c 83       	std	Y+4, r25	; 0x04
     ade:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     ae0:	eb 81       	ldd	r30, Y+3	; 0x03
     ae2:	fc 81       	ldd	r31, Y+4	; 0x04
     ae4:	80 e1       	ldi	r24, 0x10	; 16
     ae6:	80 83       	st	Z, r24
	pxTopOfStack--;
     ae8:	8b 81       	ldd	r24, Y+3	; 0x03
     aea:	9c 81       	ldd	r25, Y+4	; 0x04
     aec:	01 97       	sbiw	r24, 0x01	; 1
     aee:	9c 83       	std	Y+4, r25	; 0x04
     af0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     af2:	eb 81       	ldd	r30, Y+3	; 0x03
     af4:	fc 81       	ldd	r31, Y+4	; 0x04
     af6:	81 e1       	ldi	r24, 0x11	; 17
     af8:	80 83       	st	Z, r24
	pxTopOfStack--;
     afa:	8b 81       	ldd	r24, Y+3	; 0x03
     afc:	9c 81       	ldd	r25, Y+4	; 0x04
     afe:	01 97       	sbiw	r24, 0x01	; 1
     b00:	9c 83       	std	Y+4, r25	; 0x04
     b02:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     b04:	eb 81       	ldd	r30, Y+3	; 0x03
     b06:	fc 81       	ldd	r31, Y+4	; 0x04
     b08:	82 e1       	ldi	r24, 0x12	; 18
     b0a:	80 83       	st	Z, r24
	pxTopOfStack--;
     b0c:	8b 81       	ldd	r24, Y+3	; 0x03
     b0e:	9c 81       	ldd	r25, Y+4	; 0x04
     b10:	01 97       	sbiw	r24, 0x01	; 1
     b12:	9c 83       	std	Y+4, r25	; 0x04
     b14:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     b16:	eb 81       	ldd	r30, Y+3	; 0x03
     b18:	fc 81       	ldd	r31, Y+4	; 0x04
     b1a:	83 e1       	ldi	r24, 0x13	; 19
     b1c:	80 83       	st	Z, r24
	pxTopOfStack--;
     b1e:	8b 81       	ldd	r24, Y+3	; 0x03
     b20:	9c 81       	ldd	r25, Y+4	; 0x04
     b22:	01 97       	sbiw	r24, 0x01	; 1
     b24:	9c 83       	std	Y+4, r25	; 0x04
     b26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     b28:	eb 81       	ldd	r30, Y+3	; 0x03
     b2a:	fc 81       	ldd	r31, Y+4	; 0x04
     b2c:	84 e1       	ldi	r24, 0x14	; 20
     b2e:	80 83       	st	Z, r24
	pxTopOfStack--;
     b30:	8b 81       	ldd	r24, Y+3	; 0x03
     b32:	9c 81       	ldd	r25, Y+4	; 0x04
     b34:	01 97       	sbiw	r24, 0x01	; 1
     b36:	9c 83       	std	Y+4, r25	; 0x04
     b38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     b3a:	eb 81       	ldd	r30, Y+3	; 0x03
     b3c:	fc 81       	ldd	r31, Y+4	; 0x04
     b3e:	85 e1       	ldi	r24, 0x15	; 21
     b40:	80 83       	st	Z, r24
	pxTopOfStack--;
     b42:	8b 81       	ldd	r24, Y+3	; 0x03
     b44:	9c 81       	ldd	r25, Y+4	; 0x04
     b46:	01 97       	sbiw	r24, 0x01	; 1
     b48:	9c 83       	std	Y+4, r25	; 0x04
     b4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     b4c:	eb 81       	ldd	r30, Y+3	; 0x03
     b4e:	fc 81       	ldd	r31, Y+4	; 0x04
     b50:	86 e1       	ldi	r24, 0x16	; 22
     b52:	80 83       	st	Z, r24
	pxTopOfStack--;
     b54:	8b 81       	ldd	r24, Y+3	; 0x03
     b56:	9c 81       	ldd	r25, Y+4	; 0x04
     b58:	01 97       	sbiw	r24, 0x01	; 1
     b5a:	9c 83       	std	Y+4, r25	; 0x04
     b5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     b5e:	eb 81       	ldd	r30, Y+3	; 0x03
     b60:	fc 81       	ldd	r31, Y+4	; 0x04
     b62:	87 e1       	ldi	r24, 0x17	; 23
     b64:	80 83       	st	Z, r24
	pxTopOfStack--;
     b66:	8b 81       	ldd	r24, Y+3	; 0x03
     b68:	9c 81       	ldd	r25, Y+4	; 0x04
     b6a:	01 97       	sbiw	r24, 0x01	; 1
     b6c:	9c 83       	std	Y+4, r25	; 0x04
     b6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     b70:	eb 81       	ldd	r30, Y+3	; 0x03
     b72:	fc 81       	ldd	r31, Y+4	; 0x04
     b74:	88 e1       	ldi	r24, 0x18	; 24
     b76:	80 83       	st	Z, r24
	pxTopOfStack--;
     b78:	8b 81       	ldd	r24, Y+3	; 0x03
     b7a:	9c 81       	ldd	r25, Y+4	; 0x04
     b7c:	01 97       	sbiw	r24, 0x01	; 1
     b7e:	9c 83       	std	Y+4, r25	; 0x04
     b80:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     b82:	eb 81       	ldd	r30, Y+3	; 0x03
     b84:	fc 81       	ldd	r31, Y+4	; 0x04
     b86:	89 e1       	ldi	r24, 0x19	; 25
     b88:	80 83       	st	Z, r24
	pxTopOfStack--;
     b8a:	8b 81       	ldd	r24, Y+3	; 0x03
     b8c:	9c 81       	ldd	r25, Y+4	; 0x04
     b8e:	01 97       	sbiw	r24, 0x01	; 1
     b90:	9c 83       	std	Y+4, r25	; 0x04
     b92:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     b94:	eb 81       	ldd	r30, Y+3	; 0x03
     b96:	fc 81       	ldd	r31, Y+4	; 0x04
     b98:	80 e2       	ldi	r24, 0x20	; 32
     b9a:	80 83       	st	Z, r24
	pxTopOfStack--;
     b9c:	8b 81       	ldd	r24, Y+3	; 0x03
     b9e:	9c 81       	ldd	r25, Y+4	; 0x04
     ba0:	01 97       	sbiw	r24, 0x01	; 1
     ba2:	9c 83       	std	Y+4, r25	; 0x04
     ba4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     ba6:	eb 81       	ldd	r30, Y+3	; 0x03
     ba8:	fc 81       	ldd	r31, Y+4	; 0x04
     baa:	81 e2       	ldi	r24, 0x21	; 33
     bac:	80 83       	st	Z, r24
	pxTopOfStack--;
     bae:	8b 81       	ldd	r24, Y+3	; 0x03
     bb0:	9c 81       	ldd	r25, Y+4	; 0x04
     bb2:	01 97       	sbiw	r24, 0x01	; 1
     bb4:	9c 83       	std	Y+4, r25	; 0x04
     bb6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     bb8:	eb 81       	ldd	r30, Y+3	; 0x03
     bba:	fc 81       	ldd	r31, Y+4	; 0x04
     bbc:	82 e2       	ldi	r24, 0x22	; 34
     bbe:	80 83       	st	Z, r24
	pxTopOfStack--;
     bc0:	8b 81       	ldd	r24, Y+3	; 0x03
     bc2:	9c 81       	ldd	r25, Y+4	; 0x04
     bc4:	01 97       	sbiw	r24, 0x01	; 1
     bc6:	9c 83       	std	Y+4, r25	; 0x04
     bc8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     bca:	eb 81       	ldd	r30, Y+3	; 0x03
     bcc:	fc 81       	ldd	r31, Y+4	; 0x04
     bce:	83 e2       	ldi	r24, 0x23	; 35
     bd0:	80 83       	st	Z, r24
	pxTopOfStack--;
     bd2:	8b 81       	ldd	r24, Y+3	; 0x03
     bd4:	9c 81       	ldd	r25, Y+4	; 0x04
     bd6:	01 97       	sbiw	r24, 0x01	; 1
     bd8:	9c 83       	std	Y+4, r25	; 0x04
     bda:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
     bdc:	8f 81       	ldd	r24, Y+7	; 0x07
     bde:	98 85       	ldd	r25, Y+8	; 0x08
     be0:	9a 83       	std	Y+2, r25	; 0x02
     be2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     be4:	89 81       	ldd	r24, Y+1	; 0x01
     be6:	eb 81       	ldd	r30, Y+3	; 0x03
     be8:	fc 81       	ldd	r31, Y+4	; 0x04
     bea:	80 83       	st	Z, r24
	pxTopOfStack--;
     bec:	8b 81       	ldd	r24, Y+3	; 0x03
     bee:	9c 81       	ldd	r25, Y+4	; 0x04
     bf0:	01 97       	sbiw	r24, 0x01	; 1
     bf2:	9c 83       	std	Y+4, r25	; 0x04
     bf4:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     bf6:	89 81       	ldd	r24, Y+1	; 0x01
     bf8:	9a 81       	ldd	r25, Y+2	; 0x02
     bfa:	89 2f       	mov	r24, r25
     bfc:	99 27       	eor	r25, r25
     bfe:	9a 83       	std	Y+2, r25	; 0x02
     c00:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     c02:	89 81       	ldd	r24, Y+1	; 0x01
     c04:	eb 81       	ldd	r30, Y+3	; 0x03
     c06:	fc 81       	ldd	r31, Y+4	; 0x04
     c08:	80 83       	st	Z, r24
	pxTopOfStack--;
     c0a:	8b 81       	ldd	r24, Y+3	; 0x03
     c0c:	9c 81       	ldd	r25, Y+4	; 0x04
     c0e:	01 97       	sbiw	r24, 0x01	; 1
     c10:	9c 83       	std	Y+4, r25	; 0x04
     c12:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     c14:	eb 81       	ldd	r30, Y+3	; 0x03
     c16:	fc 81       	ldd	r31, Y+4	; 0x04
     c18:	86 e2       	ldi	r24, 0x26	; 38
     c1a:	80 83       	st	Z, r24
	pxTopOfStack--;
     c1c:	8b 81       	ldd	r24, Y+3	; 0x03
     c1e:	9c 81       	ldd	r25, Y+4	; 0x04
     c20:	01 97       	sbiw	r24, 0x01	; 1
     c22:	9c 83       	std	Y+4, r25	; 0x04
     c24:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     c26:	eb 81       	ldd	r30, Y+3	; 0x03
     c28:	fc 81       	ldd	r31, Y+4	; 0x04
     c2a:	87 e2       	ldi	r24, 0x27	; 39
     c2c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c2e:	8b 81       	ldd	r24, Y+3	; 0x03
     c30:	9c 81       	ldd	r25, Y+4	; 0x04
     c32:	01 97       	sbiw	r24, 0x01	; 1
     c34:	9c 83       	std	Y+4, r25	; 0x04
     c36:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     c38:	eb 81       	ldd	r30, Y+3	; 0x03
     c3a:	fc 81       	ldd	r31, Y+4	; 0x04
     c3c:	88 e2       	ldi	r24, 0x28	; 40
     c3e:	80 83       	st	Z, r24
	pxTopOfStack--;
     c40:	8b 81       	ldd	r24, Y+3	; 0x03
     c42:	9c 81       	ldd	r25, Y+4	; 0x04
     c44:	01 97       	sbiw	r24, 0x01	; 1
     c46:	9c 83       	std	Y+4, r25	; 0x04
     c48:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     c4a:	eb 81       	ldd	r30, Y+3	; 0x03
     c4c:	fc 81       	ldd	r31, Y+4	; 0x04
     c4e:	89 e2       	ldi	r24, 0x29	; 41
     c50:	80 83       	st	Z, r24
	pxTopOfStack--;
     c52:	8b 81       	ldd	r24, Y+3	; 0x03
     c54:	9c 81       	ldd	r25, Y+4	; 0x04
     c56:	01 97       	sbiw	r24, 0x01	; 1
     c58:	9c 83       	std	Y+4, r25	; 0x04
     c5a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     c5c:	eb 81       	ldd	r30, Y+3	; 0x03
     c5e:	fc 81       	ldd	r31, Y+4	; 0x04
     c60:	80 e3       	ldi	r24, 0x30	; 48
     c62:	80 83       	st	Z, r24
	pxTopOfStack--;
     c64:	8b 81       	ldd	r24, Y+3	; 0x03
     c66:	9c 81       	ldd	r25, Y+4	; 0x04
     c68:	01 97       	sbiw	r24, 0x01	; 1
     c6a:	9c 83       	std	Y+4, r25	; 0x04
     c6c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     c6e:	eb 81       	ldd	r30, Y+3	; 0x03
     c70:	fc 81       	ldd	r31, Y+4	; 0x04
     c72:	81 e3       	ldi	r24, 0x31	; 49
     c74:	80 83       	st	Z, r24
	pxTopOfStack--;
     c76:	8b 81       	ldd	r24, Y+3	; 0x03
     c78:	9c 81       	ldd	r25, Y+4	; 0x04
     c7a:	01 97       	sbiw	r24, 0x01	; 1
     c7c:	9c 83       	std	Y+4, r25	; 0x04
     c7e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     c80:	8b 81       	ldd	r24, Y+3	; 0x03
     c82:	9c 81       	ldd	r25, Y+4	; 0x04
}
     c84:	28 96       	adiw	r28, 0x08	; 8
     c86:	0f b6       	in	r0, 0x3f	; 63
     c88:	f8 94       	cli
     c8a:	de bf       	out	0x3e, r29	; 62
     c8c:	0f be       	out	0x3f, r0	; 63
     c8e:	cd bf       	out	0x3d, r28	; 61
     c90:	cf 91       	pop	r28
     c92:	df 91       	pop	r29
     c94:	08 95       	ret

00000c96 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
     c96:	df 93       	push	r29
     c98:	cf 93       	push	r28
     c9a:	cd b7       	in	r28, 0x3d	; 61
     c9c:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     c9e:	0e 94 3b 07 	call	0xe76	; 0xe76 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     ca2:	a0 91 3c 03 	lds	r26, 0x033C
     ca6:	b0 91 3d 03 	lds	r27, 0x033D
     caa:	cd 91       	ld	r28, X+
     cac:	cd bf       	out	0x3d, r28	; 61
     cae:	dd 91       	ld	r29, X+
     cb0:	de bf       	out	0x3e, r29	; 62
     cb2:	ff 91       	pop	r31
     cb4:	ef 91       	pop	r30
     cb6:	df 91       	pop	r29
     cb8:	cf 91       	pop	r28
     cba:	bf 91       	pop	r27
     cbc:	af 91       	pop	r26
     cbe:	9f 91       	pop	r25
     cc0:	8f 91       	pop	r24
     cc2:	7f 91       	pop	r23
     cc4:	6f 91       	pop	r22
     cc6:	5f 91       	pop	r21
     cc8:	4f 91       	pop	r20
     cca:	3f 91       	pop	r19
     ccc:	2f 91       	pop	r18
     cce:	1f 91       	pop	r17
     cd0:	0f 91       	pop	r16
     cd2:	ff 90       	pop	r15
     cd4:	ef 90       	pop	r14
     cd6:	df 90       	pop	r13
     cd8:	cf 90       	pop	r12
     cda:	bf 90       	pop	r11
     cdc:	af 90       	pop	r10
     cde:	9f 90       	pop	r9
     ce0:	8f 90       	pop	r8
     ce2:	7f 90       	pop	r7
     ce4:	6f 90       	pop	r6
     ce6:	5f 90       	pop	r5
     ce8:	4f 90       	pop	r4
     cea:	3f 90       	pop	r3
     cec:	2f 90       	pop	r2
     cee:	1f 90       	pop	r1
     cf0:	0f 90       	pop	r0
     cf2:	0f be       	out	0x3f, r0	; 63
     cf4:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     cf6:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     cf8:	81 e0       	ldi	r24, 0x01	; 1
}
     cfa:	cf 91       	pop	r28
     cfc:	df 91       	pop	r29
     cfe:	08 95       	ret

00000d00 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     d00:	df 93       	push	r29
     d02:	cf 93       	push	r28
     d04:	cd b7       	in	r28, 0x3d	; 61
     d06:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     d08:	cf 91       	pop	r28
     d0a:	df 91       	pop	r29
     d0c:	08 95       	ret

00000d0e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     d0e:	0f 92       	push	r0
     d10:	0f b6       	in	r0, 0x3f	; 63
     d12:	f8 94       	cli
     d14:	0f 92       	push	r0
     d16:	1f 92       	push	r1
     d18:	11 24       	eor	r1, r1
     d1a:	2f 92       	push	r2
     d1c:	3f 92       	push	r3
     d1e:	4f 92       	push	r4
     d20:	5f 92       	push	r5
     d22:	6f 92       	push	r6
     d24:	7f 92       	push	r7
     d26:	8f 92       	push	r8
     d28:	9f 92       	push	r9
     d2a:	af 92       	push	r10
     d2c:	bf 92       	push	r11
     d2e:	cf 92       	push	r12
     d30:	df 92       	push	r13
     d32:	ef 92       	push	r14
     d34:	ff 92       	push	r15
     d36:	0f 93       	push	r16
     d38:	1f 93       	push	r17
     d3a:	2f 93       	push	r18
     d3c:	3f 93       	push	r19
     d3e:	4f 93       	push	r20
     d40:	5f 93       	push	r21
     d42:	6f 93       	push	r22
     d44:	7f 93       	push	r23
     d46:	8f 93       	push	r24
     d48:	9f 93       	push	r25
     d4a:	af 93       	push	r26
     d4c:	bf 93       	push	r27
     d4e:	cf 93       	push	r28
     d50:	df 93       	push	r29
     d52:	ef 93       	push	r30
     d54:	ff 93       	push	r31
     d56:	a0 91 3c 03 	lds	r26, 0x033C
     d5a:	b0 91 3d 03 	lds	r27, 0x033D
     d5e:	0d b6       	in	r0, 0x3d	; 61
     d60:	0d 92       	st	X+, r0
     d62:	0e b6       	in	r0, 0x3e	; 62
     d64:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     d66:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     d6a:	a0 91 3c 03 	lds	r26, 0x033C
     d6e:	b0 91 3d 03 	lds	r27, 0x033D
     d72:	cd 91       	ld	r28, X+
     d74:	cd bf       	out	0x3d, r28	; 61
     d76:	dd 91       	ld	r29, X+
     d78:	de bf       	out	0x3e, r29	; 62
     d7a:	ff 91       	pop	r31
     d7c:	ef 91       	pop	r30
     d7e:	df 91       	pop	r29
     d80:	cf 91       	pop	r28
     d82:	bf 91       	pop	r27
     d84:	af 91       	pop	r26
     d86:	9f 91       	pop	r25
     d88:	8f 91       	pop	r24
     d8a:	7f 91       	pop	r23
     d8c:	6f 91       	pop	r22
     d8e:	5f 91       	pop	r21
     d90:	4f 91       	pop	r20
     d92:	3f 91       	pop	r19
     d94:	2f 91       	pop	r18
     d96:	1f 91       	pop	r17
     d98:	0f 91       	pop	r16
     d9a:	ff 90       	pop	r15
     d9c:	ef 90       	pop	r14
     d9e:	df 90       	pop	r13
     da0:	cf 90       	pop	r12
     da2:	bf 90       	pop	r11
     da4:	af 90       	pop	r10
     da6:	9f 90       	pop	r9
     da8:	8f 90       	pop	r8
     daa:	7f 90       	pop	r7
     dac:	6f 90       	pop	r6
     dae:	5f 90       	pop	r5
     db0:	4f 90       	pop	r4
     db2:	3f 90       	pop	r3
     db4:	2f 90       	pop	r2
     db6:	1f 90       	pop	r1
     db8:	0f 90       	pop	r0
     dba:	0f be       	out	0x3f, r0	; 63
     dbc:	0f 90       	pop	r0

	asm volatile ( "ret" );
     dbe:	08 95       	ret

00000dc0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     dc0:	0f 92       	push	r0
     dc2:	0f b6       	in	r0, 0x3f	; 63
     dc4:	f8 94       	cli
     dc6:	0f 92       	push	r0
     dc8:	1f 92       	push	r1
     dca:	11 24       	eor	r1, r1
     dcc:	2f 92       	push	r2
     dce:	3f 92       	push	r3
     dd0:	4f 92       	push	r4
     dd2:	5f 92       	push	r5
     dd4:	6f 92       	push	r6
     dd6:	7f 92       	push	r7
     dd8:	8f 92       	push	r8
     dda:	9f 92       	push	r9
     ddc:	af 92       	push	r10
     dde:	bf 92       	push	r11
     de0:	cf 92       	push	r12
     de2:	df 92       	push	r13
     de4:	ef 92       	push	r14
     de6:	ff 92       	push	r15
     de8:	0f 93       	push	r16
     dea:	1f 93       	push	r17
     dec:	2f 93       	push	r18
     dee:	3f 93       	push	r19
     df0:	4f 93       	push	r20
     df2:	5f 93       	push	r21
     df4:	6f 93       	push	r22
     df6:	7f 93       	push	r23
     df8:	8f 93       	push	r24
     dfa:	9f 93       	push	r25
     dfc:	af 93       	push	r26
     dfe:	bf 93       	push	r27
     e00:	cf 93       	push	r28
     e02:	df 93       	push	r29
     e04:	ef 93       	push	r30
     e06:	ff 93       	push	r31
     e08:	a0 91 3c 03 	lds	r26, 0x033C
     e0c:	b0 91 3d 03 	lds	r27, 0x033D
     e10:	0d b6       	in	r0, 0x3d	; 61
     e12:	0d 92       	st	X+, r0
     e14:	0e b6       	in	r0, 0x3e	; 62
     e16:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     e18:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <vTaskIncrementTick>
	vTaskSwitchContext();
     e1c:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e20:	a0 91 3c 03 	lds	r26, 0x033C
     e24:	b0 91 3d 03 	lds	r27, 0x033D
     e28:	cd 91       	ld	r28, X+
     e2a:	cd bf       	out	0x3d, r28	; 61
     e2c:	dd 91       	ld	r29, X+
     e2e:	de bf       	out	0x3e, r29	; 62
     e30:	ff 91       	pop	r31
     e32:	ef 91       	pop	r30
     e34:	df 91       	pop	r29
     e36:	cf 91       	pop	r28
     e38:	bf 91       	pop	r27
     e3a:	af 91       	pop	r26
     e3c:	9f 91       	pop	r25
     e3e:	8f 91       	pop	r24
     e40:	7f 91       	pop	r23
     e42:	6f 91       	pop	r22
     e44:	5f 91       	pop	r21
     e46:	4f 91       	pop	r20
     e48:	3f 91       	pop	r19
     e4a:	2f 91       	pop	r18
     e4c:	1f 91       	pop	r17
     e4e:	0f 91       	pop	r16
     e50:	ff 90       	pop	r15
     e52:	ef 90       	pop	r14
     e54:	df 90       	pop	r13
     e56:	cf 90       	pop	r12
     e58:	bf 90       	pop	r11
     e5a:	af 90       	pop	r10
     e5c:	9f 90       	pop	r9
     e5e:	8f 90       	pop	r8
     e60:	7f 90       	pop	r7
     e62:	6f 90       	pop	r6
     e64:	5f 90       	pop	r5
     e66:	4f 90       	pop	r4
     e68:	3f 90       	pop	r3
     e6a:	2f 90       	pop	r2
     e6c:	1f 90       	pop	r1
     e6e:	0f 90       	pop	r0
     e70:	0f be       	out	0x3f, r0	; 63
     e72:	0f 90       	pop	r0

	asm volatile ( "ret" );
     e74:	08 95       	ret

00000e76 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     e76:	df 93       	push	r29
     e78:	cf 93       	push	r28
     e7a:	00 d0       	rcall	.+0      	; 0xe7c <prvSetupTimerInterrupt+0x6>
     e7c:	00 d0       	rcall	.+0      	; 0xe7e <prvSetupTimerInterrupt+0x8>
     e7e:	00 d0       	rcall	.+0      	; 0xe80 <prvSetupTimerInterrupt+0xa>
     e80:	cd b7       	in	r28, 0x3d	; 61
     e82:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     e84:	80 e4       	ldi	r24, 0x40	; 64
     e86:	9f e1       	ldi	r25, 0x1F	; 31
     e88:	a0 e0       	ldi	r26, 0x00	; 0
     e8a:	b0 e0       	ldi	r27, 0x00	; 0
     e8c:	8b 83       	std	Y+3, r24	; 0x03
     e8e:	9c 83       	std	Y+4, r25	; 0x04
     e90:	ad 83       	std	Y+5, r26	; 0x05
     e92:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     e94:	8b 81       	ldd	r24, Y+3	; 0x03
     e96:	9c 81       	ldd	r25, Y+4	; 0x04
     e98:	ad 81       	ldd	r26, Y+5	; 0x05
     e9a:	be 81       	ldd	r27, Y+6	; 0x06
     e9c:	68 94       	set
     e9e:	15 f8       	bld	r1, 5
     ea0:	b6 95       	lsr	r27
     ea2:	a7 95       	ror	r26
     ea4:	97 95       	ror	r25
     ea6:	87 95       	ror	r24
     ea8:	16 94       	lsr	r1
     eaa:	d1 f7       	brne	.-12     	; 0xea0 <prvSetupTimerInterrupt+0x2a>
     eac:	8b 83       	std	Y+3, r24	; 0x03
     eae:	9c 83       	std	Y+4, r25	; 0x04
     eb0:	ad 83       	std	Y+5, r26	; 0x05
     eb2:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
     eb4:	8b 81       	ldd	r24, Y+3	; 0x03
     eb6:	9c 81       	ldd	r25, Y+4	; 0x04
     eb8:	ad 81       	ldd	r26, Y+5	; 0x05
     eba:	be 81       	ldd	r27, Y+6	; 0x06
     ebc:	01 97       	sbiw	r24, 0x01	; 1
     ebe:	a1 09       	sbc	r26, r1
     ec0:	b1 09       	sbc	r27, r1
     ec2:	8b 83       	std	Y+3, r24	; 0x03
     ec4:	9c 83       	std	Y+4, r25	; 0x04
     ec6:	ad 83       	std	Y+5, r26	; 0x05
     ec8:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
     eca:	8b 81       	ldd	r24, Y+3	; 0x03
     ecc:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     ece:	8b 81       	ldd	r24, Y+3	; 0x03
     ed0:	9c 81       	ldd	r25, Y+4	; 0x04
     ed2:	ad 81       	ldd	r26, Y+5	; 0x05
     ed4:	be 81       	ldd	r27, Y+6	; 0x06
     ed6:	89 2f       	mov	r24, r25
     ed8:	9a 2f       	mov	r25, r26
     eda:	ab 2f       	mov	r26, r27
     edc:	bb 27       	eor	r27, r27
     ede:	8b 83       	std	Y+3, r24	; 0x03
     ee0:	9c 83       	std	Y+4, r25	; 0x04
     ee2:	ad 83       	std	Y+5, r26	; 0x05
     ee4:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
     ee6:	8b 81       	ldd	r24, Y+3	; 0x03
     ee8:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     eea:	eb e4       	ldi	r30, 0x4B	; 75
     eec:	f0 e0       	ldi	r31, 0x00	; 0
     eee:	8a 81       	ldd	r24, Y+2	; 0x02
     ef0:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     ef2:	ea e4       	ldi	r30, 0x4A	; 74
     ef4:	f0 e0       	ldi	r31, 0x00	; 0
     ef6:	89 81       	ldd	r24, Y+1	; 0x01
     ef8:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     efa:	8b e0       	ldi	r24, 0x0B	; 11
     efc:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     efe:	ee e4       	ldi	r30, 0x4E	; 78
     f00:	f0 e0       	ldi	r31, 0x00	; 0
     f02:	89 81       	ldd	r24, Y+1	; 0x01
     f04:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     f06:	e9 e5       	ldi	r30, 0x59	; 89
     f08:	f0 e0       	ldi	r31, 0x00	; 0
     f0a:	80 81       	ld	r24, Z
     f0c:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     f0e:	89 81       	ldd	r24, Y+1	; 0x01
     f10:	80 61       	ori	r24, 0x10	; 16
     f12:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
     f14:	e9 e5       	ldi	r30, 0x59	; 89
     f16:	f0 e0       	ldi	r31, 0x00	; 0
     f18:	89 81       	ldd	r24, Y+1	; 0x01
     f1a:	80 83       	st	Z, r24
}
     f1c:	26 96       	adiw	r28, 0x06	; 6
     f1e:	0f b6       	in	r0, 0x3f	; 63
     f20:	f8 94       	cli
     f22:	de bf       	out	0x3e, r29	; 62
     f24:	0f be       	out	0x3f, r0	; 63
     f26:	cd bf       	out	0x3d, r28	; 61
     f28:	cf 91       	pop	r28
     f2a:	df 91       	pop	r29
     f2c:	08 95       	ret

00000f2e <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
     f2e:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vPortYieldFromTick>
		asm volatile ( "reti" );
     f32:	18 95       	reti

00000f34 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
     f34:	df 93       	push	r29
     f36:	cf 93       	push	r28
     f38:	cd b7       	in	r28, 0x3d	; 61
     f3a:	de b7       	in	r29, 0x3e	; 62
     f3c:	28 97       	sbiw	r28, 0x08	; 8
     f3e:	0f b6       	in	r0, 0x3f	; 63
     f40:	f8 94       	cli
     f42:	de bf       	out	0x3e, r29	; 62
     f44:	0f be       	out	0x3f, r0	; 63
     f46:	cd bf       	out	0x3d, r28	; 61
     f48:	8f 83       	std	Y+7, r24	; 0x07
     f4a:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     f4c:	1a 82       	std	Y+2, r1	; 0x02
     f4e:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     f50:	8f 81       	ldd	r24, Y+7	; 0x07
     f52:	88 23       	and	r24, r24
     f54:	09 f4       	brne	.+2      	; 0xf58 <xQueueCreate+0x24>
     f56:	8c c0       	rjmp	.+280    	; 0x1070 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     f58:	8f e1       	ldi	r24, 0x1F	; 31
     f5a:	90 e0       	ldi	r25, 0x00	; 0
     f5c:	0e 94 21 03 	call	0x642	; 0x642 <pvPortMalloc>
     f60:	9e 83       	std	Y+6, r25	; 0x06
     f62:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
     f64:	8d 81       	ldd	r24, Y+5	; 0x05
     f66:	9e 81       	ldd	r25, Y+6	; 0x06
     f68:	00 97       	sbiw	r24, 0x00	; 0
     f6a:	09 f4       	brne	.+2      	; 0xf6e <xQueueCreate+0x3a>
     f6c:	81 c0       	rjmp	.+258    	; 0x1070 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     f6e:	8f 81       	ldd	r24, Y+7	; 0x07
     f70:	28 2f       	mov	r18, r24
     f72:	30 e0       	ldi	r19, 0x00	; 0
     f74:	88 85       	ldd	r24, Y+8	; 0x08
     f76:	88 2f       	mov	r24, r24
     f78:	90 e0       	ldi	r25, 0x00	; 0
     f7a:	ac 01       	movw	r20, r24
     f7c:	24 9f       	mul	r18, r20
     f7e:	c0 01       	movw	r24, r0
     f80:	25 9f       	mul	r18, r21
     f82:	90 0d       	add	r25, r0
     f84:	34 9f       	mul	r19, r20
     f86:	90 0d       	add	r25, r0
     f88:	11 24       	eor	r1, r1
     f8a:	01 96       	adiw	r24, 0x01	; 1
     f8c:	9c 83       	std	Y+4, r25	; 0x04
     f8e:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     f90:	8b 81       	ldd	r24, Y+3	; 0x03
     f92:	9c 81       	ldd	r25, Y+4	; 0x04
     f94:	0e 94 21 03 	call	0x642	; 0x642 <pvPortMalloc>
     f98:	ed 81       	ldd	r30, Y+5	; 0x05
     f9a:	fe 81       	ldd	r31, Y+6	; 0x06
     f9c:	91 83       	std	Z+1, r25	; 0x01
     f9e:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
     fa0:	ed 81       	ldd	r30, Y+5	; 0x05
     fa2:	fe 81       	ldd	r31, Y+6	; 0x06
     fa4:	80 81       	ld	r24, Z
     fa6:	91 81       	ldd	r25, Z+1	; 0x01
     fa8:	00 97       	sbiw	r24, 0x00	; 0
     faa:	09 f4       	brne	.+2      	; 0xfae <xQueueCreate+0x7a>
     fac:	5d c0       	rjmp	.+186    	; 0x1068 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
     fae:	ed 81       	ldd	r30, Y+5	; 0x05
     fb0:	fe 81       	ldd	r31, Y+6	; 0x06
     fb2:	40 81       	ld	r20, Z
     fb4:	51 81       	ldd	r21, Z+1	; 0x01
     fb6:	8f 81       	ldd	r24, Y+7	; 0x07
     fb8:	28 2f       	mov	r18, r24
     fba:	30 e0       	ldi	r19, 0x00	; 0
     fbc:	88 85       	ldd	r24, Y+8	; 0x08
     fbe:	88 2f       	mov	r24, r24
     fc0:	90 e0       	ldi	r25, 0x00	; 0
     fc2:	bc 01       	movw	r22, r24
     fc4:	26 9f       	mul	r18, r22
     fc6:	c0 01       	movw	r24, r0
     fc8:	27 9f       	mul	r18, r23
     fca:	90 0d       	add	r25, r0
     fcc:	36 9f       	mul	r19, r22
     fce:	90 0d       	add	r25, r0
     fd0:	11 24       	eor	r1, r1
     fd2:	84 0f       	add	r24, r20
     fd4:	95 1f       	adc	r25, r21
     fd6:	ed 81       	ldd	r30, Y+5	; 0x05
     fd8:	fe 81       	ldd	r31, Y+6	; 0x06
     fda:	93 83       	std	Z+3, r25	; 0x03
     fdc:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     fde:	ed 81       	ldd	r30, Y+5	; 0x05
     fe0:	fe 81       	ldd	r31, Y+6	; 0x06
     fe2:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
     fe4:	ed 81       	ldd	r30, Y+5	; 0x05
     fe6:	fe 81       	ldd	r31, Y+6	; 0x06
     fe8:	80 81       	ld	r24, Z
     fea:	91 81       	ldd	r25, Z+1	; 0x01
     fec:	ed 81       	ldd	r30, Y+5	; 0x05
     fee:	fe 81       	ldd	r31, Y+6	; 0x06
     ff0:	95 83       	std	Z+5, r25	; 0x05
     ff2:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
     ff4:	ed 81       	ldd	r30, Y+5	; 0x05
     ff6:	fe 81       	ldd	r31, Y+6	; 0x06
     ff8:	40 81       	ld	r20, Z
     ffa:	51 81       	ldd	r21, Z+1	; 0x01
     ffc:	8f 81       	ldd	r24, Y+7	; 0x07
     ffe:	88 2f       	mov	r24, r24
    1000:	90 e0       	ldi	r25, 0x00	; 0
    1002:	9c 01       	movw	r18, r24
    1004:	21 50       	subi	r18, 0x01	; 1
    1006:	30 40       	sbci	r19, 0x00	; 0
    1008:	88 85       	ldd	r24, Y+8	; 0x08
    100a:	88 2f       	mov	r24, r24
    100c:	90 e0       	ldi	r25, 0x00	; 0
    100e:	bc 01       	movw	r22, r24
    1010:	26 9f       	mul	r18, r22
    1012:	c0 01       	movw	r24, r0
    1014:	27 9f       	mul	r18, r23
    1016:	90 0d       	add	r25, r0
    1018:	36 9f       	mul	r19, r22
    101a:	90 0d       	add	r25, r0
    101c:	11 24       	eor	r1, r1
    101e:	84 0f       	add	r24, r20
    1020:	95 1f       	adc	r25, r21
    1022:	ed 81       	ldd	r30, Y+5	; 0x05
    1024:	fe 81       	ldd	r31, Y+6	; 0x06
    1026:	97 83       	std	Z+7, r25	; 0x07
    1028:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    102a:	ed 81       	ldd	r30, Y+5	; 0x05
    102c:	fe 81       	ldd	r31, Y+6	; 0x06
    102e:	8f 81       	ldd	r24, Y+7	; 0x07
    1030:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1032:	ed 81       	ldd	r30, Y+5	; 0x05
    1034:	fe 81       	ldd	r31, Y+6	; 0x06
    1036:	88 85       	ldd	r24, Y+8	; 0x08
    1038:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    103a:	ed 81       	ldd	r30, Y+5	; 0x05
    103c:	fe 81       	ldd	r31, Y+6	; 0x06
    103e:	8f ef       	ldi	r24, 0xFF	; 255
    1040:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1042:	ed 81       	ldd	r30, Y+5	; 0x05
    1044:	fe 81       	ldd	r31, Y+6	; 0x06
    1046:	8f ef       	ldi	r24, 0xFF	; 255
    1048:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    104a:	8d 81       	ldd	r24, Y+5	; 0x05
    104c:	9e 81       	ldd	r25, Y+6	; 0x06
    104e:	08 96       	adiw	r24, 0x08	; 8
    1050:	0e 94 8d 03 	call	0x71a	; 0x71a <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1054:	8d 81       	ldd	r24, Y+5	; 0x05
    1056:	9e 81       	ldd	r25, Y+6	; 0x06
    1058:	41 96       	adiw	r24, 0x11	; 17
    105a:	0e 94 8d 03 	call	0x71a	; 0x71a <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    105e:	8d 81       	ldd	r24, Y+5	; 0x05
    1060:	9e 81       	ldd	r25, Y+6	; 0x06
    1062:	9a 83       	std	Y+2, r25	; 0x02
    1064:	89 83       	std	Y+1, r24	; 0x01
    1066:	04 c0       	rjmp	.+8      	; 0x1070 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1068:	8d 81       	ldd	r24, Y+5	; 0x05
    106a:	9e 81       	ldd	r25, Y+6	; 0x06
    106c:	0e 94 67 03 	call	0x6ce	; 0x6ce <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1070:	89 81       	ldd	r24, Y+1	; 0x01
    1072:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1074:	28 96       	adiw	r28, 0x08	; 8
    1076:	0f b6       	in	r0, 0x3f	; 63
    1078:	f8 94       	cli
    107a:	de bf       	out	0x3e, r29	; 62
    107c:	0f be       	out	0x3f, r0	; 63
    107e:	cd bf       	out	0x3d, r28	; 61
    1080:	cf 91       	pop	r28
    1082:	df 91       	pop	r29
    1084:	08 95       	ret

00001086 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1086:	df 93       	push	r29
    1088:	cf 93       	push	r28
    108a:	cd b7       	in	r28, 0x3d	; 61
    108c:	de b7       	in	r29, 0x3e	; 62
    108e:	2c 97       	sbiw	r28, 0x0c	; 12
    1090:	0f b6       	in	r0, 0x3f	; 63
    1092:	f8 94       	cli
    1094:	de bf       	out	0x3e, r29	; 62
    1096:	0f be       	out	0x3f, r0	; 63
    1098:	cd bf       	out	0x3d, r28	; 61
    109a:	9e 83       	std	Y+6, r25	; 0x06
    109c:	8d 83       	std	Y+5, r24	; 0x05
    109e:	78 87       	std	Y+8, r23	; 0x08
    10a0:	6f 83       	std	Y+7, r22	; 0x07
    10a2:	5a 87       	std	Y+10, r21	; 0x0a
    10a4:	49 87       	std	Y+9, r20	; 0x09
    10a6:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    10a8:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    10aa:	0f b6       	in	r0, 0x3f	; 63
    10ac:	f8 94       	cli
    10ae:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    10b0:	ed 81       	ldd	r30, Y+5	; 0x05
    10b2:	fe 81       	ldd	r31, Y+6	; 0x06
    10b4:	92 8d       	ldd	r25, Z+26	; 0x1a
    10b6:	ed 81       	ldd	r30, Y+5	; 0x05
    10b8:	fe 81       	ldd	r31, Y+6	; 0x06
    10ba:	83 8d       	ldd	r24, Z+27	; 0x1b
    10bc:	98 17       	cp	r25, r24
    10be:	d8 f4       	brcc	.+54     	; 0x10f6 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    10c0:	8d 81       	ldd	r24, Y+5	; 0x05
    10c2:	9e 81       	ldd	r25, Y+6	; 0x06
    10c4:	2f 81       	ldd	r18, Y+7	; 0x07
    10c6:	38 85       	ldd	r19, Y+8	; 0x08
    10c8:	b9 01       	movw	r22, r18
    10ca:	4b 85       	ldd	r20, Y+11	; 0x0b
    10cc:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10d0:	ed 81       	ldd	r30, Y+5	; 0x05
    10d2:	fe 81       	ldd	r31, Y+6	; 0x06
    10d4:	81 89       	ldd	r24, Z+17	; 0x11
    10d6:	88 23       	and	r24, r24
    10d8:	49 f0       	breq	.+18     	; 0x10ec <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    10da:	8d 81       	ldd	r24, Y+5	; 0x05
    10dc:	9e 81       	ldd	r25, Y+6	; 0x06
    10de:	41 96       	adiw	r24, 0x11	; 17
    10e0:	0e 94 93 10 	call	0x2126	; 0x2126 <xTaskRemoveFromEventList>
    10e4:	81 30       	cpi	r24, 0x01	; 1
    10e6:	11 f4       	brne	.+4      	; 0x10ec <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    10e8:	0e 94 87 06 	call	0xd0e	; 0xd0e <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    10ec:	0f 90       	pop	r0
    10ee:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    10f0:	81 e0       	ldi	r24, 0x01	; 1
    10f2:	8c 87       	std	Y+12, r24	; 0x0c
    10f4:	5c c0       	rjmp	.+184    	; 0x11ae <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    10f6:	89 85       	ldd	r24, Y+9	; 0x09
    10f8:	9a 85       	ldd	r25, Y+10	; 0x0a
    10fa:	00 97       	sbiw	r24, 0x00	; 0
    10fc:	21 f4       	brne	.+8      	; 0x1106 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    10fe:	0f 90       	pop	r0
    1100:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1102:	1c 86       	std	Y+12, r1	; 0x0c
    1104:	54 c0       	rjmp	.+168    	; 0x11ae <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    1106:	89 81       	ldd	r24, Y+1	; 0x01
    1108:	88 23       	and	r24, r24
    110a:	31 f4       	brne	.+12     	; 0x1118 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    110c:	ce 01       	movw	r24, r28
    110e:	02 96       	adiw	r24, 0x02	; 2
    1110:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1114:	81 e0       	ldi	r24, 0x01	; 1
    1116:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1118:	0f 90       	pop	r0
    111a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    111c:	0e 94 57 0e 	call	0x1cae	; 0x1cae <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1120:	0f b6       	in	r0, 0x3f	; 63
    1122:	f8 94       	cli
    1124:	0f 92       	push	r0
    1126:	ed 81       	ldd	r30, Y+5	; 0x05
    1128:	fe 81       	ldd	r31, Y+6	; 0x06
    112a:	85 8d       	ldd	r24, Z+29	; 0x1d
    112c:	8f 3f       	cpi	r24, 0xFF	; 255
    112e:	19 f4       	brne	.+6      	; 0x1136 <xQueueGenericSend+0xb0>
    1130:	ed 81       	ldd	r30, Y+5	; 0x05
    1132:	fe 81       	ldd	r31, Y+6	; 0x06
    1134:	15 8e       	std	Z+29, r1	; 0x1d
    1136:	ed 81       	ldd	r30, Y+5	; 0x05
    1138:	fe 81       	ldd	r31, Y+6	; 0x06
    113a:	86 8d       	ldd	r24, Z+30	; 0x1e
    113c:	8f 3f       	cpi	r24, 0xFF	; 255
    113e:	19 f4       	brne	.+6      	; 0x1146 <xQueueGenericSend+0xc0>
    1140:	ed 81       	ldd	r30, Y+5	; 0x05
    1142:	fe 81       	ldd	r31, Y+6	; 0x06
    1144:	16 8e       	std	Z+30, r1	; 0x1e
    1146:	0f 90       	pop	r0
    1148:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    114a:	ce 01       	movw	r24, r28
    114c:	02 96       	adiw	r24, 0x02	; 2
    114e:	9e 01       	movw	r18, r28
    1150:	27 5f       	subi	r18, 0xF7	; 247
    1152:	3f 4f       	sbci	r19, 0xFF	; 255
    1154:	b9 01       	movw	r22, r18
    1156:	0e 94 14 11 	call	0x2228	; 0x2228 <xTaskCheckForTimeOut>
    115a:	88 23       	and	r24, r24
    115c:	09 f5       	brne	.+66     	; 0x11a0 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    115e:	8d 81       	ldd	r24, Y+5	; 0x05
    1160:	9e 81       	ldd	r25, Y+6	; 0x06
    1162:	0e 94 e2 0b 	call	0x17c4	; 0x17c4 <prvIsQueueFull>
    1166:	88 23       	and	r24, r24
    1168:	a1 f0       	breq	.+40     	; 0x1192 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    116a:	8d 81       	ldd	r24, Y+5	; 0x05
    116c:	9e 81       	ldd	r25, Y+6	; 0x06
    116e:	08 96       	adiw	r24, 0x08	; 8
    1170:	29 85       	ldd	r18, Y+9	; 0x09
    1172:	3a 85       	ldd	r19, Y+10	; 0x0a
    1174:	b9 01       	movw	r22, r18
    1176:	0e 94 5d 10 	call	0x20ba	; 0x20ba <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    117a:	8d 81       	ldd	r24, Y+5	; 0x05
    117c:	9e 81       	ldd	r25, Y+6	; 0x06
    117e:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1182:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <xTaskResumeAll>
    1186:	88 23       	and	r24, r24
    1188:	09 f0       	breq	.+2      	; 0x118c <xQueueGenericSend+0x106>
    118a:	8f cf       	rjmp	.-226    	; 0x10aa <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    118c:	0e 94 87 06 	call	0xd0e	; 0xd0e <vPortYield>
    1190:	8c cf       	rjmp	.-232    	; 0x10aa <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1192:	8d 81       	ldd	r24, Y+5	; 0x05
    1194:	9e 81       	ldd	r25, Y+6	; 0x06
    1196:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    119a:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <xTaskResumeAll>
    119e:	85 cf       	rjmp	.-246    	; 0x10aa <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    11a0:	8d 81       	ldd	r24, Y+5	; 0x05
    11a2:	9e 81       	ldd	r25, Y+6	; 0x06
    11a4:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    11a8:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    11ac:	1c 86       	std	Y+12, r1	; 0x0c
    11ae:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    11b0:	2c 96       	adiw	r28, 0x0c	; 12
    11b2:	0f b6       	in	r0, 0x3f	; 63
    11b4:	f8 94       	cli
    11b6:	de bf       	out	0x3e, r29	; 62
    11b8:	0f be       	out	0x3f, r0	; 63
    11ba:	cd bf       	out	0x3d, r28	; 61
    11bc:	cf 91       	pop	r28
    11be:	df 91       	pop	r29
    11c0:	08 95       	ret

000011c2 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    11c2:	df 93       	push	r29
    11c4:	cf 93       	push	r28
    11c6:	cd b7       	in	r28, 0x3d	; 61
    11c8:	de b7       	in	r29, 0x3e	; 62
    11ca:	29 97       	sbiw	r28, 0x09	; 9
    11cc:	0f b6       	in	r0, 0x3f	; 63
    11ce:	f8 94       	cli
    11d0:	de bf       	out	0x3e, r29	; 62
    11d2:	0f be       	out	0x3f, r0	; 63
    11d4:	cd bf       	out	0x3d, r28	; 61
    11d6:	9c 83       	std	Y+4, r25	; 0x04
    11d8:	8b 83       	std	Y+3, r24	; 0x03
    11da:	7e 83       	std	Y+6, r23	; 0x06
    11dc:	6d 83       	std	Y+5, r22	; 0x05
    11de:	58 87       	std	Y+8, r21	; 0x08
    11e0:	4f 83       	std	Y+7, r20	; 0x07
    11e2:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    11e4:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    11e6:	eb 81       	ldd	r30, Y+3	; 0x03
    11e8:	fc 81       	ldd	r31, Y+4	; 0x04
    11ea:	92 8d       	ldd	r25, Z+26	; 0x1a
    11ec:	eb 81       	ldd	r30, Y+3	; 0x03
    11ee:	fc 81       	ldd	r31, Y+4	; 0x04
    11f0:	83 8d       	ldd	r24, Z+27	; 0x1b
    11f2:	98 17       	cp	r25, r24
    11f4:	40 f5       	brcc	.+80     	; 0x1246 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    11f6:	8b 81       	ldd	r24, Y+3	; 0x03
    11f8:	9c 81       	ldd	r25, Y+4	; 0x04
    11fa:	2d 81       	ldd	r18, Y+5	; 0x05
    11fc:	3e 81       	ldd	r19, Y+6	; 0x06
    11fe:	b9 01       	movw	r22, r18
    1200:	49 85       	ldd	r20, Y+9	; 0x09
    1202:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1206:	eb 81       	ldd	r30, Y+3	; 0x03
    1208:	fc 81       	ldd	r31, Y+4	; 0x04
    120a:	86 8d       	ldd	r24, Z+30	; 0x1e
    120c:	8f 3f       	cpi	r24, 0xFF	; 255
    120e:	89 f4       	brne	.+34     	; 0x1232 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1210:	eb 81       	ldd	r30, Y+3	; 0x03
    1212:	fc 81       	ldd	r31, Y+4	; 0x04
    1214:	81 89       	ldd	r24, Z+17	; 0x11
    1216:	88 23       	and	r24, r24
    1218:	99 f0       	breq	.+38     	; 0x1240 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    121a:	8b 81       	ldd	r24, Y+3	; 0x03
    121c:	9c 81       	ldd	r25, Y+4	; 0x04
    121e:	41 96       	adiw	r24, 0x11	; 17
    1220:	0e 94 93 10 	call	0x2126	; 0x2126 <xTaskRemoveFromEventList>
    1224:	88 23       	and	r24, r24
    1226:	61 f0       	breq	.+24     	; 0x1240 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1228:	ef 81       	ldd	r30, Y+7	; 0x07
    122a:	f8 85       	ldd	r31, Y+8	; 0x08
    122c:	81 e0       	ldi	r24, 0x01	; 1
    122e:	80 83       	st	Z, r24
    1230:	07 c0       	rjmp	.+14     	; 0x1240 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1232:	eb 81       	ldd	r30, Y+3	; 0x03
    1234:	fc 81       	ldd	r31, Y+4	; 0x04
    1236:	86 8d       	ldd	r24, Z+30	; 0x1e
    1238:	8f 5f       	subi	r24, 0xFF	; 255
    123a:	eb 81       	ldd	r30, Y+3	; 0x03
    123c:	fc 81       	ldd	r31, Y+4	; 0x04
    123e:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1240:	81 e0       	ldi	r24, 0x01	; 1
    1242:	8a 83       	std	Y+2, r24	; 0x02
    1244:	01 c0       	rjmp	.+2      	; 0x1248 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1246:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1248:	8a 81       	ldd	r24, Y+2	; 0x02
}
    124a:	29 96       	adiw	r28, 0x09	; 9
    124c:	0f b6       	in	r0, 0x3f	; 63
    124e:	f8 94       	cli
    1250:	de bf       	out	0x3e, r29	; 62
    1252:	0f be       	out	0x3f, r0	; 63
    1254:	cd bf       	out	0x3d, r28	; 61
    1256:	cf 91       	pop	r28
    1258:	df 91       	pop	r29
    125a:	08 95       	ret

0000125c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    125c:	df 93       	push	r29
    125e:	cf 93       	push	r28
    1260:	cd b7       	in	r28, 0x3d	; 61
    1262:	de b7       	in	r29, 0x3e	; 62
    1264:	2e 97       	sbiw	r28, 0x0e	; 14
    1266:	0f b6       	in	r0, 0x3f	; 63
    1268:	f8 94       	cli
    126a:	de bf       	out	0x3e, r29	; 62
    126c:	0f be       	out	0x3f, r0	; 63
    126e:	cd bf       	out	0x3d, r28	; 61
    1270:	98 87       	std	Y+8, r25	; 0x08
    1272:	8f 83       	std	Y+7, r24	; 0x07
    1274:	7a 87       	std	Y+10, r23	; 0x0a
    1276:	69 87       	std	Y+9, r22	; 0x09
    1278:	5c 87       	std	Y+12, r21	; 0x0c
    127a:	4b 87       	std	Y+11, r20	; 0x0b
    127c:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    127e:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1280:	0f b6       	in	r0, 0x3f	; 63
    1282:	f8 94       	cli
    1284:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1286:	ef 81       	ldd	r30, Y+7	; 0x07
    1288:	f8 85       	ldd	r31, Y+8	; 0x08
    128a:	82 8d       	ldd	r24, Z+26	; 0x1a
    128c:	88 23       	and	r24, r24
    128e:	09 f4       	brne	.+2      	; 0x1292 <xQueueGenericReceive+0x36>
    1290:	3f c0       	rjmp	.+126    	; 0x1310 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1292:	ef 81       	ldd	r30, Y+7	; 0x07
    1294:	f8 85       	ldd	r31, Y+8	; 0x08
    1296:	86 81       	ldd	r24, Z+6	; 0x06
    1298:	97 81       	ldd	r25, Z+7	; 0x07
    129a:	9a 83       	std	Y+2, r25	; 0x02
    129c:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    129e:	8f 81       	ldd	r24, Y+7	; 0x07
    12a0:	98 85       	ldd	r25, Y+8	; 0x08
    12a2:	29 85       	ldd	r18, Y+9	; 0x09
    12a4:	3a 85       	ldd	r19, Y+10	; 0x0a
    12a6:	b9 01       	movw	r22, r18
    12a8:	0e 94 13 0b 	call	0x1626	; 0x1626 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    12ac:	8d 85       	ldd	r24, Y+13	; 0x0d
    12ae:	88 23       	and	r24, r24
    12b0:	b1 f4       	brne	.+44     	; 0x12de <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    12b2:	ef 81       	ldd	r30, Y+7	; 0x07
    12b4:	f8 85       	ldd	r31, Y+8	; 0x08
    12b6:	82 8d       	ldd	r24, Z+26	; 0x1a
    12b8:	81 50       	subi	r24, 0x01	; 1
    12ba:	ef 81       	ldd	r30, Y+7	; 0x07
    12bc:	f8 85       	ldd	r31, Y+8	; 0x08
    12be:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    12c0:	ef 81       	ldd	r30, Y+7	; 0x07
    12c2:	f8 85       	ldd	r31, Y+8	; 0x08
    12c4:	80 85       	ldd	r24, Z+8	; 0x08
    12c6:	88 23       	and	r24, r24
    12c8:	f1 f0       	breq	.+60     	; 0x1306 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    12ca:	8f 81       	ldd	r24, Y+7	; 0x07
    12cc:	98 85       	ldd	r25, Y+8	; 0x08
    12ce:	08 96       	adiw	r24, 0x08	; 8
    12d0:	0e 94 93 10 	call	0x2126	; 0x2126 <xTaskRemoveFromEventList>
    12d4:	81 30       	cpi	r24, 0x01	; 1
    12d6:	b9 f4       	brne	.+46     	; 0x1306 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    12d8:	0e 94 87 06 	call	0xd0e	; 0xd0e <vPortYield>
    12dc:	14 c0       	rjmp	.+40     	; 0x1306 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    12de:	ef 81       	ldd	r30, Y+7	; 0x07
    12e0:	f8 85       	ldd	r31, Y+8	; 0x08
    12e2:	89 81       	ldd	r24, Y+1	; 0x01
    12e4:	9a 81       	ldd	r25, Y+2	; 0x02
    12e6:	97 83       	std	Z+7, r25	; 0x07
    12e8:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12ea:	ef 81       	ldd	r30, Y+7	; 0x07
    12ec:	f8 85       	ldd	r31, Y+8	; 0x08
    12ee:	81 89       	ldd	r24, Z+17	; 0x11
    12f0:	88 23       	and	r24, r24
    12f2:	49 f0       	breq	.+18     	; 0x1306 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12f4:	8f 81       	ldd	r24, Y+7	; 0x07
    12f6:	98 85       	ldd	r25, Y+8	; 0x08
    12f8:	41 96       	adiw	r24, 0x11	; 17
    12fa:	0e 94 93 10 	call	0x2126	; 0x2126 <xTaskRemoveFromEventList>
    12fe:	88 23       	and	r24, r24
    1300:	11 f0       	breq	.+4      	; 0x1306 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1302:	0e 94 87 06 	call	0xd0e	; 0xd0e <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1306:	0f 90       	pop	r0
    1308:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    130a:	81 e0       	ldi	r24, 0x01	; 1
    130c:	8e 87       	std	Y+14, r24	; 0x0e
    130e:	5c c0       	rjmp	.+184    	; 0x13c8 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1310:	8b 85       	ldd	r24, Y+11	; 0x0b
    1312:	9c 85       	ldd	r25, Y+12	; 0x0c
    1314:	00 97       	sbiw	r24, 0x00	; 0
    1316:	21 f4       	brne	.+8      	; 0x1320 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1318:	0f 90       	pop	r0
    131a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    131c:	1e 86       	std	Y+14, r1	; 0x0e
    131e:	54 c0       	rjmp	.+168    	; 0x13c8 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1320:	8b 81       	ldd	r24, Y+3	; 0x03
    1322:	88 23       	and	r24, r24
    1324:	31 f4       	brne	.+12     	; 0x1332 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1326:	ce 01       	movw	r24, r28
    1328:	04 96       	adiw	r24, 0x04	; 4
    132a:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    132e:	81 e0       	ldi	r24, 0x01	; 1
    1330:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    1332:	0f 90       	pop	r0
    1334:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1336:	0e 94 57 0e 	call	0x1cae	; 0x1cae <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    133a:	0f b6       	in	r0, 0x3f	; 63
    133c:	f8 94       	cli
    133e:	0f 92       	push	r0
    1340:	ef 81       	ldd	r30, Y+7	; 0x07
    1342:	f8 85       	ldd	r31, Y+8	; 0x08
    1344:	85 8d       	ldd	r24, Z+29	; 0x1d
    1346:	8f 3f       	cpi	r24, 0xFF	; 255
    1348:	19 f4       	brne	.+6      	; 0x1350 <xQueueGenericReceive+0xf4>
    134a:	ef 81       	ldd	r30, Y+7	; 0x07
    134c:	f8 85       	ldd	r31, Y+8	; 0x08
    134e:	15 8e       	std	Z+29, r1	; 0x1d
    1350:	ef 81       	ldd	r30, Y+7	; 0x07
    1352:	f8 85       	ldd	r31, Y+8	; 0x08
    1354:	86 8d       	ldd	r24, Z+30	; 0x1e
    1356:	8f 3f       	cpi	r24, 0xFF	; 255
    1358:	19 f4       	brne	.+6      	; 0x1360 <xQueueGenericReceive+0x104>
    135a:	ef 81       	ldd	r30, Y+7	; 0x07
    135c:	f8 85       	ldd	r31, Y+8	; 0x08
    135e:	16 8e       	std	Z+30, r1	; 0x1e
    1360:	0f 90       	pop	r0
    1362:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1364:	ce 01       	movw	r24, r28
    1366:	04 96       	adiw	r24, 0x04	; 4
    1368:	9e 01       	movw	r18, r28
    136a:	25 5f       	subi	r18, 0xF5	; 245
    136c:	3f 4f       	sbci	r19, 0xFF	; 255
    136e:	b9 01       	movw	r22, r18
    1370:	0e 94 14 11 	call	0x2228	; 0x2228 <xTaskCheckForTimeOut>
    1374:	88 23       	and	r24, r24
    1376:	09 f5       	brne	.+66     	; 0x13ba <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1378:	8f 81       	ldd	r24, Y+7	; 0x07
    137a:	98 85       	ldd	r25, Y+8	; 0x08
    137c:	0e 94 af 0b 	call	0x175e	; 0x175e <prvIsQueueEmpty>
    1380:	88 23       	and	r24, r24
    1382:	a1 f0       	breq	.+40     	; 0x13ac <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1384:	8f 81       	ldd	r24, Y+7	; 0x07
    1386:	98 85       	ldd	r25, Y+8	; 0x08
    1388:	41 96       	adiw	r24, 0x11	; 17
    138a:	2b 85       	ldd	r18, Y+11	; 0x0b
    138c:	3c 85       	ldd	r19, Y+12	; 0x0c
    138e:	b9 01       	movw	r22, r18
    1390:	0e 94 5d 10 	call	0x20ba	; 0x20ba <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1394:	8f 81       	ldd	r24, Y+7	; 0x07
    1396:	98 85       	ldd	r25, Y+8	; 0x08
    1398:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    139c:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <xTaskResumeAll>
    13a0:	88 23       	and	r24, r24
    13a2:	09 f0       	breq	.+2      	; 0x13a6 <xQueueGenericReceive+0x14a>
    13a4:	6d cf       	rjmp	.-294    	; 0x1280 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    13a6:	0e 94 87 06 	call	0xd0e	; 0xd0e <vPortYield>
    13aa:	6a cf       	rjmp	.-300    	; 0x1280 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    13ac:	8f 81       	ldd	r24, Y+7	; 0x07
    13ae:	98 85       	ldd	r25, Y+8	; 0x08
    13b0:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    13b4:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <xTaskResumeAll>
    13b8:	63 cf       	rjmp	.-314    	; 0x1280 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    13ba:	8f 81       	ldd	r24, Y+7	; 0x07
    13bc:	98 85       	ldd	r25, Y+8	; 0x08
    13be:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    13c2:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    13c6:	1e 86       	std	Y+14, r1	; 0x0e
    13c8:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    13ca:	2e 96       	adiw	r28, 0x0e	; 14
    13cc:	0f b6       	in	r0, 0x3f	; 63
    13ce:	f8 94       	cli
    13d0:	de bf       	out	0x3e, r29	; 62
    13d2:	0f be       	out	0x3f, r0	; 63
    13d4:	cd bf       	out	0x3d, r28	; 61
    13d6:	cf 91       	pop	r28
    13d8:	df 91       	pop	r29
    13da:	08 95       	ret

000013dc <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    13dc:	df 93       	push	r29
    13de:	cf 93       	push	r28
    13e0:	cd b7       	in	r28, 0x3d	; 61
    13e2:	de b7       	in	r29, 0x3e	; 62
    13e4:	28 97       	sbiw	r28, 0x08	; 8
    13e6:	0f b6       	in	r0, 0x3f	; 63
    13e8:	f8 94       	cli
    13ea:	de bf       	out	0x3e, r29	; 62
    13ec:	0f be       	out	0x3f, r0	; 63
    13ee:	cd bf       	out	0x3d, r28	; 61
    13f0:	9c 83       	std	Y+4, r25	; 0x04
    13f2:	8b 83       	std	Y+3, r24	; 0x03
    13f4:	7e 83       	std	Y+6, r23	; 0x06
    13f6:	6d 83       	std	Y+5, r22	; 0x05
    13f8:	58 87       	std	Y+8, r21	; 0x08
    13fa:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    13fc:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    13fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1400:	fc 81       	ldd	r31, Y+4	; 0x04
    1402:	82 8d       	ldd	r24, Z+26	; 0x1a
    1404:	88 23       	and	r24, r24
    1406:	71 f1       	breq	.+92     	; 0x1464 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1408:	8b 81       	ldd	r24, Y+3	; 0x03
    140a:	9c 81       	ldd	r25, Y+4	; 0x04
    140c:	2d 81       	ldd	r18, Y+5	; 0x05
    140e:	3e 81       	ldd	r19, Y+6	; 0x06
    1410:	b9 01       	movw	r22, r18
    1412:	0e 94 13 0b 	call	0x1626	; 0x1626 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1416:	eb 81       	ldd	r30, Y+3	; 0x03
    1418:	fc 81       	ldd	r31, Y+4	; 0x04
    141a:	82 8d       	ldd	r24, Z+26	; 0x1a
    141c:	81 50       	subi	r24, 0x01	; 1
    141e:	eb 81       	ldd	r30, Y+3	; 0x03
    1420:	fc 81       	ldd	r31, Y+4	; 0x04
    1422:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1424:	eb 81       	ldd	r30, Y+3	; 0x03
    1426:	fc 81       	ldd	r31, Y+4	; 0x04
    1428:	85 8d       	ldd	r24, Z+29	; 0x1d
    142a:	8f 3f       	cpi	r24, 0xFF	; 255
    142c:	89 f4       	brne	.+34     	; 0x1450 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    142e:	eb 81       	ldd	r30, Y+3	; 0x03
    1430:	fc 81       	ldd	r31, Y+4	; 0x04
    1432:	80 85       	ldd	r24, Z+8	; 0x08
    1434:	88 23       	and	r24, r24
    1436:	99 f0       	breq	.+38     	; 0x145e <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1438:	8b 81       	ldd	r24, Y+3	; 0x03
    143a:	9c 81       	ldd	r25, Y+4	; 0x04
    143c:	08 96       	adiw	r24, 0x08	; 8
    143e:	0e 94 93 10 	call	0x2126	; 0x2126 <xTaskRemoveFromEventList>
    1442:	88 23       	and	r24, r24
    1444:	61 f0       	breq	.+24     	; 0x145e <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1446:	ef 81       	ldd	r30, Y+7	; 0x07
    1448:	f8 85       	ldd	r31, Y+8	; 0x08
    144a:	81 e0       	ldi	r24, 0x01	; 1
    144c:	80 83       	st	Z, r24
    144e:	07 c0       	rjmp	.+14     	; 0x145e <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1450:	eb 81       	ldd	r30, Y+3	; 0x03
    1452:	fc 81       	ldd	r31, Y+4	; 0x04
    1454:	85 8d       	ldd	r24, Z+29	; 0x1d
    1456:	8f 5f       	subi	r24, 0xFF	; 255
    1458:	eb 81       	ldd	r30, Y+3	; 0x03
    145a:	fc 81       	ldd	r31, Y+4	; 0x04
    145c:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    145e:	81 e0       	ldi	r24, 0x01	; 1
    1460:	8a 83       	std	Y+2, r24	; 0x02
    1462:	01 c0       	rjmp	.+2      	; 0x1466 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    1464:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1466:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1468:	28 96       	adiw	r28, 0x08	; 8
    146a:	0f b6       	in	r0, 0x3f	; 63
    146c:	f8 94       	cli
    146e:	de bf       	out	0x3e, r29	; 62
    1470:	0f be       	out	0x3f, r0	; 63
    1472:	cd bf       	out	0x3d, r28	; 61
    1474:	cf 91       	pop	r28
    1476:	df 91       	pop	r29
    1478:	08 95       	ret

0000147a <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    147a:	df 93       	push	r29
    147c:	cf 93       	push	r28
    147e:	00 d0       	rcall	.+0      	; 0x1480 <uxQueueMessagesWaiting+0x6>
    1480:	0f 92       	push	r0
    1482:	cd b7       	in	r28, 0x3d	; 61
    1484:	de b7       	in	r29, 0x3e	; 62
    1486:	9b 83       	std	Y+3, r25	; 0x03
    1488:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    148a:	0f b6       	in	r0, 0x3f	; 63
    148c:	f8 94       	cli
    148e:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1490:	ea 81       	ldd	r30, Y+2	; 0x02
    1492:	fb 81       	ldd	r31, Y+3	; 0x03
    1494:	82 8d       	ldd	r24, Z+26	; 0x1a
    1496:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1498:	0f 90       	pop	r0
    149a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    149c:	89 81       	ldd	r24, Y+1	; 0x01
}
    149e:	0f 90       	pop	r0
    14a0:	0f 90       	pop	r0
    14a2:	0f 90       	pop	r0
    14a4:	cf 91       	pop	r28
    14a6:	df 91       	pop	r29
    14a8:	08 95       	ret

000014aa <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    14aa:	df 93       	push	r29
    14ac:	cf 93       	push	r28
    14ae:	00 d0       	rcall	.+0      	; 0x14b0 <uxQueueMessagesWaitingFromISR+0x6>
    14b0:	0f 92       	push	r0
    14b2:	cd b7       	in	r28, 0x3d	; 61
    14b4:	de b7       	in	r29, 0x3e	; 62
    14b6:	9b 83       	std	Y+3, r25	; 0x03
    14b8:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    14ba:	ea 81       	ldd	r30, Y+2	; 0x02
    14bc:	fb 81       	ldd	r31, Y+3	; 0x03
    14be:	82 8d       	ldd	r24, Z+26	; 0x1a
    14c0:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    14c2:	89 81       	ldd	r24, Y+1	; 0x01
}
    14c4:	0f 90       	pop	r0
    14c6:	0f 90       	pop	r0
    14c8:	0f 90       	pop	r0
    14ca:	cf 91       	pop	r28
    14cc:	df 91       	pop	r29
    14ce:	08 95       	ret

000014d0 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    14d0:	df 93       	push	r29
    14d2:	cf 93       	push	r28
    14d4:	00 d0       	rcall	.+0      	; 0x14d6 <vQueueDelete+0x6>
    14d6:	cd b7       	in	r28, 0x3d	; 61
    14d8:	de b7       	in	r29, 0x3e	; 62
    14da:	9a 83       	std	Y+2, r25	; 0x02
    14dc:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    14de:	e9 81       	ldd	r30, Y+1	; 0x01
    14e0:	fa 81       	ldd	r31, Y+2	; 0x02
    14e2:	80 81       	ld	r24, Z
    14e4:	91 81       	ldd	r25, Z+1	; 0x01
    14e6:	0e 94 67 03 	call	0x6ce	; 0x6ce <vPortFree>
	vPortFree( pxQueue );
    14ea:	89 81       	ldd	r24, Y+1	; 0x01
    14ec:	9a 81       	ldd	r25, Y+2	; 0x02
    14ee:	0e 94 67 03 	call	0x6ce	; 0x6ce <vPortFree>
}
    14f2:	0f 90       	pop	r0
    14f4:	0f 90       	pop	r0
    14f6:	cf 91       	pop	r28
    14f8:	df 91       	pop	r29
    14fa:	08 95       	ret

000014fc <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    14fc:	df 93       	push	r29
    14fe:	cf 93       	push	r28
    1500:	00 d0       	rcall	.+0      	; 0x1502 <prvCopyDataToQueue+0x6>
    1502:	00 d0       	rcall	.+0      	; 0x1504 <prvCopyDataToQueue+0x8>
    1504:	0f 92       	push	r0
    1506:	cd b7       	in	r28, 0x3d	; 61
    1508:	de b7       	in	r29, 0x3e	; 62
    150a:	9a 83       	std	Y+2, r25	; 0x02
    150c:	89 83       	std	Y+1, r24	; 0x01
    150e:	7c 83       	std	Y+4, r23	; 0x04
    1510:	6b 83       	std	Y+3, r22	; 0x03
    1512:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1514:	e9 81       	ldd	r30, Y+1	; 0x01
    1516:	fa 81       	ldd	r31, Y+2	; 0x02
    1518:	84 8d       	ldd	r24, Z+28	; 0x1c
    151a:	88 23       	and	r24, r24
    151c:	09 f4       	brne	.+2      	; 0x1520 <prvCopyDataToQueue+0x24>
    151e:	74 c0       	rjmp	.+232    	; 0x1608 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1520:	8d 81       	ldd	r24, Y+5	; 0x05
    1522:	88 23       	and	r24, r24
    1524:	99 f5       	brne	.+102    	; 0x158c <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1526:	e9 81       	ldd	r30, Y+1	; 0x01
    1528:	fa 81       	ldd	r31, Y+2	; 0x02
    152a:	64 81       	ldd	r22, Z+4	; 0x04
    152c:	75 81       	ldd	r23, Z+5	; 0x05
    152e:	e9 81       	ldd	r30, Y+1	; 0x01
    1530:	fa 81       	ldd	r31, Y+2	; 0x02
    1532:	84 8d       	ldd	r24, Z+28	; 0x1c
    1534:	48 2f       	mov	r20, r24
    1536:	50 e0       	ldi	r21, 0x00	; 0
    1538:	2b 81       	ldd	r18, Y+3	; 0x03
    153a:	3c 81       	ldd	r19, Y+4	; 0x04
    153c:	cb 01       	movw	r24, r22
    153e:	b9 01       	movw	r22, r18
    1540:	0e 94 b6 19 	call	0x336c	; 0x336c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1544:	e9 81       	ldd	r30, Y+1	; 0x01
    1546:	fa 81       	ldd	r31, Y+2	; 0x02
    1548:	24 81       	ldd	r18, Z+4	; 0x04
    154a:	35 81       	ldd	r19, Z+5	; 0x05
    154c:	e9 81       	ldd	r30, Y+1	; 0x01
    154e:	fa 81       	ldd	r31, Y+2	; 0x02
    1550:	84 8d       	ldd	r24, Z+28	; 0x1c
    1552:	88 2f       	mov	r24, r24
    1554:	90 e0       	ldi	r25, 0x00	; 0
    1556:	82 0f       	add	r24, r18
    1558:	93 1f       	adc	r25, r19
    155a:	e9 81       	ldd	r30, Y+1	; 0x01
    155c:	fa 81       	ldd	r31, Y+2	; 0x02
    155e:	95 83       	std	Z+5, r25	; 0x05
    1560:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1562:	e9 81       	ldd	r30, Y+1	; 0x01
    1564:	fa 81       	ldd	r31, Y+2	; 0x02
    1566:	24 81       	ldd	r18, Z+4	; 0x04
    1568:	35 81       	ldd	r19, Z+5	; 0x05
    156a:	e9 81       	ldd	r30, Y+1	; 0x01
    156c:	fa 81       	ldd	r31, Y+2	; 0x02
    156e:	82 81       	ldd	r24, Z+2	; 0x02
    1570:	93 81       	ldd	r25, Z+3	; 0x03
    1572:	28 17       	cp	r18, r24
    1574:	39 07       	cpc	r19, r25
    1576:	08 f4       	brcc	.+2      	; 0x157a <prvCopyDataToQueue+0x7e>
    1578:	47 c0       	rjmp	.+142    	; 0x1608 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    157a:	e9 81       	ldd	r30, Y+1	; 0x01
    157c:	fa 81       	ldd	r31, Y+2	; 0x02
    157e:	80 81       	ld	r24, Z
    1580:	91 81       	ldd	r25, Z+1	; 0x01
    1582:	e9 81       	ldd	r30, Y+1	; 0x01
    1584:	fa 81       	ldd	r31, Y+2	; 0x02
    1586:	95 83       	std	Z+5, r25	; 0x05
    1588:	84 83       	std	Z+4, r24	; 0x04
    158a:	3e c0       	rjmp	.+124    	; 0x1608 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    158c:	e9 81       	ldd	r30, Y+1	; 0x01
    158e:	fa 81       	ldd	r31, Y+2	; 0x02
    1590:	66 81       	ldd	r22, Z+6	; 0x06
    1592:	77 81       	ldd	r23, Z+7	; 0x07
    1594:	e9 81       	ldd	r30, Y+1	; 0x01
    1596:	fa 81       	ldd	r31, Y+2	; 0x02
    1598:	84 8d       	ldd	r24, Z+28	; 0x1c
    159a:	48 2f       	mov	r20, r24
    159c:	50 e0       	ldi	r21, 0x00	; 0
    159e:	2b 81       	ldd	r18, Y+3	; 0x03
    15a0:	3c 81       	ldd	r19, Y+4	; 0x04
    15a2:	cb 01       	movw	r24, r22
    15a4:	b9 01       	movw	r22, r18
    15a6:	0e 94 b6 19 	call	0x336c	; 0x336c <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    15aa:	e9 81       	ldd	r30, Y+1	; 0x01
    15ac:	fa 81       	ldd	r31, Y+2	; 0x02
    15ae:	26 81       	ldd	r18, Z+6	; 0x06
    15b0:	37 81       	ldd	r19, Z+7	; 0x07
    15b2:	e9 81       	ldd	r30, Y+1	; 0x01
    15b4:	fa 81       	ldd	r31, Y+2	; 0x02
    15b6:	84 8d       	ldd	r24, Z+28	; 0x1c
    15b8:	88 2f       	mov	r24, r24
    15ba:	90 e0       	ldi	r25, 0x00	; 0
    15bc:	90 95       	com	r25
    15be:	81 95       	neg	r24
    15c0:	9f 4f       	sbci	r25, 0xFF	; 255
    15c2:	82 0f       	add	r24, r18
    15c4:	93 1f       	adc	r25, r19
    15c6:	e9 81       	ldd	r30, Y+1	; 0x01
    15c8:	fa 81       	ldd	r31, Y+2	; 0x02
    15ca:	97 83       	std	Z+7, r25	; 0x07
    15cc:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    15ce:	e9 81       	ldd	r30, Y+1	; 0x01
    15d0:	fa 81       	ldd	r31, Y+2	; 0x02
    15d2:	26 81       	ldd	r18, Z+6	; 0x06
    15d4:	37 81       	ldd	r19, Z+7	; 0x07
    15d6:	e9 81       	ldd	r30, Y+1	; 0x01
    15d8:	fa 81       	ldd	r31, Y+2	; 0x02
    15da:	80 81       	ld	r24, Z
    15dc:	91 81       	ldd	r25, Z+1	; 0x01
    15de:	28 17       	cp	r18, r24
    15e0:	39 07       	cpc	r19, r25
    15e2:	90 f4       	brcc	.+36     	; 0x1608 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    15e4:	e9 81       	ldd	r30, Y+1	; 0x01
    15e6:	fa 81       	ldd	r31, Y+2	; 0x02
    15e8:	22 81       	ldd	r18, Z+2	; 0x02
    15ea:	33 81       	ldd	r19, Z+3	; 0x03
    15ec:	e9 81       	ldd	r30, Y+1	; 0x01
    15ee:	fa 81       	ldd	r31, Y+2	; 0x02
    15f0:	84 8d       	ldd	r24, Z+28	; 0x1c
    15f2:	88 2f       	mov	r24, r24
    15f4:	90 e0       	ldi	r25, 0x00	; 0
    15f6:	90 95       	com	r25
    15f8:	81 95       	neg	r24
    15fa:	9f 4f       	sbci	r25, 0xFF	; 255
    15fc:	82 0f       	add	r24, r18
    15fe:	93 1f       	adc	r25, r19
    1600:	e9 81       	ldd	r30, Y+1	; 0x01
    1602:	fa 81       	ldd	r31, Y+2	; 0x02
    1604:	97 83       	std	Z+7, r25	; 0x07
    1606:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1608:	e9 81       	ldd	r30, Y+1	; 0x01
    160a:	fa 81       	ldd	r31, Y+2	; 0x02
    160c:	82 8d       	ldd	r24, Z+26	; 0x1a
    160e:	8f 5f       	subi	r24, 0xFF	; 255
    1610:	e9 81       	ldd	r30, Y+1	; 0x01
    1612:	fa 81       	ldd	r31, Y+2	; 0x02
    1614:	82 8f       	std	Z+26, r24	; 0x1a
}
    1616:	0f 90       	pop	r0
    1618:	0f 90       	pop	r0
    161a:	0f 90       	pop	r0
    161c:	0f 90       	pop	r0
    161e:	0f 90       	pop	r0
    1620:	cf 91       	pop	r28
    1622:	df 91       	pop	r29
    1624:	08 95       	ret

00001626 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1626:	df 93       	push	r29
    1628:	cf 93       	push	r28
    162a:	00 d0       	rcall	.+0      	; 0x162c <prvCopyDataFromQueue+0x6>
    162c:	00 d0       	rcall	.+0      	; 0x162e <prvCopyDataFromQueue+0x8>
    162e:	cd b7       	in	r28, 0x3d	; 61
    1630:	de b7       	in	r29, 0x3e	; 62
    1632:	9a 83       	std	Y+2, r25	; 0x02
    1634:	89 83       	std	Y+1, r24	; 0x01
    1636:	7c 83       	std	Y+4, r23	; 0x04
    1638:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    163a:	e9 81       	ldd	r30, Y+1	; 0x01
    163c:	fa 81       	ldd	r31, Y+2	; 0x02
    163e:	80 81       	ld	r24, Z
    1640:	91 81       	ldd	r25, Z+1	; 0x01
    1642:	00 97       	sbiw	r24, 0x00	; 0
    1644:	89 f1       	breq	.+98     	; 0x16a8 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1646:	e9 81       	ldd	r30, Y+1	; 0x01
    1648:	fa 81       	ldd	r31, Y+2	; 0x02
    164a:	26 81       	ldd	r18, Z+6	; 0x06
    164c:	37 81       	ldd	r19, Z+7	; 0x07
    164e:	e9 81       	ldd	r30, Y+1	; 0x01
    1650:	fa 81       	ldd	r31, Y+2	; 0x02
    1652:	84 8d       	ldd	r24, Z+28	; 0x1c
    1654:	88 2f       	mov	r24, r24
    1656:	90 e0       	ldi	r25, 0x00	; 0
    1658:	82 0f       	add	r24, r18
    165a:	93 1f       	adc	r25, r19
    165c:	e9 81       	ldd	r30, Y+1	; 0x01
    165e:	fa 81       	ldd	r31, Y+2	; 0x02
    1660:	97 83       	std	Z+7, r25	; 0x07
    1662:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1664:	e9 81       	ldd	r30, Y+1	; 0x01
    1666:	fa 81       	ldd	r31, Y+2	; 0x02
    1668:	26 81       	ldd	r18, Z+6	; 0x06
    166a:	37 81       	ldd	r19, Z+7	; 0x07
    166c:	e9 81       	ldd	r30, Y+1	; 0x01
    166e:	fa 81       	ldd	r31, Y+2	; 0x02
    1670:	82 81       	ldd	r24, Z+2	; 0x02
    1672:	93 81       	ldd	r25, Z+3	; 0x03
    1674:	28 17       	cp	r18, r24
    1676:	39 07       	cpc	r19, r25
    1678:	40 f0       	brcs	.+16     	; 0x168a <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    167a:	e9 81       	ldd	r30, Y+1	; 0x01
    167c:	fa 81       	ldd	r31, Y+2	; 0x02
    167e:	80 81       	ld	r24, Z
    1680:	91 81       	ldd	r25, Z+1	; 0x01
    1682:	e9 81       	ldd	r30, Y+1	; 0x01
    1684:	fa 81       	ldd	r31, Y+2	; 0x02
    1686:	97 83       	std	Z+7, r25	; 0x07
    1688:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    168a:	e9 81       	ldd	r30, Y+1	; 0x01
    168c:	fa 81       	ldd	r31, Y+2	; 0x02
    168e:	46 81       	ldd	r20, Z+6	; 0x06
    1690:	57 81       	ldd	r21, Z+7	; 0x07
    1692:	e9 81       	ldd	r30, Y+1	; 0x01
    1694:	fa 81       	ldd	r31, Y+2	; 0x02
    1696:	84 8d       	ldd	r24, Z+28	; 0x1c
    1698:	28 2f       	mov	r18, r24
    169a:	30 e0       	ldi	r19, 0x00	; 0
    169c:	8b 81       	ldd	r24, Y+3	; 0x03
    169e:	9c 81       	ldd	r25, Y+4	; 0x04
    16a0:	ba 01       	movw	r22, r20
    16a2:	a9 01       	movw	r20, r18
    16a4:	0e 94 b6 19 	call	0x336c	; 0x336c <memcpy>
	}
}
    16a8:	0f 90       	pop	r0
    16aa:	0f 90       	pop	r0
    16ac:	0f 90       	pop	r0
    16ae:	0f 90       	pop	r0
    16b0:	cf 91       	pop	r28
    16b2:	df 91       	pop	r29
    16b4:	08 95       	ret

000016b6 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    16b6:	df 93       	push	r29
    16b8:	cf 93       	push	r28
    16ba:	00 d0       	rcall	.+0      	; 0x16bc <prvUnlockQueue+0x6>
    16bc:	cd b7       	in	r28, 0x3d	; 61
    16be:	de b7       	in	r29, 0x3e	; 62
    16c0:	9a 83       	std	Y+2, r25	; 0x02
    16c2:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    16c4:	0f b6       	in	r0, 0x3f	; 63
    16c6:	f8 94       	cli
    16c8:	0f 92       	push	r0
    16ca:	15 c0       	rjmp	.+42     	; 0x16f6 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16cc:	e9 81       	ldd	r30, Y+1	; 0x01
    16ce:	fa 81       	ldd	r31, Y+2	; 0x02
    16d0:	81 89       	ldd	r24, Z+17	; 0x11
    16d2:	88 23       	and	r24, r24
    16d4:	a9 f0       	breq	.+42     	; 0x1700 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    16d6:	89 81       	ldd	r24, Y+1	; 0x01
    16d8:	9a 81       	ldd	r25, Y+2	; 0x02
    16da:	41 96       	adiw	r24, 0x11	; 17
    16dc:	0e 94 93 10 	call	0x2126	; 0x2126 <xTaskRemoveFromEventList>
    16e0:	88 23       	and	r24, r24
    16e2:	11 f0       	breq	.+4      	; 0x16e8 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    16e4:	0e 94 71 11 	call	0x22e2	; 0x22e2 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    16e8:	e9 81       	ldd	r30, Y+1	; 0x01
    16ea:	fa 81       	ldd	r31, Y+2	; 0x02
    16ec:	86 8d       	ldd	r24, Z+30	; 0x1e
    16ee:	81 50       	subi	r24, 0x01	; 1
    16f0:	e9 81       	ldd	r30, Y+1	; 0x01
    16f2:	fa 81       	ldd	r31, Y+2	; 0x02
    16f4:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    16f6:	e9 81       	ldd	r30, Y+1	; 0x01
    16f8:	fa 81       	ldd	r31, Y+2	; 0x02
    16fa:	86 8d       	ldd	r24, Z+30	; 0x1e
    16fc:	18 16       	cp	r1, r24
    16fe:	34 f3       	brlt	.-52     	; 0x16cc <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1700:	e9 81       	ldd	r30, Y+1	; 0x01
    1702:	fa 81       	ldd	r31, Y+2	; 0x02
    1704:	8f ef       	ldi	r24, 0xFF	; 255
    1706:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1708:	0f 90       	pop	r0
    170a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    170c:	0f b6       	in	r0, 0x3f	; 63
    170e:	f8 94       	cli
    1710:	0f 92       	push	r0
    1712:	15 c0       	rjmp	.+42     	; 0x173e <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1714:	e9 81       	ldd	r30, Y+1	; 0x01
    1716:	fa 81       	ldd	r31, Y+2	; 0x02
    1718:	80 85       	ldd	r24, Z+8	; 0x08
    171a:	88 23       	and	r24, r24
    171c:	a9 f0       	breq	.+42     	; 0x1748 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    171e:	89 81       	ldd	r24, Y+1	; 0x01
    1720:	9a 81       	ldd	r25, Y+2	; 0x02
    1722:	08 96       	adiw	r24, 0x08	; 8
    1724:	0e 94 93 10 	call	0x2126	; 0x2126 <xTaskRemoveFromEventList>
    1728:	88 23       	and	r24, r24
    172a:	11 f0       	breq	.+4      	; 0x1730 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    172c:	0e 94 71 11 	call	0x22e2	; 0x22e2 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1730:	e9 81       	ldd	r30, Y+1	; 0x01
    1732:	fa 81       	ldd	r31, Y+2	; 0x02
    1734:	85 8d       	ldd	r24, Z+29	; 0x1d
    1736:	81 50       	subi	r24, 0x01	; 1
    1738:	e9 81       	ldd	r30, Y+1	; 0x01
    173a:	fa 81       	ldd	r31, Y+2	; 0x02
    173c:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    173e:	e9 81       	ldd	r30, Y+1	; 0x01
    1740:	fa 81       	ldd	r31, Y+2	; 0x02
    1742:	85 8d       	ldd	r24, Z+29	; 0x1d
    1744:	18 16       	cp	r1, r24
    1746:	34 f3       	brlt	.-52     	; 0x1714 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1748:	e9 81       	ldd	r30, Y+1	; 0x01
    174a:	fa 81       	ldd	r31, Y+2	; 0x02
    174c:	8f ef       	ldi	r24, 0xFF	; 255
    174e:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1750:	0f 90       	pop	r0
    1752:	0f be       	out	0x3f, r0	; 63
}
    1754:	0f 90       	pop	r0
    1756:	0f 90       	pop	r0
    1758:	cf 91       	pop	r28
    175a:	df 91       	pop	r29
    175c:	08 95       	ret

0000175e <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    175e:	df 93       	push	r29
    1760:	cf 93       	push	r28
    1762:	00 d0       	rcall	.+0      	; 0x1764 <prvIsQueueEmpty+0x6>
    1764:	0f 92       	push	r0
    1766:	cd b7       	in	r28, 0x3d	; 61
    1768:	de b7       	in	r29, 0x3e	; 62
    176a:	9b 83       	std	Y+3, r25	; 0x03
    176c:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    176e:	0f b6       	in	r0, 0x3f	; 63
    1770:	f8 94       	cli
    1772:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1774:	ea 81       	ldd	r30, Y+2	; 0x02
    1776:	fb 81       	ldd	r31, Y+3	; 0x03
    1778:	82 8d       	ldd	r24, Z+26	; 0x1a
    177a:	19 82       	std	Y+1, r1	; 0x01
    177c:	88 23       	and	r24, r24
    177e:	11 f4       	brne	.+4      	; 0x1784 <prvIsQueueEmpty+0x26>
    1780:	81 e0       	ldi	r24, 0x01	; 1
    1782:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1784:	0f 90       	pop	r0
    1786:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1788:	89 81       	ldd	r24, Y+1	; 0x01
}
    178a:	0f 90       	pop	r0
    178c:	0f 90       	pop	r0
    178e:	0f 90       	pop	r0
    1790:	cf 91       	pop	r28
    1792:	df 91       	pop	r29
    1794:	08 95       	ret

00001796 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1796:	df 93       	push	r29
    1798:	cf 93       	push	r28
    179a:	00 d0       	rcall	.+0      	; 0x179c <xQueueIsQueueEmptyFromISR+0x6>
    179c:	0f 92       	push	r0
    179e:	cd b7       	in	r28, 0x3d	; 61
    17a0:	de b7       	in	r29, 0x3e	; 62
    17a2:	9b 83       	std	Y+3, r25	; 0x03
    17a4:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    17a6:	ea 81       	ldd	r30, Y+2	; 0x02
    17a8:	fb 81       	ldd	r31, Y+3	; 0x03
    17aa:	82 8d       	ldd	r24, Z+26	; 0x1a
    17ac:	19 82       	std	Y+1, r1	; 0x01
    17ae:	88 23       	and	r24, r24
    17b0:	11 f4       	brne	.+4      	; 0x17b6 <xQueueIsQueueEmptyFromISR+0x20>
    17b2:	81 e0       	ldi	r24, 0x01	; 1
    17b4:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    17b6:	89 81       	ldd	r24, Y+1	; 0x01
}
    17b8:	0f 90       	pop	r0
    17ba:	0f 90       	pop	r0
    17bc:	0f 90       	pop	r0
    17be:	cf 91       	pop	r28
    17c0:	df 91       	pop	r29
    17c2:	08 95       	ret

000017c4 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    17c4:	df 93       	push	r29
    17c6:	cf 93       	push	r28
    17c8:	00 d0       	rcall	.+0      	; 0x17ca <prvIsQueueFull+0x6>
    17ca:	0f 92       	push	r0
    17cc:	cd b7       	in	r28, 0x3d	; 61
    17ce:	de b7       	in	r29, 0x3e	; 62
    17d0:	9b 83       	std	Y+3, r25	; 0x03
    17d2:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    17d4:	0f b6       	in	r0, 0x3f	; 63
    17d6:	f8 94       	cli
    17d8:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    17da:	ea 81       	ldd	r30, Y+2	; 0x02
    17dc:	fb 81       	ldd	r31, Y+3	; 0x03
    17de:	92 8d       	ldd	r25, Z+26	; 0x1a
    17e0:	ea 81       	ldd	r30, Y+2	; 0x02
    17e2:	fb 81       	ldd	r31, Y+3	; 0x03
    17e4:	83 8d       	ldd	r24, Z+27	; 0x1b
    17e6:	19 82       	std	Y+1, r1	; 0x01
    17e8:	98 17       	cp	r25, r24
    17ea:	11 f4       	brne	.+4      	; 0x17f0 <prvIsQueueFull+0x2c>
    17ec:	81 e0       	ldi	r24, 0x01	; 1
    17ee:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    17f0:	0f 90       	pop	r0
    17f2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    17f4:	89 81       	ldd	r24, Y+1	; 0x01
}
    17f6:	0f 90       	pop	r0
    17f8:	0f 90       	pop	r0
    17fa:	0f 90       	pop	r0
    17fc:	cf 91       	pop	r28
    17fe:	df 91       	pop	r29
    1800:	08 95       	ret

00001802 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1802:	df 93       	push	r29
    1804:	cf 93       	push	r28
    1806:	00 d0       	rcall	.+0      	; 0x1808 <xQueueIsQueueFullFromISR+0x6>
    1808:	0f 92       	push	r0
    180a:	cd b7       	in	r28, 0x3d	; 61
    180c:	de b7       	in	r29, 0x3e	; 62
    180e:	9b 83       	std	Y+3, r25	; 0x03
    1810:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1812:	ea 81       	ldd	r30, Y+2	; 0x02
    1814:	fb 81       	ldd	r31, Y+3	; 0x03
    1816:	92 8d       	ldd	r25, Z+26	; 0x1a
    1818:	ea 81       	ldd	r30, Y+2	; 0x02
    181a:	fb 81       	ldd	r31, Y+3	; 0x03
    181c:	83 8d       	ldd	r24, Z+27	; 0x1b
    181e:	19 82       	std	Y+1, r1	; 0x01
    1820:	98 17       	cp	r25, r24
    1822:	11 f4       	brne	.+4      	; 0x1828 <xQueueIsQueueFullFromISR+0x26>
    1824:	81 e0       	ldi	r24, 0x01	; 1
    1826:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1828:	89 81       	ldd	r24, Y+1	; 0x01
}
    182a:	0f 90       	pop	r0
    182c:	0f 90       	pop	r0
    182e:	0f 90       	pop	r0
    1830:	cf 91       	pop	r28
    1832:	df 91       	pop	r29
    1834:	08 95       	ret

00001836 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1836:	af 92       	push	r10
    1838:	bf 92       	push	r11
    183a:	cf 92       	push	r12
    183c:	df 92       	push	r13
    183e:	ef 92       	push	r14
    1840:	ff 92       	push	r15
    1842:	0f 93       	push	r16
    1844:	1f 93       	push	r17
    1846:	df 93       	push	r29
    1848:	cf 93       	push	r28
    184a:	cd b7       	in	r28, 0x3d	; 61
    184c:	de b7       	in	r29, 0x3e	; 62
    184e:	64 97       	sbiw	r28, 0x14	; 20
    1850:	0f b6       	in	r0, 0x3f	; 63
    1852:	f8 94       	cli
    1854:	de bf       	out	0x3e, r29	; 62
    1856:	0f be       	out	0x3f, r0	; 63
    1858:	cd bf       	out	0x3d, r28	; 61
    185a:	9f 83       	std	Y+7, r25	; 0x07
    185c:	8e 83       	std	Y+6, r24	; 0x06
    185e:	79 87       	std	Y+9, r23	; 0x09
    1860:	68 87       	std	Y+8, r22	; 0x08
    1862:	5b 87       	std	Y+11, r21	; 0x0b
    1864:	4a 87       	std	Y+10, r20	; 0x0a
    1866:	3d 87       	std	Y+13, r19	; 0x0d
    1868:	2c 87       	std	Y+12, r18	; 0x0c
    186a:	0e 87       	std	Y+14, r16	; 0x0e
    186c:	f8 8a       	std	Y+16, r15	; 0x10
    186e:	ef 86       	std	Y+15, r14	; 0x0f
    1870:	da 8a       	std	Y+18, r13	; 0x12
    1872:	c9 8a       	std	Y+17, r12	; 0x11
    1874:	bc 8a       	std	Y+20, r11	; 0x14
    1876:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    1878:	8a 85       	ldd	r24, Y+10	; 0x0a
    187a:	9b 85       	ldd	r25, Y+11	; 0x0b
    187c:	29 89       	ldd	r18, Y+17	; 0x11
    187e:	3a 89       	ldd	r19, Y+18	; 0x12
    1880:	b9 01       	movw	r22, r18
    1882:	0e 94 a0 12 	call	0x2540	; 0x2540 <prvAllocateTCBAndStack>
    1886:	9c 83       	std	Y+4, r25	; 0x04
    1888:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    188a:	8b 81       	ldd	r24, Y+3	; 0x03
    188c:	9c 81       	ldd	r25, Y+4	; 0x04
    188e:	00 97       	sbiw	r24, 0x00	; 0
    1890:	09 f4       	brne	.+2      	; 0x1894 <xTaskGenericCreate+0x5e>
    1892:	99 c0       	rjmp	.+306    	; 0x19c6 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1894:	eb 81       	ldd	r30, Y+3	; 0x03
    1896:	fc 81       	ldd	r31, Y+4	; 0x04
    1898:	27 89       	ldd	r18, Z+23	; 0x17
    189a:	30 8d       	ldd	r19, Z+24	; 0x18
    189c:	8a 85       	ldd	r24, Y+10	; 0x0a
    189e:	9b 85       	ldd	r25, Y+11	; 0x0b
    18a0:	01 97       	sbiw	r24, 0x01	; 1
    18a2:	82 0f       	add	r24, r18
    18a4:	93 1f       	adc	r25, r19
    18a6:	9a 83       	std	Y+2, r25	; 0x02
    18a8:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    18aa:	8b 81       	ldd	r24, Y+3	; 0x03
    18ac:	9c 81       	ldd	r25, Y+4	; 0x04
    18ae:	28 85       	ldd	r18, Y+8	; 0x08
    18b0:	39 85       	ldd	r19, Y+9	; 0x09
    18b2:	eb 89       	ldd	r30, Y+19	; 0x13
    18b4:	fc 89       	ldd	r31, Y+20	; 0x14
    18b6:	aa 85       	ldd	r26, Y+10	; 0x0a
    18b8:	bb 85       	ldd	r27, Y+11	; 0x0b
    18ba:	b9 01       	movw	r22, r18
    18bc:	4e 85       	ldd	r20, Y+14	; 0x0e
    18be:	9f 01       	movw	r18, r30
    18c0:	8d 01       	movw	r16, r26
    18c2:	0e 94 85 11 	call	0x230a	; 0x230a <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    18c6:	89 81       	ldd	r24, Y+1	; 0x01
    18c8:	9a 81       	ldd	r25, Y+2	; 0x02
    18ca:	2e 81       	ldd	r18, Y+6	; 0x06
    18cc:	3f 81       	ldd	r19, Y+7	; 0x07
    18ce:	4c 85       	ldd	r20, Y+12	; 0x0c
    18d0:	5d 85       	ldd	r21, Y+13	; 0x0d
    18d2:	b9 01       	movw	r22, r18
    18d4:	0e 94 c8 04 	call	0x990	; 0x990 <pxPortInitialiseStack>
    18d8:	eb 81       	ldd	r30, Y+3	; 0x03
    18da:	fc 81       	ldd	r31, Y+4	; 0x04
    18dc:	91 83       	std	Z+1, r25	; 0x01
    18de:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    18e0:	8f 85       	ldd	r24, Y+15	; 0x0f
    18e2:	98 89       	ldd	r25, Y+16	; 0x10
    18e4:	00 97       	sbiw	r24, 0x00	; 0
    18e6:	31 f0       	breq	.+12     	; 0x18f4 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    18e8:	ef 85       	ldd	r30, Y+15	; 0x0f
    18ea:	f8 89       	ldd	r31, Y+16	; 0x10
    18ec:	8b 81       	ldd	r24, Y+3	; 0x03
    18ee:	9c 81       	ldd	r25, Y+4	; 0x04
    18f0:	91 83       	std	Z+1, r25	; 0x01
    18f2:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    18f4:	0f b6       	in	r0, 0x3f	; 63
    18f6:	f8 94       	cli
    18f8:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    18fa:	80 91 3f 03 	lds	r24, 0x033F
    18fe:	8f 5f       	subi	r24, 0xFF	; 255
    1900:	80 93 3f 03 	sts	0x033F, r24
			if( pxCurrentTCB == NULL )
    1904:	80 91 3c 03 	lds	r24, 0x033C
    1908:	90 91 3d 03 	lds	r25, 0x033D
    190c:	00 97       	sbiw	r24, 0x00	; 0
    190e:	69 f4       	brne	.+26     	; 0x192a <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1910:	8b 81       	ldd	r24, Y+3	; 0x03
    1912:	9c 81       	ldd	r25, Y+4	; 0x04
    1914:	90 93 3d 03 	sts	0x033D, r25
    1918:	80 93 3c 03 	sts	0x033C, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    191c:	80 91 3f 03 	lds	r24, 0x033F
    1920:	81 30       	cpi	r24, 0x01	; 1
    1922:	a9 f4       	brne	.+42     	; 0x194e <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    1924:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <prvInitialiseTaskLists>
    1928:	12 c0       	rjmp	.+36     	; 0x194e <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    192a:	80 91 44 03 	lds	r24, 0x0344
    192e:	88 23       	and	r24, r24
    1930:	71 f4       	brne	.+28     	; 0x194e <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1932:	e0 91 3c 03 	lds	r30, 0x033C
    1936:	f0 91 3d 03 	lds	r31, 0x033D
    193a:	96 89       	ldd	r25, Z+22	; 0x16
    193c:	8e 85       	ldd	r24, Y+14	; 0x0e
    193e:	89 17       	cp	r24, r25
    1940:	30 f0       	brcs	.+12     	; 0x194e <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    1942:	8b 81       	ldd	r24, Y+3	; 0x03
    1944:	9c 81       	ldd	r25, Y+4	; 0x04
    1946:	90 93 3d 03 	sts	0x033D, r25
    194a:	80 93 3c 03 	sts	0x033C, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    194e:	eb 81       	ldd	r30, Y+3	; 0x03
    1950:	fc 81       	ldd	r31, Y+4	; 0x04
    1952:	96 89       	ldd	r25, Z+22	; 0x16
    1954:	80 91 42 03 	lds	r24, 0x0342
    1958:	89 17       	cp	r24, r25
    195a:	28 f4       	brcc	.+10     	; 0x1966 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    195c:	eb 81       	ldd	r30, Y+3	; 0x03
    195e:	fc 81       	ldd	r31, Y+4	; 0x04
    1960:	86 89       	ldd	r24, Z+22	; 0x16
    1962:	80 93 42 03 	sts	0x0342, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1966:	80 91 49 03 	lds	r24, 0x0349
    196a:	8f 5f       	subi	r24, 0xFF	; 255
    196c:	80 93 49 03 	sts	0x0349, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1970:	eb 81       	ldd	r30, Y+3	; 0x03
    1972:	fc 81       	ldd	r31, Y+4	; 0x04
    1974:	96 89       	ldd	r25, Z+22	; 0x16
    1976:	80 91 43 03 	lds	r24, 0x0343
    197a:	89 17       	cp	r24, r25
    197c:	28 f4       	brcc	.+10     	; 0x1988 <xTaskGenericCreate+0x152>
    197e:	eb 81       	ldd	r30, Y+3	; 0x03
    1980:	fc 81       	ldd	r31, Y+4	; 0x04
    1982:	86 89       	ldd	r24, Z+22	; 0x16
    1984:	80 93 43 03 	sts	0x0343, r24
    1988:	eb 81       	ldd	r30, Y+3	; 0x03
    198a:	fc 81       	ldd	r31, Y+4	; 0x04
    198c:	86 89       	ldd	r24, Z+22	; 0x16
    198e:	28 2f       	mov	r18, r24
    1990:	30 e0       	ldi	r19, 0x00	; 0
    1992:	c9 01       	movw	r24, r18
    1994:	88 0f       	add	r24, r24
    1996:	99 1f       	adc	r25, r25
    1998:	88 0f       	add	r24, r24
    199a:	99 1f       	adc	r25, r25
    199c:	88 0f       	add	r24, r24
    199e:	99 1f       	adc	r25, r25
    19a0:	82 0f       	add	r24, r18
    19a2:	93 1f       	adc	r25, r19
    19a4:	ac 01       	movw	r20, r24
    19a6:	46 5b       	subi	r20, 0xB6	; 182
    19a8:	5c 4f       	sbci	r21, 0xFC	; 252
    19aa:	8b 81       	ldd	r24, Y+3	; 0x03
    19ac:	9c 81       	ldd	r25, Y+4	; 0x04
    19ae:	9c 01       	movw	r18, r24
    19b0:	2e 5f       	subi	r18, 0xFE	; 254
    19b2:	3f 4f       	sbci	r19, 0xFF	; 255
    19b4:	ca 01       	movw	r24, r20
    19b6:	b9 01       	movw	r22, r18
    19b8:	0e 94 c7 03 	call	0x78e	; 0x78e <vListInsertEnd>

			xReturn = pdPASS;
    19bc:	81 e0       	ldi	r24, 0x01	; 1
    19be:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    19c0:	0f 90       	pop	r0
    19c2:	0f be       	out	0x3f, r0	; 63
    19c4:	02 c0       	rjmp	.+4      	; 0x19ca <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    19c6:	8f ef       	ldi	r24, 0xFF	; 255
    19c8:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    19ca:	8d 81       	ldd	r24, Y+5	; 0x05
    19cc:	81 30       	cpi	r24, 0x01	; 1
    19ce:	71 f4       	brne	.+28     	; 0x19ec <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    19d0:	80 91 44 03 	lds	r24, 0x0344
    19d4:	88 23       	and	r24, r24
    19d6:	51 f0       	breq	.+20     	; 0x19ec <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    19d8:	e0 91 3c 03 	lds	r30, 0x033C
    19dc:	f0 91 3d 03 	lds	r31, 0x033D
    19e0:	96 89       	ldd	r25, Z+22	; 0x16
    19e2:	8e 85       	ldd	r24, Y+14	; 0x0e
    19e4:	98 17       	cp	r25, r24
    19e6:	10 f4       	brcc	.+4      	; 0x19ec <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    19e8:	0e 94 87 06 	call	0xd0e	; 0xd0e <vPortYield>
			}
		}
	}

	return xReturn;
    19ec:	8d 81       	ldd	r24, Y+5	; 0x05
}
    19ee:	64 96       	adiw	r28, 0x14	; 20
    19f0:	0f b6       	in	r0, 0x3f	; 63
    19f2:	f8 94       	cli
    19f4:	de bf       	out	0x3e, r29	; 62
    19f6:	0f be       	out	0x3f, r0	; 63
    19f8:	cd bf       	out	0x3d, r28	; 61
    19fa:	cf 91       	pop	r28
    19fc:	df 91       	pop	r29
    19fe:	1f 91       	pop	r17
    1a00:	0f 91       	pop	r16
    1a02:	ff 90       	pop	r15
    1a04:	ef 90       	pop	r14
    1a06:	df 90       	pop	r13
    1a08:	cf 90       	pop	r12
    1a0a:	bf 90       	pop	r11
    1a0c:	af 90       	pop	r10
    1a0e:	08 95       	ret

00001a10 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1a10:	df 93       	push	r29
    1a12:	cf 93       	push	r28
    1a14:	00 d0       	rcall	.+0      	; 0x1a16 <vTaskDelete+0x6>
    1a16:	00 d0       	rcall	.+0      	; 0x1a18 <vTaskDelete+0x8>
    1a18:	00 d0       	rcall	.+0      	; 0x1a1a <vTaskDelete+0xa>
    1a1a:	cd b7       	in	r28, 0x3d	; 61
    1a1c:	de b7       	in	r29, 0x3e	; 62
    1a1e:	9c 83       	std	Y+4, r25	; 0x04
    1a20:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1a22:	0f b6       	in	r0, 0x3f	; 63
    1a24:	f8 94       	cli
    1a26:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1a28:	20 91 3c 03 	lds	r18, 0x033C
    1a2c:	30 91 3d 03 	lds	r19, 0x033D
    1a30:	8b 81       	ldd	r24, Y+3	; 0x03
    1a32:	9c 81       	ldd	r25, Y+4	; 0x04
    1a34:	82 17       	cp	r24, r18
    1a36:	93 07       	cpc	r25, r19
    1a38:	11 f4       	brne	.+4      	; 0x1a3e <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    1a3a:	1c 82       	std	Y+4, r1	; 0x04
    1a3c:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1a3e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a40:	9c 81       	ldd	r25, Y+4	; 0x04
    1a42:	00 97       	sbiw	r24, 0x00	; 0
    1a44:	39 f4       	brne	.+14     	; 0x1a54 <vTaskDelete+0x44>
    1a46:	80 91 3c 03 	lds	r24, 0x033C
    1a4a:	90 91 3d 03 	lds	r25, 0x033D
    1a4e:	9e 83       	std	Y+6, r25	; 0x06
    1a50:	8d 83       	std	Y+5, r24	; 0x05
    1a52:	04 c0       	rjmp	.+8      	; 0x1a5c <vTaskDelete+0x4c>
    1a54:	8b 81       	ldd	r24, Y+3	; 0x03
    1a56:	9c 81       	ldd	r25, Y+4	; 0x04
    1a58:	9e 83       	std	Y+6, r25	; 0x06
    1a5a:	8d 83       	std	Y+5, r24	; 0x05
    1a5c:	8d 81       	ldd	r24, Y+5	; 0x05
    1a5e:	9e 81       	ldd	r25, Y+6	; 0x06
    1a60:	9a 83       	std	Y+2, r25	; 0x02
    1a62:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1a64:	89 81       	ldd	r24, Y+1	; 0x01
    1a66:	9a 81       	ldd	r25, Y+2	; 0x02
    1a68:	02 96       	adiw	r24, 0x02	; 2
    1a6a:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1a6e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a70:	fa 81       	ldd	r31, Y+2	; 0x02
    1a72:	84 89       	ldd	r24, Z+20	; 0x14
    1a74:	95 89       	ldd	r25, Z+21	; 0x15
    1a76:	00 97       	sbiw	r24, 0x00	; 0
    1a78:	29 f0       	breq	.+10     	; 0x1a84 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1a7a:	89 81       	ldd	r24, Y+1	; 0x01
    1a7c:	9a 81       	ldd	r25, Y+2	; 0x02
    1a7e:	0c 96       	adiw	r24, 0x0c	; 12
    1a80:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1a84:	89 81       	ldd	r24, Y+1	; 0x01
    1a86:	9a 81       	ldd	r25, Y+2	; 0x02
    1a88:	9c 01       	movw	r18, r24
    1a8a:	2e 5f       	subi	r18, 0xFE	; 254
    1a8c:	3f 4f       	sbci	r19, 0xFF	; 255
    1a8e:	86 e9       	ldi	r24, 0x96	; 150
    1a90:	93 e0       	ldi	r25, 0x03	; 3
    1a92:	b9 01       	movw	r22, r18
    1a94:	0e 94 c7 03 	call	0x78e	; 0x78e <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1a98:	80 91 3e 03 	lds	r24, 0x033E
    1a9c:	8f 5f       	subi	r24, 0xFF	; 255
    1a9e:	80 93 3e 03 	sts	0x033E, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1aa2:	80 91 49 03 	lds	r24, 0x0349
    1aa6:	8f 5f       	subi	r24, 0xFF	; 255
    1aa8:	80 93 49 03 	sts	0x0349, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1aac:	0f 90       	pop	r0
    1aae:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1ab0:	80 91 44 03 	lds	r24, 0x0344
    1ab4:	88 23       	and	r24, r24
    1ab6:	31 f0       	breq	.+12     	; 0x1ac4 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1ab8:	8b 81       	ldd	r24, Y+3	; 0x03
    1aba:	9c 81       	ldd	r25, Y+4	; 0x04
    1abc:	00 97       	sbiw	r24, 0x00	; 0
    1abe:	11 f4       	brne	.+4      	; 0x1ac4 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    1ac0:	0e 94 87 06 	call	0xd0e	; 0xd0e <vPortYield>
			}
		}
	}
    1ac4:	26 96       	adiw	r28, 0x06	; 6
    1ac6:	0f b6       	in	r0, 0x3f	; 63
    1ac8:	f8 94       	cli
    1aca:	de bf       	out	0x3e, r29	; 62
    1acc:	0f be       	out	0x3f, r0	; 63
    1ace:	cd bf       	out	0x3d, r28	; 61
    1ad0:	cf 91       	pop	r28
    1ad2:	df 91       	pop	r29
    1ad4:	08 95       	ret

00001ad6 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1ad6:	df 93       	push	r29
    1ad8:	cf 93       	push	r28
    1ada:	cd b7       	in	r28, 0x3d	; 61
    1adc:	de b7       	in	r29, 0x3e	; 62
    1ade:	28 97       	sbiw	r28, 0x08	; 8
    1ae0:	0f b6       	in	r0, 0x3f	; 63
    1ae2:	f8 94       	cli
    1ae4:	de bf       	out	0x3e, r29	; 62
    1ae6:	0f be       	out	0x3f, r0	; 63
    1ae8:	cd bf       	out	0x3d, r28	; 61
    1aea:	9e 83       	std	Y+6, r25	; 0x06
    1aec:	8d 83       	std	Y+5, r24	; 0x05
    1aee:	78 87       	std	Y+8, r23	; 0x08
    1af0:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    1af2:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1af4:	0e 94 57 0e 	call	0x1cae	; 0x1cae <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1af8:	ed 81       	ldd	r30, Y+5	; 0x05
    1afa:	fe 81       	ldd	r31, Y+6	; 0x06
    1afc:	20 81       	ld	r18, Z
    1afe:	31 81       	ldd	r19, Z+1	; 0x01
    1b00:	8f 81       	ldd	r24, Y+7	; 0x07
    1b02:	98 85       	ldd	r25, Y+8	; 0x08
    1b04:	82 0f       	add	r24, r18
    1b06:	93 1f       	adc	r25, r19
    1b08:	9c 83       	std	Y+4, r25	; 0x04
    1b0a:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    1b0c:	ed 81       	ldd	r30, Y+5	; 0x05
    1b0e:	fe 81       	ldd	r31, Y+6	; 0x06
    1b10:	20 81       	ld	r18, Z
    1b12:	31 81       	ldd	r19, Z+1	; 0x01
    1b14:	80 91 40 03 	lds	r24, 0x0340
    1b18:	90 91 41 03 	lds	r25, 0x0341
    1b1c:	82 17       	cp	r24, r18
    1b1e:	93 07       	cpc	r25, r19
    1b20:	a8 f4       	brcc	.+42     	; 0x1b4c <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1b22:	ed 81       	ldd	r30, Y+5	; 0x05
    1b24:	fe 81       	ldd	r31, Y+6	; 0x06
    1b26:	20 81       	ld	r18, Z
    1b28:	31 81       	ldd	r19, Z+1	; 0x01
    1b2a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b2c:	9c 81       	ldd	r25, Y+4	; 0x04
    1b2e:	82 17       	cp	r24, r18
    1b30:	93 07       	cpc	r25, r19
    1b32:	00 f5       	brcc	.+64     	; 0x1b74 <vTaskDelayUntil+0x9e>
    1b34:	20 91 40 03 	lds	r18, 0x0340
    1b38:	30 91 41 03 	lds	r19, 0x0341
    1b3c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b3e:	9c 81       	ldd	r25, Y+4	; 0x04
    1b40:	28 17       	cp	r18, r24
    1b42:	39 07       	cpc	r19, r25
    1b44:	b8 f4       	brcc	.+46     	; 0x1b74 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1b46:	81 e0       	ldi	r24, 0x01	; 1
    1b48:	89 83       	std	Y+1, r24	; 0x01
    1b4a:	14 c0       	rjmp	.+40     	; 0x1b74 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1b4c:	ed 81       	ldd	r30, Y+5	; 0x05
    1b4e:	fe 81       	ldd	r31, Y+6	; 0x06
    1b50:	20 81       	ld	r18, Z
    1b52:	31 81       	ldd	r19, Z+1	; 0x01
    1b54:	8b 81       	ldd	r24, Y+3	; 0x03
    1b56:	9c 81       	ldd	r25, Y+4	; 0x04
    1b58:	82 17       	cp	r24, r18
    1b5a:	93 07       	cpc	r25, r19
    1b5c:	48 f0       	brcs	.+18     	; 0x1b70 <vTaskDelayUntil+0x9a>
    1b5e:	20 91 40 03 	lds	r18, 0x0340
    1b62:	30 91 41 03 	lds	r19, 0x0341
    1b66:	8b 81       	ldd	r24, Y+3	; 0x03
    1b68:	9c 81       	ldd	r25, Y+4	; 0x04
    1b6a:	28 17       	cp	r18, r24
    1b6c:	39 07       	cpc	r19, r25
    1b6e:	10 f4       	brcc	.+4      	; 0x1b74 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1b70:	81 e0       	ldi	r24, 0x01	; 1
    1b72:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1b74:	ed 81       	ldd	r30, Y+5	; 0x05
    1b76:	fe 81       	ldd	r31, Y+6	; 0x06
    1b78:	8b 81       	ldd	r24, Y+3	; 0x03
    1b7a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b7c:	91 83       	std	Z+1, r25	; 0x01
    1b7e:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1b80:	89 81       	ldd	r24, Y+1	; 0x01
    1b82:	88 23       	and	r24, r24
    1b84:	59 f0       	breq	.+22     	; 0x1b9c <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1b86:	80 91 3c 03 	lds	r24, 0x033C
    1b8a:	90 91 3d 03 	lds	r25, 0x033D
    1b8e:	02 96       	adiw	r24, 0x02	; 2
    1b90:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1b94:	8b 81       	ldd	r24, Y+3	; 0x03
    1b96:	9c 81       	ldd	r25, Y+4	; 0x04
    1b98:	0e 94 57 12 	call	0x24ae	; 0x24ae <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1b9c:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <xTaskResumeAll>
    1ba0:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1ba2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ba4:	88 23       	and	r24, r24
    1ba6:	11 f4       	brne	.+4      	; 0x1bac <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    1ba8:	0e 94 87 06 	call	0xd0e	; 0xd0e <vPortYield>
		}
	}
    1bac:	28 96       	adiw	r28, 0x08	; 8
    1bae:	0f b6       	in	r0, 0x3f	; 63
    1bb0:	f8 94       	cli
    1bb2:	de bf       	out	0x3e, r29	; 62
    1bb4:	0f be       	out	0x3f, r0	; 63
    1bb6:	cd bf       	out	0x3d, r28	; 61
    1bb8:	cf 91       	pop	r28
    1bba:	df 91       	pop	r29
    1bbc:	08 95       	ret

00001bbe <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1bbe:	df 93       	push	r29
    1bc0:	cf 93       	push	r28
    1bc2:	00 d0       	rcall	.+0      	; 0x1bc4 <vTaskDelay+0x6>
    1bc4:	00 d0       	rcall	.+0      	; 0x1bc6 <vTaskDelay+0x8>
    1bc6:	0f 92       	push	r0
    1bc8:	cd b7       	in	r28, 0x3d	; 61
    1bca:	de b7       	in	r29, 0x3e	; 62
    1bcc:	9d 83       	std	Y+5, r25	; 0x05
    1bce:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1bd0:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1bd2:	8c 81       	ldd	r24, Y+4	; 0x04
    1bd4:	9d 81       	ldd	r25, Y+5	; 0x05
    1bd6:	00 97       	sbiw	r24, 0x00	; 0
    1bd8:	d1 f0       	breq	.+52     	; 0x1c0e <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    1bda:	0e 94 57 0e 	call	0x1cae	; 0x1cae <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1bde:	20 91 40 03 	lds	r18, 0x0340
    1be2:	30 91 41 03 	lds	r19, 0x0341
    1be6:	8c 81       	ldd	r24, Y+4	; 0x04
    1be8:	9d 81       	ldd	r25, Y+5	; 0x05
    1bea:	82 0f       	add	r24, r18
    1bec:	93 1f       	adc	r25, r19
    1bee:	9b 83       	std	Y+3, r25	; 0x03
    1bf0:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1bf2:	80 91 3c 03 	lds	r24, 0x033C
    1bf6:	90 91 3d 03 	lds	r25, 0x033D
    1bfa:	02 96       	adiw	r24, 0x02	; 2
    1bfc:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1c00:	8a 81       	ldd	r24, Y+2	; 0x02
    1c02:	9b 81       	ldd	r25, Y+3	; 0x03
    1c04:	0e 94 57 12 	call	0x24ae	; 0x24ae <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1c08:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <xTaskResumeAll>
    1c0c:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1c0e:	89 81       	ldd	r24, Y+1	; 0x01
    1c10:	88 23       	and	r24, r24
    1c12:	11 f4       	brne	.+4      	; 0x1c18 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    1c14:	0e 94 87 06 	call	0xd0e	; 0xd0e <vPortYield>
		}
	}
    1c18:	0f 90       	pop	r0
    1c1a:	0f 90       	pop	r0
    1c1c:	0f 90       	pop	r0
    1c1e:	0f 90       	pop	r0
    1c20:	0f 90       	pop	r0
    1c22:	cf 91       	pop	r28
    1c24:	df 91       	pop	r29
    1c26:	08 95       	ret

00001c28 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1c28:	af 92       	push	r10
    1c2a:	bf 92       	push	r11
    1c2c:	cf 92       	push	r12
    1c2e:	df 92       	push	r13
    1c30:	ef 92       	push	r14
    1c32:	ff 92       	push	r15
    1c34:	0f 93       	push	r16
    1c36:	df 93       	push	r29
    1c38:	cf 93       	push	r28
    1c3a:	0f 92       	push	r0
    1c3c:	cd b7       	in	r28, 0x3d	; 61
    1c3e:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1c40:	20 e6       	ldi	r18, 0x60	; 96
    1c42:	30 e0       	ldi	r19, 0x00	; 0
    1c44:	8b e7       	ldi	r24, 0x7B	; 123
    1c46:	91 e1       	ldi	r25, 0x11	; 17
    1c48:	b9 01       	movw	r22, r18
    1c4a:	45 e5       	ldi	r20, 0x55	; 85
    1c4c:	50 e0       	ldi	r21, 0x00	; 0
    1c4e:	20 e0       	ldi	r18, 0x00	; 0
    1c50:	30 e0       	ldi	r19, 0x00	; 0
    1c52:	00 e0       	ldi	r16, 0x00	; 0
    1c54:	ee 24       	eor	r14, r14
    1c56:	ff 24       	eor	r15, r15
    1c58:	cc 24       	eor	r12, r12
    1c5a:	dd 24       	eor	r13, r13
    1c5c:	aa 24       	eor	r10, r10
    1c5e:	bb 24       	eor	r11, r11
    1c60:	0e 94 1b 0c 	call	0x1836	; 0x1836 <xTaskGenericCreate>
    1c64:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1c66:	89 81       	ldd	r24, Y+1	; 0x01
    1c68:	81 30       	cpi	r24, 0x01	; 1
    1c6a:	51 f4       	brne	.+20     	; 0x1c80 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1c6c:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1c6e:	81 e0       	ldi	r24, 0x01	; 1
    1c70:	80 93 44 03 	sts	0x0344, r24
		xTickCount = ( portTickType ) 0U;
    1c74:	10 92 41 03 	sts	0x0341, r1
    1c78:	10 92 40 03 	sts	0x0340, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1c7c:	0e 94 4b 06 	call	0xc96	; 0xc96 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1c80:	0f 90       	pop	r0
    1c82:	cf 91       	pop	r28
    1c84:	df 91       	pop	r29
    1c86:	0f 91       	pop	r16
    1c88:	ff 90       	pop	r15
    1c8a:	ef 90       	pop	r14
    1c8c:	df 90       	pop	r13
    1c8e:	cf 90       	pop	r12
    1c90:	bf 90       	pop	r11
    1c92:	af 90       	pop	r10
    1c94:	08 95       	ret

00001c96 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    1c96:	df 93       	push	r29
    1c98:	cf 93       	push	r28
    1c9a:	cd b7       	in	r28, 0x3d	; 61
    1c9c:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1c9e:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1ca0:	10 92 44 03 	sts	0x0344, r1
	vPortEndScheduler();
    1ca4:	0e 94 80 06 	call	0xd00	; 0xd00 <vPortEndScheduler>
}
    1ca8:	cf 91       	pop	r28
    1caa:	df 91       	pop	r29
    1cac:	08 95       	ret

00001cae <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    1cae:	df 93       	push	r29
    1cb0:	cf 93       	push	r28
    1cb2:	cd b7       	in	r28, 0x3d	; 61
    1cb4:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1cb6:	80 91 45 03 	lds	r24, 0x0345
    1cba:	8f 5f       	subi	r24, 0xFF	; 255
    1cbc:	80 93 45 03 	sts	0x0345, r24
}
    1cc0:	cf 91       	pop	r28
    1cc2:	df 91       	pop	r29
    1cc4:	08 95       	ret

00001cc6 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1cc6:	df 93       	push	r29
    1cc8:	cf 93       	push	r28
    1cca:	00 d0       	rcall	.+0      	; 0x1ccc <xTaskResumeAll+0x6>
    1ccc:	00 d0       	rcall	.+0      	; 0x1cce <xTaskResumeAll+0x8>
    1cce:	cd b7       	in	r28, 0x3d	; 61
    1cd0:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1cd2:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1cd4:	0f b6       	in	r0, 0x3f	; 63
    1cd6:	f8 94       	cli
    1cd8:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1cda:	80 91 45 03 	lds	r24, 0x0345
    1cde:	81 50       	subi	r24, 0x01	; 1
    1ce0:	80 93 45 03 	sts	0x0345, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1ce4:	80 91 45 03 	lds	r24, 0x0345
    1ce8:	88 23       	and	r24, r24
    1cea:	09 f0       	breq	.+2      	; 0x1cee <xTaskResumeAll+0x28>
    1cec:	6c c0       	rjmp	.+216    	; 0x1dc6 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1cee:	80 91 3f 03 	lds	r24, 0x033F
    1cf2:	88 23       	and	r24, r24
    1cf4:	09 f4       	brne	.+2      	; 0x1cf8 <xTaskResumeAll+0x32>
    1cf6:	67 c0       	rjmp	.+206    	; 0x1dc6 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    1cf8:	19 82       	std	Y+1, r1	; 0x01
    1cfa:	41 c0       	rjmp	.+130    	; 0x1d7e <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1cfc:	e0 91 92 03 	lds	r30, 0x0392
    1d00:	f0 91 93 03 	lds	r31, 0x0393
    1d04:	86 81       	ldd	r24, Z+6	; 0x06
    1d06:	97 81       	ldd	r25, Z+7	; 0x07
    1d08:	9c 83       	std	Y+4, r25	; 0x04
    1d0a:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    1d0c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d0e:	9c 81       	ldd	r25, Y+4	; 0x04
    1d10:	0c 96       	adiw	r24, 0x0c	; 12
    1d12:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1d16:	8b 81       	ldd	r24, Y+3	; 0x03
    1d18:	9c 81       	ldd	r25, Y+4	; 0x04
    1d1a:	02 96       	adiw	r24, 0x02	; 2
    1d1c:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1d20:	eb 81       	ldd	r30, Y+3	; 0x03
    1d22:	fc 81       	ldd	r31, Y+4	; 0x04
    1d24:	96 89       	ldd	r25, Z+22	; 0x16
    1d26:	80 91 43 03 	lds	r24, 0x0343
    1d2a:	89 17       	cp	r24, r25
    1d2c:	28 f4       	brcc	.+10     	; 0x1d38 <xTaskResumeAll+0x72>
    1d2e:	eb 81       	ldd	r30, Y+3	; 0x03
    1d30:	fc 81       	ldd	r31, Y+4	; 0x04
    1d32:	86 89       	ldd	r24, Z+22	; 0x16
    1d34:	80 93 43 03 	sts	0x0343, r24
    1d38:	eb 81       	ldd	r30, Y+3	; 0x03
    1d3a:	fc 81       	ldd	r31, Y+4	; 0x04
    1d3c:	86 89       	ldd	r24, Z+22	; 0x16
    1d3e:	28 2f       	mov	r18, r24
    1d40:	30 e0       	ldi	r19, 0x00	; 0
    1d42:	c9 01       	movw	r24, r18
    1d44:	88 0f       	add	r24, r24
    1d46:	99 1f       	adc	r25, r25
    1d48:	88 0f       	add	r24, r24
    1d4a:	99 1f       	adc	r25, r25
    1d4c:	88 0f       	add	r24, r24
    1d4e:	99 1f       	adc	r25, r25
    1d50:	82 0f       	add	r24, r18
    1d52:	93 1f       	adc	r25, r19
    1d54:	86 5b       	subi	r24, 0xB6	; 182
    1d56:	9c 4f       	sbci	r25, 0xFC	; 252
    1d58:	2b 81       	ldd	r18, Y+3	; 0x03
    1d5a:	3c 81       	ldd	r19, Y+4	; 0x04
    1d5c:	2e 5f       	subi	r18, 0xFE	; 254
    1d5e:	3f 4f       	sbci	r19, 0xFF	; 255
    1d60:	b9 01       	movw	r22, r18
    1d62:	0e 94 c7 03 	call	0x78e	; 0x78e <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1d66:	eb 81       	ldd	r30, Y+3	; 0x03
    1d68:	fc 81       	ldd	r31, Y+4	; 0x04
    1d6a:	96 89       	ldd	r25, Z+22	; 0x16
    1d6c:	e0 91 3c 03 	lds	r30, 0x033C
    1d70:	f0 91 3d 03 	lds	r31, 0x033D
    1d74:	86 89       	ldd	r24, Z+22	; 0x16
    1d76:	98 17       	cp	r25, r24
    1d78:	10 f0       	brcs	.+4      	; 0x1d7e <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    1d7a:	81 e0       	ldi	r24, 0x01	; 1
    1d7c:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1d7e:	80 91 8d 03 	lds	r24, 0x038D
    1d82:	88 23       	and	r24, r24
    1d84:	09 f0       	breq	.+2      	; 0x1d88 <xTaskResumeAll+0xc2>
    1d86:	ba cf       	rjmp	.-140    	; 0x1cfc <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1d88:	80 91 46 03 	lds	r24, 0x0346
    1d8c:	88 23       	and	r24, r24
    1d8e:	71 f0       	breq	.+28     	; 0x1dac <xTaskResumeAll+0xe6>
    1d90:	07 c0       	rjmp	.+14     	; 0x1da0 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    1d92:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <vTaskIncrementTick>
						--uxMissedTicks;
    1d96:	80 91 46 03 	lds	r24, 0x0346
    1d9a:	81 50       	subi	r24, 0x01	; 1
    1d9c:	80 93 46 03 	sts	0x0346, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1da0:	80 91 46 03 	lds	r24, 0x0346
    1da4:	88 23       	and	r24, r24
    1da6:	a9 f7       	brne	.-22     	; 0x1d92 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    1da8:	81 e0       	ldi	r24, 0x01	; 1
    1daa:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1dac:	89 81       	ldd	r24, Y+1	; 0x01
    1dae:	81 30       	cpi	r24, 0x01	; 1
    1db0:	21 f0       	breq	.+8      	; 0x1dba <xTaskResumeAll+0xf4>
    1db2:	80 91 47 03 	lds	r24, 0x0347
    1db6:	81 30       	cpi	r24, 0x01	; 1
    1db8:	31 f4       	brne	.+12     	; 0x1dc6 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    1dba:	81 e0       	ldi	r24, 0x01	; 1
    1dbc:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    1dbe:	10 92 47 03 	sts	0x0347, r1
					portYIELD_WITHIN_API();
    1dc2:	0e 94 87 06 	call	0xd0e	; 0xd0e <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1dc6:	0f 90       	pop	r0
    1dc8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    1dca:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1dcc:	0f 90       	pop	r0
    1dce:	0f 90       	pop	r0
    1dd0:	0f 90       	pop	r0
    1dd2:	0f 90       	pop	r0
    1dd4:	cf 91       	pop	r28
    1dd6:	df 91       	pop	r29
    1dd8:	08 95       	ret

00001dda <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    1dda:	df 93       	push	r29
    1ddc:	cf 93       	push	r28
    1dde:	00 d0       	rcall	.+0      	; 0x1de0 <xTaskGetTickCount+0x6>
    1de0:	cd b7       	in	r28, 0x3d	; 61
    1de2:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1de4:	0f b6       	in	r0, 0x3f	; 63
    1de6:	f8 94       	cli
    1de8:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1dea:	80 91 40 03 	lds	r24, 0x0340
    1dee:	90 91 41 03 	lds	r25, 0x0341
    1df2:	9a 83       	std	Y+2, r25	; 0x02
    1df4:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    1df6:	0f 90       	pop	r0
    1df8:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    1dfa:	89 81       	ldd	r24, Y+1	; 0x01
    1dfc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1dfe:	0f 90       	pop	r0
    1e00:	0f 90       	pop	r0
    1e02:	cf 91       	pop	r28
    1e04:	df 91       	pop	r29
    1e06:	08 95       	ret

00001e08 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    1e08:	df 93       	push	r29
    1e0a:	cf 93       	push	r28
    1e0c:	00 d0       	rcall	.+0      	; 0x1e0e <xTaskGetTickCountFromISR+0x6>
    1e0e:	0f 92       	push	r0
    1e10:	cd b7       	in	r28, 0x3d	; 61
    1e12:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1e14:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    1e16:	80 91 40 03 	lds	r24, 0x0340
    1e1a:	90 91 41 03 	lds	r25, 0x0341
    1e1e:	9b 83       	std	Y+3, r25	; 0x03
    1e20:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1e22:	8a 81       	ldd	r24, Y+2	; 0x02
    1e24:	9b 81       	ldd	r25, Y+3	; 0x03
}
    1e26:	0f 90       	pop	r0
    1e28:	0f 90       	pop	r0
    1e2a:	0f 90       	pop	r0
    1e2c:	cf 91       	pop	r28
    1e2e:	df 91       	pop	r29
    1e30:	08 95       	ret

00001e32 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    1e32:	df 93       	push	r29
    1e34:	cf 93       	push	r28
    1e36:	cd b7       	in	r28, 0x3d	; 61
    1e38:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1e3a:	80 91 3f 03 	lds	r24, 0x033F
}
    1e3e:	cf 91       	pop	r28
    1e40:	df 91       	pop	r29
    1e42:	08 95       	ret

00001e44 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1e44:	df 93       	push	r29
    1e46:	cf 93       	push	r28
    1e48:	00 d0       	rcall	.+0      	; 0x1e4a <vTaskIncrementTick+0x6>
    1e4a:	00 d0       	rcall	.+0      	; 0x1e4c <vTaskIncrementTick+0x8>
    1e4c:	00 d0       	rcall	.+0      	; 0x1e4e <vTaskIncrementTick+0xa>
    1e4e:	cd b7       	in	r28, 0x3d	; 61
    1e50:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1e52:	80 91 45 03 	lds	r24, 0x0345
    1e56:	88 23       	and	r24, r24
    1e58:	09 f0       	breq	.+2      	; 0x1e5c <vTaskIncrementTick+0x18>
    1e5a:	bb c0       	rjmp	.+374    	; 0x1fd2 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    1e5c:	80 91 40 03 	lds	r24, 0x0340
    1e60:	90 91 41 03 	lds	r25, 0x0341
    1e64:	01 96       	adiw	r24, 0x01	; 1
    1e66:	90 93 41 03 	sts	0x0341, r25
    1e6a:	80 93 40 03 	sts	0x0340, r24
		if( xTickCount == ( portTickType ) 0U )
    1e6e:	80 91 40 03 	lds	r24, 0x0340
    1e72:	90 91 41 03 	lds	r25, 0x0341
    1e76:	00 97       	sbiw	r24, 0x00	; 0
    1e78:	d1 f5       	brne	.+116    	; 0x1eee <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1e7a:	80 91 89 03 	lds	r24, 0x0389
    1e7e:	90 91 8a 03 	lds	r25, 0x038A
    1e82:	9c 83       	std	Y+4, r25	; 0x04
    1e84:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1e86:	80 91 8b 03 	lds	r24, 0x038B
    1e8a:	90 91 8c 03 	lds	r25, 0x038C
    1e8e:	90 93 8a 03 	sts	0x038A, r25
    1e92:	80 93 89 03 	sts	0x0389, r24
			pxOverflowDelayedTaskList = pxTemp;
    1e96:	8b 81       	ldd	r24, Y+3	; 0x03
    1e98:	9c 81       	ldd	r25, Y+4	; 0x04
    1e9a:	90 93 8c 03 	sts	0x038C, r25
    1e9e:	80 93 8b 03 	sts	0x038B, r24
			xNumOfOverflows++;
    1ea2:	80 91 48 03 	lds	r24, 0x0348
    1ea6:	8f 5f       	subi	r24, 0xFF	; 255
    1ea8:	80 93 48 03 	sts	0x0348, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1eac:	e0 91 89 03 	lds	r30, 0x0389
    1eb0:	f0 91 8a 03 	lds	r31, 0x038A
    1eb4:	80 81       	ld	r24, Z
    1eb6:	88 23       	and	r24, r24
    1eb8:	39 f4       	brne	.+14     	; 0x1ec8 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1eba:	8f ef       	ldi	r24, 0xFF	; 255
    1ebc:	9f ef       	ldi	r25, 0xFF	; 255
    1ebe:	90 93 66 00 	sts	0x0066, r25
    1ec2:	80 93 65 00 	sts	0x0065, r24
    1ec6:	13 c0       	rjmp	.+38     	; 0x1eee <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1ec8:	e0 91 89 03 	lds	r30, 0x0389
    1ecc:	f0 91 8a 03 	lds	r31, 0x038A
    1ed0:	05 80       	ldd	r0, Z+5	; 0x05
    1ed2:	f6 81       	ldd	r31, Z+6	; 0x06
    1ed4:	e0 2d       	mov	r30, r0
    1ed6:	86 81       	ldd	r24, Z+6	; 0x06
    1ed8:	97 81       	ldd	r25, Z+7	; 0x07
    1eda:	9e 83       	std	Y+6, r25	; 0x06
    1edc:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1ede:	ed 81       	ldd	r30, Y+5	; 0x05
    1ee0:	fe 81       	ldd	r31, Y+6	; 0x06
    1ee2:	82 81       	ldd	r24, Z+2	; 0x02
    1ee4:	93 81       	ldd	r25, Z+3	; 0x03
    1ee6:	90 93 66 00 	sts	0x0066, r25
    1eea:	80 93 65 00 	sts	0x0065, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1eee:	20 91 40 03 	lds	r18, 0x0340
    1ef2:	30 91 41 03 	lds	r19, 0x0341
    1ef6:	80 91 65 00 	lds	r24, 0x0065
    1efa:	90 91 66 00 	lds	r25, 0x0066
    1efe:	28 17       	cp	r18, r24
    1f00:	39 07       	cpc	r19, r25
    1f02:	08 f4       	brcc	.+2      	; 0x1f06 <vTaskIncrementTick+0xc2>
    1f04:	6b c0       	rjmp	.+214    	; 0x1fdc <vTaskIncrementTick+0x198>
    1f06:	e0 91 89 03 	lds	r30, 0x0389
    1f0a:	f0 91 8a 03 	lds	r31, 0x038A
    1f0e:	80 81       	ld	r24, Z
    1f10:	88 23       	and	r24, r24
    1f12:	39 f4       	brne	.+14     	; 0x1f22 <vTaskIncrementTick+0xde>
    1f14:	8f ef       	ldi	r24, 0xFF	; 255
    1f16:	9f ef       	ldi	r25, 0xFF	; 255
    1f18:	90 93 66 00 	sts	0x0066, r25
    1f1c:	80 93 65 00 	sts	0x0065, r24
    1f20:	5d c0       	rjmp	.+186    	; 0x1fdc <vTaskIncrementTick+0x198>
    1f22:	e0 91 89 03 	lds	r30, 0x0389
    1f26:	f0 91 8a 03 	lds	r31, 0x038A
    1f2a:	05 80       	ldd	r0, Z+5	; 0x05
    1f2c:	f6 81       	ldd	r31, Z+6	; 0x06
    1f2e:	e0 2d       	mov	r30, r0
    1f30:	86 81       	ldd	r24, Z+6	; 0x06
    1f32:	97 81       	ldd	r25, Z+7	; 0x07
    1f34:	9e 83       	std	Y+6, r25	; 0x06
    1f36:	8d 83       	std	Y+5, r24	; 0x05
    1f38:	ed 81       	ldd	r30, Y+5	; 0x05
    1f3a:	fe 81       	ldd	r31, Y+6	; 0x06
    1f3c:	82 81       	ldd	r24, Z+2	; 0x02
    1f3e:	93 81       	ldd	r25, Z+3	; 0x03
    1f40:	9a 83       	std	Y+2, r25	; 0x02
    1f42:	89 83       	std	Y+1, r24	; 0x01
    1f44:	20 91 40 03 	lds	r18, 0x0340
    1f48:	30 91 41 03 	lds	r19, 0x0341
    1f4c:	89 81       	ldd	r24, Y+1	; 0x01
    1f4e:	9a 81       	ldd	r25, Y+2	; 0x02
    1f50:	28 17       	cp	r18, r24
    1f52:	39 07       	cpc	r19, r25
    1f54:	38 f4       	brcc	.+14     	; 0x1f64 <vTaskIncrementTick+0x120>
    1f56:	89 81       	ldd	r24, Y+1	; 0x01
    1f58:	9a 81       	ldd	r25, Y+2	; 0x02
    1f5a:	90 93 66 00 	sts	0x0066, r25
    1f5e:	80 93 65 00 	sts	0x0065, r24
    1f62:	3c c0       	rjmp	.+120    	; 0x1fdc <vTaskIncrementTick+0x198>
    1f64:	8d 81       	ldd	r24, Y+5	; 0x05
    1f66:	9e 81       	ldd	r25, Y+6	; 0x06
    1f68:	02 96       	adiw	r24, 0x02	; 2
    1f6a:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListRemove>
    1f6e:	ed 81       	ldd	r30, Y+5	; 0x05
    1f70:	fe 81       	ldd	r31, Y+6	; 0x06
    1f72:	84 89       	ldd	r24, Z+20	; 0x14
    1f74:	95 89       	ldd	r25, Z+21	; 0x15
    1f76:	00 97       	sbiw	r24, 0x00	; 0
    1f78:	29 f0       	breq	.+10     	; 0x1f84 <vTaskIncrementTick+0x140>
    1f7a:	8d 81       	ldd	r24, Y+5	; 0x05
    1f7c:	9e 81       	ldd	r25, Y+6	; 0x06
    1f7e:	0c 96       	adiw	r24, 0x0c	; 12
    1f80:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListRemove>
    1f84:	ed 81       	ldd	r30, Y+5	; 0x05
    1f86:	fe 81       	ldd	r31, Y+6	; 0x06
    1f88:	96 89       	ldd	r25, Z+22	; 0x16
    1f8a:	80 91 43 03 	lds	r24, 0x0343
    1f8e:	89 17       	cp	r24, r25
    1f90:	28 f4       	brcc	.+10     	; 0x1f9c <vTaskIncrementTick+0x158>
    1f92:	ed 81       	ldd	r30, Y+5	; 0x05
    1f94:	fe 81       	ldd	r31, Y+6	; 0x06
    1f96:	86 89       	ldd	r24, Z+22	; 0x16
    1f98:	80 93 43 03 	sts	0x0343, r24
    1f9c:	ed 81       	ldd	r30, Y+5	; 0x05
    1f9e:	fe 81       	ldd	r31, Y+6	; 0x06
    1fa0:	86 89       	ldd	r24, Z+22	; 0x16
    1fa2:	28 2f       	mov	r18, r24
    1fa4:	30 e0       	ldi	r19, 0x00	; 0
    1fa6:	c9 01       	movw	r24, r18
    1fa8:	88 0f       	add	r24, r24
    1faa:	99 1f       	adc	r25, r25
    1fac:	88 0f       	add	r24, r24
    1fae:	99 1f       	adc	r25, r25
    1fb0:	88 0f       	add	r24, r24
    1fb2:	99 1f       	adc	r25, r25
    1fb4:	82 0f       	add	r24, r18
    1fb6:	93 1f       	adc	r25, r19
    1fb8:	ac 01       	movw	r20, r24
    1fba:	46 5b       	subi	r20, 0xB6	; 182
    1fbc:	5c 4f       	sbci	r21, 0xFC	; 252
    1fbe:	8d 81       	ldd	r24, Y+5	; 0x05
    1fc0:	9e 81       	ldd	r25, Y+6	; 0x06
    1fc2:	9c 01       	movw	r18, r24
    1fc4:	2e 5f       	subi	r18, 0xFE	; 254
    1fc6:	3f 4f       	sbci	r19, 0xFF	; 255
    1fc8:	ca 01       	movw	r24, r20
    1fca:	b9 01       	movw	r22, r18
    1fcc:	0e 94 c7 03 	call	0x78e	; 0x78e <vListInsertEnd>
    1fd0:	9a cf       	rjmp	.-204    	; 0x1f06 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    1fd2:	80 91 46 03 	lds	r24, 0x0346
    1fd6:	8f 5f       	subi	r24, 0xFF	; 255
    1fd8:	80 93 46 03 	sts	0x0346, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    1fdc:	26 96       	adiw	r28, 0x06	; 6
    1fde:	0f b6       	in	r0, 0x3f	; 63
    1fe0:	f8 94       	cli
    1fe2:	de bf       	out	0x3e, r29	; 62
    1fe4:	0f be       	out	0x3f, r0	; 63
    1fe6:	cd bf       	out	0x3d, r28	; 61
    1fe8:	cf 91       	pop	r28
    1fea:	df 91       	pop	r29
    1fec:	08 95       	ret

00001fee <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    1fee:	df 93       	push	r29
    1ff0:	cf 93       	push	r28
    1ff2:	00 d0       	rcall	.+0      	; 0x1ff4 <vTaskSwitchContext+0x6>
    1ff4:	cd b7       	in	r28, 0x3d	; 61
    1ff6:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1ff8:	80 91 45 03 	lds	r24, 0x0345
    1ffc:	88 23       	and	r24, r24
    1ffe:	49 f0       	breq	.+18     	; 0x2012 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2000:	81 e0       	ldi	r24, 0x01	; 1
    2002:	80 93 47 03 	sts	0x0347, r24
    2006:	54 c0       	rjmp	.+168    	; 0x20b0 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2008:	80 91 43 03 	lds	r24, 0x0343
    200c:	81 50       	subi	r24, 0x01	; 1
    200e:	80 93 43 03 	sts	0x0343, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2012:	80 91 43 03 	lds	r24, 0x0343
    2016:	28 2f       	mov	r18, r24
    2018:	30 e0       	ldi	r19, 0x00	; 0
    201a:	c9 01       	movw	r24, r18
    201c:	88 0f       	add	r24, r24
    201e:	99 1f       	adc	r25, r25
    2020:	88 0f       	add	r24, r24
    2022:	99 1f       	adc	r25, r25
    2024:	88 0f       	add	r24, r24
    2026:	99 1f       	adc	r25, r25
    2028:	82 0f       	add	r24, r18
    202a:	93 1f       	adc	r25, r19
    202c:	fc 01       	movw	r30, r24
    202e:	e6 5b       	subi	r30, 0xB6	; 182
    2030:	fc 4f       	sbci	r31, 0xFC	; 252
    2032:	80 81       	ld	r24, Z
    2034:	88 23       	and	r24, r24
    2036:	41 f3       	breq	.-48     	; 0x2008 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2038:	80 91 43 03 	lds	r24, 0x0343
    203c:	28 2f       	mov	r18, r24
    203e:	30 e0       	ldi	r19, 0x00	; 0
    2040:	c9 01       	movw	r24, r18
    2042:	88 0f       	add	r24, r24
    2044:	99 1f       	adc	r25, r25
    2046:	88 0f       	add	r24, r24
    2048:	99 1f       	adc	r25, r25
    204a:	88 0f       	add	r24, r24
    204c:	99 1f       	adc	r25, r25
    204e:	82 0f       	add	r24, r18
    2050:	93 1f       	adc	r25, r19
    2052:	86 5b       	subi	r24, 0xB6	; 182
    2054:	9c 4f       	sbci	r25, 0xFC	; 252
    2056:	9a 83       	std	Y+2, r25	; 0x02
    2058:	89 83       	std	Y+1, r24	; 0x01
    205a:	e9 81       	ldd	r30, Y+1	; 0x01
    205c:	fa 81       	ldd	r31, Y+2	; 0x02
    205e:	01 80       	ldd	r0, Z+1	; 0x01
    2060:	f2 81       	ldd	r31, Z+2	; 0x02
    2062:	e0 2d       	mov	r30, r0
    2064:	82 81       	ldd	r24, Z+2	; 0x02
    2066:	93 81       	ldd	r25, Z+3	; 0x03
    2068:	e9 81       	ldd	r30, Y+1	; 0x01
    206a:	fa 81       	ldd	r31, Y+2	; 0x02
    206c:	92 83       	std	Z+2, r25	; 0x02
    206e:	81 83       	std	Z+1, r24	; 0x01
    2070:	e9 81       	ldd	r30, Y+1	; 0x01
    2072:	fa 81       	ldd	r31, Y+2	; 0x02
    2074:	21 81       	ldd	r18, Z+1	; 0x01
    2076:	32 81       	ldd	r19, Z+2	; 0x02
    2078:	89 81       	ldd	r24, Y+1	; 0x01
    207a:	9a 81       	ldd	r25, Y+2	; 0x02
    207c:	03 96       	adiw	r24, 0x03	; 3
    207e:	28 17       	cp	r18, r24
    2080:	39 07       	cpc	r19, r25
    2082:	59 f4       	brne	.+22     	; 0x209a <vTaskSwitchContext+0xac>
    2084:	e9 81       	ldd	r30, Y+1	; 0x01
    2086:	fa 81       	ldd	r31, Y+2	; 0x02
    2088:	01 80       	ldd	r0, Z+1	; 0x01
    208a:	f2 81       	ldd	r31, Z+2	; 0x02
    208c:	e0 2d       	mov	r30, r0
    208e:	82 81       	ldd	r24, Z+2	; 0x02
    2090:	93 81       	ldd	r25, Z+3	; 0x03
    2092:	e9 81       	ldd	r30, Y+1	; 0x01
    2094:	fa 81       	ldd	r31, Y+2	; 0x02
    2096:	92 83       	std	Z+2, r25	; 0x02
    2098:	81 83       	std	Z+1, r24	; 0x01
    209a:	e9 81       	ldd	r30, Y+1	; 0x01
    209c:	fa 81       	ldd	r31, Y+2	; 0x02
    209e:	01 80       	ldd	r0, Z+1	; 0x01
    20a0:	f2 81       	ldd	r31, Z+2	; 0x02
    20a2:	e0 2d       	mov	r30, r0
    20a4:	86 81       	ldd	r24, Z+6	; 0x06
    20a6:	97 81       	ldd	r25, Z+7	; 0x07
    20a8:	90 93 3d 03 	sts	0x033D, r25
    20ac:	80 93 3c 03 	sts	0x033C, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    20b0:	0f 90       	pop	r0
    20b2:	0f 90       	pop	r0
    20b4:	cf 91       	pop	r28
    20b6:	df 91       	pop	r29
    20b8:	08 95       	ret

000020ba <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    20ba:	df 93       	push	r29
    20bc:	cf 93       	push	r28
    20be:	00 d0       	rcall	.+0      	; 0x20c0 <vTaskPlaceOnEventList+0x6>
    20c0:	00 d0       	rcall	.+0      	; 0x20c2 <vTaskPlaceOnEventList+0x8>
    20c2:	00 d0       	rcall	.+0      	; 0x20c4 <vTaskPlaceOnEventList+0xa>
    20c4:	cd b7       	in	r28, 0x3d	; 61
    20c6:	de b7       	in	r29, 0x3e	; 62
    20c8:	9c 83       	std	Y+4, r25	; 0x04
    20ca:	8b 83       	std	Y+3, r24	; 0x03
    20cc:	7e 83       	std	Y+6, r23	; 0x06
    20ce:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    20d0:	4b 81       	ldd	r20, Y+3	; 0x03
    20d2:	5c 81       	ldd	r21, Y+4	; 0x04
    20d4:	80 91 3c 03 	lds	r24, 0x033C
    20d8:	90 91 3d 03 	lds	r25, 0x033D
    20dc:	9c 01       	movw	r18, r24
    20de:	24 5f       	subi	r18, 0xF4	; 244
    20e0:	3f 4f       	sbci	r19, 0xFF	; 255
    20e2:	ca 01       	movw	r24, r20
    20e4:	b9 01       	movw	r22, r18
    20e6:	0e 94 13 04 	call	0x826	; 0x826 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    20ea:	80 91 3c 03 	lds	r24, 0x033C
    20ee:	90 91 3d 03 	lds	r25, 0x033D
    20f2:	02 96       	adiw	r24, 0x02	; 2
    20f4:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    20f8:	20 91 40 03 	lds	r18, 0x0340
    20fc:	30 91 41 03 	lds	r19, 0x0341
    2100:	8d 81       	ldd	r24, Y+5	; 0x05
    2102:	9e 81       	ldd	r25, Y+6	; 0x06
    2104:	82 0f       	add	r24, r18
    2106:	93 1f       	adc	r25, r19
    2108:	9a 83       	std	Y+2, r25	; 0x02
    210a:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    210c:	89 81       	ldd	r24, Y+1	; 0x01
    210e:	9a 81       	ldd	r25, Y+2	; 0x02
    2110:	0e 94 57 12 	call	0x24ae	; 0x24ae <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2114:	26 96       	adiw	r28, 0x06	; 6
    2116:	0f b6       	in	r0, 0x3f	; 63
    2118:	f8 94       	cli
    211a:	de bf       	out	0x3e, r29	; 62
    211c:	0f be       	out	0x3f, r0	; 63
    211e:	cd bf       	out	0x3d, r28	; 61
    2120:	cf 91       	pop	r28
    2122:	df 91       	pop	r29
    2124:	08 95       	ret

00002126 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2126:	df 93       	push	r29
    2128:	cf 93       	push	r28
    212a:	00 d0       	rcall	.+0      	; 0x212c <xTaskRemoveFromEventList+0x6>
    212c:	00 d0       	rcall	.+0      	; 0x212e <xTaskRemoveFromEventList+0x8>
    212e:	0f 92       	push	r0
    2130:	cd b7       	in	r28, 0x3d	; 61
    2132:	de b7       	in	r29, 0x3e	; 62
    2134:	9d 83       	std	Y+5, r25	; 0x05
    2136:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2138:	ec 81       	ldd	r30, Y+4	; 0x04
    213a:	fd 81       	ldd	r31, Y+5	; 0x05
    213c:	05 80       	ldd	r0, Z+5	; 0x05
    213e:	f6 81       	ldd	r31, Z+6	; 0x06
    2140:	e0 2d       	mov	r30, r0
    2142:	86 81       	ldd	r24, Z+6	; 0x06
    2144:	97 81       	ldd	r25, Z+7	; 0x07
    2146:	9b 83       	std	Y+3, r25	; 0x03
    2148:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    214a:	8a 81       	ldd	r24, Y+2	; 0x02
    214c:	9b 81       	ldd	r25, Y+3	; 0x03
    214e:	0c 96       	adiw	r24, 0x0c	; 12
    2150:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2154:	80 91 45 03 	lds	r24, 0x0345
    2158:	88 23       	and	r24, r24
    215a:	61 f5       	brne	.+88     	; 0x21b4 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    215c:	8a 81       	ldd	r24, Y+2	; 0x02
    215e:	9b 81       	ldd	r25, Y+3	; 0x03
    2160:	02 96       	adiw	r24, 0x02	; 2
    2162:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2166:	ea 81       	ldd	r30, Y+2	; 0x02
    2168:	fb 81       	ldd	r31, Y+3	; 0x03
    216a:	96 89       	ldd	r25, Z+22	; 0x16
    216c:	80 91 43 03 	lds	r24, 0x0343
    2170:	89 17       	cp	r24, r25
    2172:	28 f4       	brcc	.+10     	; 0x217e <xTaskRemoveFromEventList+0x58>
    2174:	ea 81       	ldd	r30, Y+2	; 0x02
    2176:	fb 81       	ldd	r31, Y+3	; 0x03
    2178:	86 89       	ldd	r24, Z+22	; 0x16
    217a:	80 93 43 03 	sts	0x0343, r24
    217e:	ea 81       	ldd	r30, Y+2	; 0x02
    2180:	fb 81       	ldd	r31, Y+3	; 0x03
    2182:	86 89       	ldd	r24, Z+22	; 0x16
    2184:	28 2f       	mov	r18, r24
    2186:	30 e0       	ldi	r19, 0x00	; 0
    2188:	c9 01       	movw	r24, r18
    218a:	88 0f       	add	r24, r24
    218c:	99 1f       	adc	r25, r25
    218e:	88 0f       	add	r24, r24
    2190:	99 1f       	adc	r25, r25
    2192:	88 0f       	add	r24, r24
    2194:	99 1f       	adc	r25, r25
    2196:	82 0f       	add	r24, r18
    2198:	93 1f       	adc	r25, r19
    219a:	ac 01       	movw	r20, r24
    219c:	46 5b       	subi	r20, 0xB6	; 182
    219e:	5c 4f       	sbci	r21, 0xFC	; 252
    21a0:	8a 81       	ldd	r24, Y+2	; 0x02
    21a2:	9b 81       	ldd	r25, Y+3	; 0x03
    21a4:	9c 01       	movw	r18, r24
    21a6:	2e 5f       	subi	r18, 0xFE	; 254
    21a8:	3f 4f       	sbci	r19, 0xFF	; 255
    21aa:	ca 01       	movw	r24, r20
    21ac:	b9 01       	movw	r22, r18
    21ae:	0e 94 c7 03 	call	0x78e	; 0x78e <vListInsertEnd>
    21b2:	0a c0       	rjmp	.+20     	; 0x21c8 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    21b4:	8a 81       	ldd	r24, Y+2	; 0x02
    21b6:	9b 81       	ldd	r25, Y+3	; 0x03
    21b8:	9c 01       	movw	r18, r24
    21ba:	24 5f       	subi	r18, 0xF4	; 244
    21bc:	3f 4f       	sbci	r19, 0xFF	; 255
    21be:	8d e8       	ldi	r24, 0x8D	; 141
    21c0:	93 e0       	ldi	r25, 0x03	; 3
    21c2:	b9 01       	movw	r22, r18
    21c4:	0e 94 c7 03 	call	0x78e	; 0x78e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    21c8:	ea 81       	ldd	r30, Y+2	; 0x02
    21ca:	fb 81       	ldd	r31, Y+3	; 0x03
    21cc:	96 89       	ldd	r25, Z+22	; 0x16
    21ce:	e0 91 3c 03 	lds	r30, 0x033C
    21d2:	f0 91 3d 03 	lds	r31, 0x033D
    21d6:	86 89       	ldd	r24, Z+22	; 0x16
    21d8:	98 17       	cp	r25, r24
    21da:	18 f0       	brcs	.+6      	; 0x21e2 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    21dc:	81 e0       	ldi	r24, 0x01	; 1
    21de:	89 83       	std	Y+1, r24	; 0x01
    21e0:	01 c0       	rjmp	.+2      	; 0x21e4 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    21e2:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    21e4:	89 81       	ldd	r24, Y+1	; 0x01
}
    21e6:	0f 90       	pop	r0
    21e8:	0f 90       	pop	r0
    21ea:	0f 90       	pop	r0
    21ec:	0f 90       	pop	r0
    21ee:	0f 90       	pop	r0
    21f0:	cf 91       	pop	r28
    21f2:	df 91       	pop	r29
    21f4:	08 95       	ret

000021f6 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    21f6:	df 93       	push	r29
    21f8:	cf 93       	push	r28
    21fa:	00 d0       	rcall	.+0      	; 0x21fc <vTaskSetTimeOutState+0x6>
    21fc:	cd b7       	in	r28, 0x3d	; 61
    21fe:	de b7       	in	r29, 0x3e	; 62
    2200:	9a 83       	std	Y+2, r25	; 0x02
    2202:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2204:	80 91 48 03 	lds	r24, 0x0348
    2208:	e9 81       	ldd	r30, Y+1	; 0x01
    220a:	fa 81       	ldd	r31, Y+2	; 0x02
    220c:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    220e:	80 91 40 03 	lds	r24, 0x0340
    2212:	90 91 41 03 	lds	r25, 0x0341
    2216:	e9 81       	ldd	r30, Y+1	; 0x01
    2218:	fa 81       	ldd	r31, Y+2	; 0x02
    221a:	92 83       	std	Z+2, r25	; 0x02
    221c:	81 83       	std	Z+1, r24	; 0x01
}
    221e:	0f 90       	pop	r0
    2220:	0f 90       	pop	r0
    2222:	cf 91       	pop	r28
    2224:	df 91       	pop	r29
    2226:	08 95       	ret

00002228 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2228:	df 93       	push	r29
    222a:	cf 93       	push	r28
    222c:	00 d0       	rcall	.+0      	; 0x222e <xTaskCheckForTimeOut+0x6>
    222e:	00 d0       	rcall	.+0      	; 0x2230 <xTaskCheckForTimeOut+0x8>
    2230:	0f 92       	push	r0
    2232:	cd b7       	in	r28, 0x3d	; 61
    2234:	de b7       	in	r29, 0x3e	; 62
    2236:	9b 83       	std	Y+3, r25	; 0x03
    2238:	8a 83       	std	Y+2, r24	; 0x02
    223a:	7d 83       	std	Y+5, r23	; 0x05
    223c:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    223e:	0f b6       	in	r0, 0x3f	; 63
    2240:	f8 94       	cli
    2242:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2244:	ea 81       	ldd	r30, Y+2	; 0x02
    2246:	fb 81       	ldd	r31, Y+3	; 0x03
    2248:	90 81       	ld	r25, Z
    224a:	80 91 48 03 	lds	r24, 0x0348
    224e:	98 17       	cp	r25, r24
    2250:	71 f0       	breq	.+28     	; 0x226e <xTaskCheckForTimeOut+0x46>
    2252:	ea 81       	ldd	r30, Y+2	; 0x02
    2254:	fb 81       	ldd	r31, Y+3	; 0x03
    2256:	21 81       	ldd	r18, Z+1	; 0x01
    2258:	32 81       	ldd	r19, Z+2	; 0x02
    225a:	80 91 40 03 	lds	r24, 0x0340
    225e:	90 91 41 03 	lds	r25, 0x0341
    2262:	82 17       	cp	r24, r18
    2264:	93 07       	cpc	r25, r19
    2266:	18 f0       	brcs	.+6      	; 0x226e <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2268:	81 e0       	ldi	r24, 0x01	; 1
    226a:	89 83       	std	Y+1, r24	; 0x01
    226c:	2f c0       	rjmp	.+94     	; 0x22cc <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    226e:	20 91 40 03 	lds	r18, 0x0340
    2272:	30 91 41 03 	lds	r19, 0x0341
    2276:	ea 81       	ldd	r30, Y+2	; 0x02
    2278:	fb 81       	ldd	r31, Y+3	; 0x03
    227a:	81 81       	ldd	r24, Z+1	; 0x01
    227c:	92 81       	ldd	r25, Z+2	; 0x02
    227e:	28 1b       	sub	r18, r24
    2280:	39 0b       	sbc	r19, r25
    2282:	ec 81       	ldd	r30, Y+4	; 0x04
    2284:	fd 81       	ldd	r31, Y+5	; 0x05
    2286:	80 81       	ld	r24, Z
    2288:	91 81       	ldd	r25, Z+1	; 0x01
    228a:	28 17       	cp	r18, r24
    228c:	39 07       	cpc	r19, r25
    228e:	e0 f4       	brcc	.+56     	; 0x22c8 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2290:	ec 81       	ldd	r30, Y+4	; 0x04
    2292:	fd 81       	ldd	r31, Y+5	; 0x05
    2294:	40 81       	ld	r20, Z
    2296:	51 81       	ldd	r21, Z+1	; 0x01
    2298:	ea 81       	ldd	r30, Y+2	; 0x02
    229a:	fb 81       	ldd	r31, Y+3	; 0x03
    229c:	21 81       	ldd	r18, Z+1	; 0x01
    229e:	32 81       	ldd	r19, Z+2	; 0x02
    22a0:	80 91 40 03 	lds	r24, 0x0340
    22a4:	90 91 41 03 	lds	r25, 0x0341
    22a8:	b9 01       	movw	r22, r18
    22aa:	68 1b       	sub	r22, r24
    22ac:	79 0b       	sbc	r23, r25
    22ae:	cb 01       	movw	r24, r22
    22b0:	84 0f       	add	r24, r20
    22b2:	95 1f       	adc	r25, r21
    22b4:	ec 81       	ldd	r30, Y+4	; 0x04
    22b6:	fd 81       	ldd	r31, Y+5	; 0x05
    22b8:	91 83       	std	Z+1, r25	; 0x01
    22ba:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    22bc:	8a 81       	ldd	r24, Y+2	; 0x02
    22be:	9b 81       	ldd	r25, Y+3	; 0x03
    22c0:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    22c4:	19 82       	std	Y+1, r1	; 0x01
    22c6:	02 c0       	rjmp	.+4      	; 0x22cc <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    22c8:	81 e0       	ldi	r24, 0x01	; 1
    22ca:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    22cc:	0f 90       	pop	r0
    22ce:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    22d0:	89 81       	ldd	r24, Y+1	; 0x01
}
    22d2:	0f 90       	pop	r0
    22d4:	0f 90       	pop	r0
    22d6:	0f 90       	pop	r0
    22d8:	0f 90       	pop	r0
    22da:	0f 90       	pop	r0
    22dc:	cf 91       	pop	r28
    22de:	df 91       	pop	r29
    22e0:	08 95       	ret

000022e2 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    22e2:	df 93       	push	r29
    22e4:	cf 93       	push	r28
    22e6:	cd b7       	in	r28, 0x3d	; 61
    22e8:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    22ea:	81 e0       	ldi	r24, 0x01	; 1
    22ec:	80 93 47 03 	sts	0x0347, r24
}
    22f0:	cf 91       	pop	r28
    22f2:	df 91       	pop	r29
    22f4:	08 95       	ret

000022f6 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    22f6:	df 93       	push	r29
    22f8:	cf 93       	push	r28
    22fa:	00 d0       	rcall	.+0      	; 0x22fc <prvIdleTask+0x6>
    22fc:	cd b7       	in	r28, 0x3d	; 61
    22fe:	de b7       	in	r29, 0x3e	; 62
    2300:	9a 83       	std	Y+2, r25	; 0x02
    2302:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    2304:	0e 94 19 12 	call	0x2432	; 0x2432 <prvCheckTasksWaitingTermination>
    2308:	fd cf       	rjmp	.-6      	; 0x2304 <prvIdleTask+0xe>

0000230a <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    230a:	0f 93       	push	r16
    230c:	1f 93       	push	r17
    230e:	df 93       	push	r29
    2310:	cf 93       	push	r28
    2312:	cd b7       	in	r28, 0x3d	; 61
    2314:	de b7       	in	r29, 0x3e	; 62
    2316:	29 97       	sbiw	r28, 0x09	; 9
    2318:	0f b6       	in	r0, 0x3f	; 63
    231a:	f8 94       	cli
    231c:	de bf       	out	0x3e, r29	; 62
    231e:	0f be       	out	0x3f, r0	; 63
    2320:	cd bf       	out	0x3d, r28	; 61
    2322:	9a 83       	std	Y+2, r25	; 0x02
    2324:	89 83       	std	Y+1, r24	; 0x01
    2326:	7c 83       	std	Y+4, r23	; 0x04
    2328:	6b 83       	std	Y+3, r22	; 0x03
    232a:	4d 83       	std	Y+5, r20	; 0x05
    232c:	3f 83       	std	Y+7, r19	; 0x07
    232e:	2e 83       	std	Y+6, r18	; 0x06
    2330:	19 87       	std	Y+9, r17	; 0x09
    2332:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2334:	89 81       	ldd	r24, Y+1	; 0x01
    2336:	9a 81       	ldd	r25, Y+2	; 0x02
    2338:	49 96       	adiw	r24, 0x19	; 25
    233a:	2b 81       	ldd	r18, Y+3	; 0x03
    233c:	3c 81       	ldd	r19, Y+4	; 0x04
    233e:	b9 01       	movw	r22, r18
    2340:	48 e0       	ldi	r20, 0x08	; 8
    2342:	50 e0       	ldi	r21, 0x00	; 0
    2344:	0e 94 c6 19 	call	0x338c	; 0x338c <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    2348:	e9 81       	ldd	r30, Y+1	; 0x01
    234a:	fa 81       	ldd	r31, Y+2	; 0x02
    234c:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    234e:	8d 81       	ldd	r24, Y+5	; 0x05
    2350:	85 30       	cpi	r24, 0x05	; 5
    2352:	10 f0       	brcs	.+4      	; 0x2358 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    2354:	84 e0       	ldi	r24, 0x04	; 4
    2356:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    2358:	e9 81       	ldd	r30, Y+1	; 0x01
    235a:	fa 81       	ldd	r31, Y+2	; 0x02
    235c:	8d 81       	ldd	r24, Y+5	; 0x05
    235e:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2360:	89 81       	ldd	r24, Y+1	; 0x01
    2362:	9a 81       	ldd	r25, Y+2	; 0x02
    2364:	02 96       	adiw	r24, 0x02	; 2
    2366:	0e 94 b7 03 	call	0x76e	; 0x76e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    236a:	89 81       	ldd	r24, Y+1	; 0x01
    236c:	9a 81       	ldd	r25, Y+2	; 0x02
    236e:	0c 96       	adiw	r24, 0x0c	; 12
    2370:	0e 94 b7 03 	call	0x76e	; 0x76e <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2374:	e9 81       	ldd	r30, Y+1	; 0x01
    2376:	fa 81       	ldd	r31, Y+2	; 0x02
    2378:	89 81       	ldd	r24, Y+1	; 0x01
    237a:	9a 81       	ldd	r25, Y+2	; 0x02
    237c:	91 87       	std	Z+9, r25	; 0x09
    237e:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2380:	8d 81       	ldd	r24, Y+5	; 0x05
    2382:	28 2f       	mov	r18, r24
    2384:	30 e0       	ldi	r19, 0x00	; 0
    2386:	85 e0       	ldi	r24, 0x05	; 5
    2388:	90 e0       	ldi	r25, 0x00	; 0
    238a:	82 1b       	sub	r24, r18
    238c:	93 0b       	sbc	r25, r19
    238e:	e9 81       	ldd	r30, Y+1	; 0x01
    2390:	fa 81       	ldd	r31, Y+2	; 0x02
    2392:	95 87       	std	Z+13, r25	; 0x0d
    2394:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2396:	e9 81       	ldd	r30, Y+1	; 0x01
    2398:	fa 81       	ldd	r31, Y+2	; 0x02
    239a:	89 81       	ldd	r24, Y+1	; 0x01
    239c:	9a 81       	ldd	r25, Y+2	; 0x02
    239e:	93 8b       	std	Z+19, r25	; 0x13
    23a0:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    23a2:	29 96       	adiw	r28, 0x09	; 9
    23a4:	0f b6       	in	r0, 0x3f	; 63
    23a6:	f8 94       	cli
    23a8:	de bf       	out	0x3e, r29	; 62
    23aa:	0f be       	out	0x3f, r0	; 63
    23ac:	cd bf       	out	0x3d, r28	; 61
    23ae:	cf 91       	pop	r28
    23b0:	df 91       	pop	r29
    23b2:	1f 91       	pop	r17
    23b4:	0f 91       	pop	r16
    23b6:	08 95       	ret

000023b8 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    23b8:	df 93       	push	r29
    23ba:	cf 93       	push	r28
    23bc:	0f 92       	push	r0
    23be:	cd b7       	in	r28, 0x3d	; 61
    23c0:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    23c2:	19 82       	std	Y+1, r1	; 0x01
    23c4:	13 c0       	rjmp	.+38     	; 0x23ec <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    23c6:	89 81       	ldd	r24, Y+1	; 0x01
    23c8:	28 2f       	mov	r18, r24
    23ca:	30 e0       	ldi	r19, 0x00	; 0
    23cc:	c9 01       	movw	r24, r18
    23ce:	88 0f       	add	r24, r24
    23d0:	99 1f       	adc	r25, r25
    23d2:	88 0f       	add	r24, r24
    23d4:	99 1f       	adc	r25, r25
    23d6:	88 0f       	add	r24, r24
    23d8:	99 1f       	adc	r25, r25
    23da:	82 0f       	add	r24, r18
    23dc:	93 1f       	adc	r25, r19
    23de:	86 5b       	subi	r24, 0xB6	; 182
    23e0:	9c 4f       	sbci	r25, 0xFC	; 252
    23e2:	0e 94 8d 03 	call	0x71a	; 0x71a <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    23e6:	89 81       	ldd	r24, Y+1	; 0x01
    23e8:	8f 5f       	subi	r24, 0xFF	; 255
    23ea:	89 83       	std	Y+1, r24	; 0x01
    23ec:	89 81       	ldd	r24, Y+1	; 0x01
    23ee:	85 30       	cpi	r24, 0x05	; 5
    23f0:	50 f3       	brcs	.-44     	; 0x23c6 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    23f2:	87 e7       	ldi	r24, 0x77	; 119
    23f4:	93 e0       	ldi	r25, 0x03	; 3
    23f6:	0e 94 8d 03 	call	0x71a	; 0x71a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    23fa:	80 e8       	ldi	r24, 0x80	; 128
    23fc:	93 e0       	ldi	r25, 0x03	; 3
    23fe:	0e 94 8d 03 	call	0x71a	; 0x71a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2402:	8d e8       	ldi	r24, 0x8D	; 141
    2404:	93 e0       	ldi	r25, 0x03	; 3
    2406:	0e 94 8d 03 	call	0x71a	; 0x71a <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    240a:	86 e9       	ldi	r24, 0x96	; 150
    240c:	93 e0       	ldi	r25, 0x03	; 3
    240e:	0e 94 8d 03 	call	0x71a	; 0x71a <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2412:	87 e7       	ldi	r24, 0x77	; 119
    2414:	93 e0       	ldi	r25, 0x03	; 3
    2416:	90 93 8a 03 	sts	0x038A, r25
    241a:	80 93 89 03 	sts	0x0389, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    241e:	80 e8       	ldi	r24, 0x80	; 128
    2420:	93 e0       	ldi	r25, 0x03	; 3
    2422:	90 93 8c 03 	sts	0x038C, r25
    2426:	80 93 8b 03 	sts	0x038B, r24
}
    242a:	0f 90       	pop	r0
    242c:	cf 91       	pop	r28
    242e:	df 91       	pop	r29
    2430:	08 95       	ret

00002432 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2432:	df 93       	push	r29
    2434:	cf 93       	push	r28
    2436:	00 d0       	rcall	.+0      	; 0x2438 <prvCheckTasksWaitingTermination+0x6>
    2438:	0f 92       	push	r0
    243a:	cd b7       	in	r28, 0x3d	; 61
    243c:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    243e:	80 91 3e 03 	lds	r24, 0x033E
    2442:	88 23       	and	r24, r24
    2444:	71 f1       	breq	.+92     	; 0x24a2 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    2446:	0e 94 57 0e 	call	0x1cae	; 0x1cae <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    244a:	80 91 96 03 	lds	r24, 0x0396
    244e:	1b 82       	std	Y+3, r1	; 0x03
    2450:	88 23       	and	r24, r24
    2452:	11 f4       	brne	.+4      	; 0x2458 <prvCheckTasksWaitingTermination+0x26>
    2454:	81 e0       	ldi	r24, 0x01	; 1
    2456:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    2458:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    245c:	8b 81       	ldd	r24, Y+3	; 0x03
    245e:	88 23       	and	r24, r24
    2460:	01 f5       	brne	.+64     	; 0x24a2 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    2462:	0f b6       	in	r0, 0x3f	; 63
    2464:	f8 94       	cli
    2466:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    2468:	e0 91 9b 03 	lds	r30, 0x039B
    246c:	f0 91 9c 03 	lds	r31, 0x039C
    2470:	86 81       	ldd	r24, Z+6	; 0x06
    2472:	97 81       	ldd	r25, Z+7	; 0x07
    2474:	9a 83       	std	Y+2, r25	; 0x02
    2476:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    2478:	89 81       	ldd	r24, Y+1	; 0x01
    247a:	9a 81       	ldd	r25, Y+2	; 0x02
    247c:	02 96       	adiw	r24, 0x02	; 2
    247e:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListRemove>
					--uxCurrentNumberOfTasks;
    2482:	80 91 3f 03 	lds	r24, 0x033F
    2486:	81 50       	subi	r24, 0x01	; 1
    2488:	80 93 3f 03 	sts	0x033F, r24
					--uxTasksDeleted;
    248c:	80 91 3e 03 	lds	r24, 0x033E
    2490:	81 50       	subi	r24, 0x01	; 1
    2492:	80 93 3e 03 	sts	0x033E, r24
				}
				taskEXIT_CRITICAL();
    2496:	0f 90       	pop	r0
    2498:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    249a:	89 81       	ldd	r24, Y+1	; 0x01
    249c:	9a 81       	ldd	r25, Y+2	; 0x02
    249e:	0e 94 f0 12 	call	0x25e0	; 0x25e0 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    24a2:	0f 90       	pop	r0
    24a4:	0f 90       	pop	r0
    24a6:	0f 90       	pop	r0
    24a8:	cf 91       	pop	r28
    24aa:	df 91       	pop	r29
    24ac:	08 95       	ret

000024ae <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    24ae:	df 93       	push	r29
    24b0:	cf 93       	push	r28
    24b2:	00 d0       	rcall	.+0      	; 0x24b4 <prvAddCurrentTaskToDelayedList+0x6>
    24b4:	cd b7       	in	r28, 0x3d	; 61
    24b6:	de b7       	in	r29, 0x3e	; 62
    24b8:	9a 83       	std	Y+2, r25	; 0x02
    24ba:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    24bc:	e0 91 3c 03 	lds	r30, 0x033C
    24c0:	f0 91 3d 03 	lds	r31, 0x033D
    24c4:	89 81       	ldd	r24, Y+1	; 0x01
    24c6:	9a 81       	ldd	r25, Y+2	; 0x02
    24c8:	93 83       	std	Z+3, r25	; 0x03
    24ca:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    24cc:	20 91 40 03 	lds	r18, 0x0340
    24d0:	30 91 41 03 	lds	r19, 0x0341
    24d4:	89 81       	ldd	r24, Y+1	; 0x01
    24d6:	9a 81       	ldd	r25, Y+2	; 0x02
    24d8:	82 17       	cp	r24, r18
    24da:	93 07       	cpc	r25, r19
    24dc:	70 f4       	brcc	.+28     	; 0x24fa <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    24de:	80 91 8b 03 	lds	r24, 0x038B
    24e2:	90 91 8c 03 	lds	r25, 0x038C
    24e6:	20 91 3c 03 	lds	r18, 0x033C
    24ea:	30 91 3d 03 	lds	r19, 0x033D
    24ee:	2e 5f       	subi	r18, 0xFE	; 254
    24f0:	3f 4f       	sbci	r19, 0xFF	; 255
    24f2:	b9 01       	movw	r22, r18
    24f4:	0e 94 13 04 	call	0x826	; 0x826 <vListInsert>
    24f8:	1e c0       	rjmp	.+60     	; 0x2536 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    24fa:	40 91 89 03 	lds	r20, 0x0389
    24fe:	50 91 8a 03 	lds	r21, 0x038A
    2502:	80 91 3c 03 	lds	r24, 0x033C
    2506:	90 91 3d 03 	lds	r25, 0x033D
    250a:	9c 01       	movw	r18, r24
    250c:	2e 5f       	subi	r18, 0xFE	; 254
    250e:	3f 4f       	sbci	r19, 0xFF	; 255
    2510:	ca 01       	movw	r24, r20
    2512:	b9 01       	movw	r22, r18
    2514:	0e 94 13 04 	call	0x826	; 0x826 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    2518:	20 91 65 00 	lds	r18, 0x0065
    251c:	30 91 66 00 	lds	r19, 0x0066
    2520:	89 81       	ldd	r24, Y+1	; 0x01
    2522:	9a 81       	ldd	r25, Y+2	; 0x02
    2524:	82 17       	cp	r24, r18
    2526:	93 07       	cpc	r25, r19
    2528:	30 f4       	brcc	.+12     	; 0x2536 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    252a:	89 81       	ldd	r24, Y+1	; 0x01
    252c:	9a 81       	ldd	r25, Y+2	; 0x02
    252e:	90 93 66 00 	sts	0x0066, r25
    2532:	80 93 65 00 	sts	0x0065, r24
		}
	}
}
    2536:	0f 90       	pop	r0
    2538:	0f 90       	pop	r0
    253a:	cf 91       	pop	r28
    253c:	df 91       	pop	r29
    253e:	08 95       	ret

00002540 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    2540:	df 93       	push	r29
    2542:	cf 93       	push	r28
    2544:	cd b7       	in	r28, 0x3d	; 61
    2546:	de b7       	in	r29, 0x3e	; 62
    2548:	28 97       	sbiw	r28, 0x08	; 8
    254a:	0f b6       	in	r0, 0x3f	; 63
    254c:	f8 94       	cli
    254e:	de bf       	out	0x3e, r29	; 62
    2550:	0f be       	out	0x3f, r0	; 63
    2552:	cd bf       	out	0x3d, r28	; 61
    2554:	9c 83       	std	Y+4, r25	; 0x04
    2556:	8b 83       	std	Y+3, r24	; 0x03
    2558:	7e 83       	std	Y+6, r23	; 0x06
    255a:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    255c:	81 e2       	ldi	r24, 0x21	; 33
    255e:	90 e0       	ldi	r25, 0x00	; 0
    2560:	0e 94 21 03 	call	0x642	; 0x642 <pvPortMalloc>
    2564:	9a 83       	std	Y+2, r25	; 0x02
    2566:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    2568:	89 81       	ldd	r24, Y+1	; 0x01
    256a:	9a 81       	ldd	r25, Y+2	; 0x02
    256c:	00 97       	sbiw	r24, 0x00	; 0
    256e:	69 f1       	breq	.+90     	; 0x25ca <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2570:	8d 81       	ldd	r24, Y+5	; 0x05
    2572:	9e 81       	ldd	r25, Y+6	; 0x06
    2574:	00 97       	sbiw	r24, 0x00	; 0
    2576:	39 f4       	brne	.+14     	; 0x2586 <prvAllocateTCBAndStack+0x46>
    2578:	8b 81       	ldd	r24, Y+3	; 0x03
    257a:	9c 81       	ldd	r25, Y+4	; 0x04
    257c:	0e 94 21 03 	call	0x642	; 0x642 <pvPortMalloc>
    2580:	98 87       	std	Y+8, r25	; 0x08
    2582:	8f 83       	std	Y+7, r24	; 0x07
    2584:	04 c0       	rjmp	.+8      	; 0x258e <prvAllocateTCBAndStack+0x4e>
    2586:	8d 81       	ldd	r24, Y+5	; 0x05
    2588:	9e 81       	ldd	r25, Y+6	; 0x06
    258a:	98 87       	std	Y+8, r25	; 0x08
    258c:	8f 83       	std	Y+7, r24	; 0x07
    258e:	e9 81       	ldd	r30, Y+1	; 0x01
    2590:	fa 81       	ldd	r31, Y+2	; 0x02
    2592:	8f 81       	ldd	r24, Y+7	; 0x07
    2594:	98 85       	ldd	r25, Y+8	; 0x08
    2596:	90 8f       	std	Z+24, r25	; 0x18
    2598:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    259a:	e9 81       	ldd	r30, Y+1	; 0x01
    259c:	fa 81       	ldd	r31, Y+2	; 0x02
    259e:	87 89       	ldd	r24, Z+23	; 0x17
    25a0:	90 8d       	ldd	r25, Z+24	; 0x18
    25a2:	00 97       	sbiw	r24, 0x00	; 0
    25a4:	39 f4       	brne	.+14     	; 0x25b4 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    25a6:	89 81       	ldd	r24, Y+1	; 0x01
    25a8:	9a 81       	ldd	r25, Y+2	; 0x02
    25aa:	0e 94 67 03 	call	0x6ce	; 0x6ce <vPortFree>
			pxNewTCB = NULL;
    25ae:	1a 82       	std	Y+2, r1	; 0x02
    25b0:	19 82       	std	Y+1, r1	; 0x01
    25b2:	0b c0       	rjmp	.+22     	; 0x25ca <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    25b4:	e9 81       	ldd	r30, Y+1	; 0x01
    25b6:	fa 81       	ldd	r31, Y+2	; 0x02
    25b8:	87 89       	ldd	r24, Z+23	; 0x17
    25ba:	90 8d       	ldd	r25, Z+24	; 0x18
    25bc:	2b 81       	ldd	r18, Y+3	; 0x03
    25be:	3c 81       	ldd	r19, Y+4	; 0x04
    25c0:	65 ea       	ldi	r22, 0xA5	; 165
    25c2:	70 e0       	ldi	r23, 0x00	; 0
    25c4:	a9 01       	movw	r20, r18
    25c6:	0e 94 bf 19 	call	0x337e	; 0x337e <memset>
		}
	}

	return pxNewTCB;
    25ca:	89 81       	ldd	r24, Y+1	; 0x01
    25cc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    25ce:	28 96       	adiw	r28, 0x08	; 8
    25d0:	0f b6       	in	r0, 0x3f	; 63
    25d2:	f8 94       	cli
    25d4:	de bf       	out	0x3e, r29	; 62
    25d6:	0f be       	out	0x3f, r0	; 63
    25d8:	cd bf       	out	0x3d, r28	; 61
    25da:	cf 91       	pop	r28
    25dc:	df 91       	pop	r29
    25de:	08 95       	ret

000025e0 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    25e0:	df 93       	push	r29
    25e2:	cf 93       	push	r28
    25e4:	00 d0       	rcall	.+0      	; 0x25e6 <prvDeleteTCB+0x6>
    25e6:	cd b7       	in	r28, 0x3d	; 61
    25e8:	de b7       	in	r29, 0x3e	; 62
    25ea:	9a 83       	std	Y+2, r25	; 0x02
    25ec:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    25ee:	e9 81       	ldd	r30, Y+1	; 0x01
    25f0:	fa 81       	ldd	r31, Y+2	; 0x02
    25f2:	87 89       	ldd	r24, Z+23	; 0x17
    25f4:	90 8d       	ldd	r25, Z+24	; 0x18
    25f6:	0e 94 67 03 	call	0x6ce	; 0x6ce <vPortFree>
		vPortFree( pxTCB );
    25fa:	89 81       	ldd	r24, Y+1	; 0x01
    25fc:	9a 81       	ldd	r25, Y+2	; 0x02
    25fe:	0e 94 67 03 	call	0x6ce	; 0x6ce <vPortFree>
	}
    2602:	0f 90       	pop	r0
    2604:	0f 90       	pop	r0
    2606:	cf 91       	pop	r28
    2608:	df 91       	pop	r29
    260a:	08 95       	ret

0000260c <DIO_Init>:

static void DIO_InitPin(DIO_Pin_type pin , DIO_PinStatus_type status);
extern const DIO_PinStatus_type PinsStatusArray[TOTAL_PINS];

void DIO_Init(void)
{
    260c:	df 93       	push	r29
    260e:	cf 93       	push	r28
    2610:	0f 92       	push	r0
    2612:	cd b7       	in	r28, 0x3d	; 61
    2614:	de b7       	in	r29, 0x3e	; 62
	DIO_Pin_type counter;
	for (counter=PINA_0; counter<TOTAL_PINS; ++counter)
    2616:	19 82       	std	Y+1, r1	; 0x01
    2618:	0e c0       	rjmp	.+28     	; 0x2636 <DIO_Init+0x2a>
	{
		DIO_InitPin(counter , PinsStatusArray[counter]);
    261a:	89 81       	ldd	r24, Y+1	; 0x01
    261c:	88 2f       	mov	r24, r24
    261e:	90 e0       	ldi	r25, 0x00	; 0
    2620:	fc 01       	movw	r30, r24
    2622:	e9 57       	subi	r30, 0x79	; 121
    2624:	ff 4f       	sbci	r31, 0xFF	; 255
    2626:	90 81       	ld	r25, Z
    2628:	89 81       	ldd	r24, Y+1	; 0x01
    262a:	69 2f       	mov	r22, r25
    262c:	0e 94 22 13 	call	0x2644	; 0x2644 <DIO_InitPin>
extern const DIO_PinStatus_type PinsStatusArray[TOTAL_PINS];

void DIO_Init(void)
{
	DIO_Pin_type counter;
	for (counter=PINA_0; counter<TOTAL_PINS; ++counter)
    2630:	89 81       	ldd	r24, Y+1	; 0x01
    2632:	8f 5f       	subi	r24, 0xFF	; 255
    2634:	89 83       	std	Y+1, r24	; 0x01
    2636:	89 81       	ldd	r24, Y+1	; 0x01
    2638:	80 32       	cpi	r24, 0x20	; 32
    263a:	78 f3       	brcs	.-34     	; 0x261a <DIO_Init+0xe>
	{
		DIO_InitPin(counter , PinsStatusArray[counter]);
	}
}
    263c:	0f 90       	pop	r0
    263e:	cf 91       	pop	r28
    2640:	df 91       	pop	r29
    2642:	08 95       	ret

00002644 <DIO_InitPin>:

static void DIO_InitPin(DIO_Pin_type pin , DIO_PinStatus_type status)
{
    2644:	df 93       	push	r29
    2646:	cf 93       	push	r28
    2648:	cd b7       	in	r28, 0x3d	; 61
    264a:	de b7       	in	r29, 0x3e	; 62
    264c:	2c 97       	sbiw	r28, 0x0c	; 12
    264e:	0f b6       	in	r0, 0x3f	; 63
    2650:	f8 94       	cli
    2652:	de bf       	out	0x3e, r29	; 62
    2654:	0f be       	out	0x3f, r0	; 63
    2656:	cd bf       	out	0x3d, r28	; 61
    2658:	8b 83       	std	Y+3, r24	; 0x03
    265a:	6c 83       	std	Y+4, r22	; 0x04
	DIO_Port_type port = pin/8;
    265c:	8b 81       	ldd	r24, Y+3	; 0x03
    265e:	86 95       	lsr	r24
    2660:	86 95       	lsr	r24
    2662:	86 95       	lsr	r24
    2664:	8a 83       	std	Y+2, r24	; 0x02
	u8 pin_num  = pin % 8;
    2666:	8b 81       	ldd	r24, Y+3	; 0x03
    2668:	87 70       	andi	r24, 0x07	; 7
    266a:	89 83       	std	Y+1, r24	; 0x01
	switch(status)
    266c:	8c 81       	ldd	r24, Y+4	; 0x04
    266e:	28 2f       	mov	r18, r24
    2670:	30 e0       	ldi	r19, 0x00	; 0
    2672:	3c 87       	std	Y+12, r19	; 0x0c
    2674:	2b 87       	std	Y+11, r18	; 0x0b
    2676:	8b 85       	ldd	r24, Y+11	; 0x0b
    2678:	9c 85       	ldd	r25, Y+12	; 0x0c
    267a:	81 30       	cpi	r24, 0x01	; 1
    267c:	91 05       	cpc	r25, r1
    267e:	09 f4       	brne	.+2      	; 0x2682 <DIO_InitPin+0x3e>
    2680:	c9 c0       	rjmp	.+402    	; 0x2814 <DIO_InitPin+0x1d0>
    2682:	2b 85       	ldd	r18, Y+11	; 0x0b
    2684:	3c 85       	ldd	r19, Y+12	; 0x0c
    2686:	22 30       	cpi	r18, 0x02	; 2
    2688:	31 05       	cpc	r19, r1
    268a:	09 f4       	brne	.+2      	; 0x268e <DIO_InitPin+0x4a>
    268c:	85 c1       	rjmp	.+778    	; 0x2998 <DIO_InitPin+0x354>
    268e:	8b 85       	ldd	r24, Y+11	; 0x0b
    2690:	9c 85       	ldd	r25, Y+12	; 0x0c
    2692:	00 97       	sbiw	r24, 0x00	; 0
    2694:	09 f0       	breq	.+2      	; 0x2698 <DIO_InitPin+0x54>
    2696:	3d c2       	rjmp	.+1146   	; 0x2b12 <DIO_InitPin+0x4ce>
	{
		case OUTPUT:
		switch(port)
    2698:	8a 81       	ldd	r24, Y+2	; 0x02
    269a:	28 2f       	mov	r18, r24
    269c:	30 e0       	ldi	r19, 0x00	; 0
    269e:	3a 87       	std	Y+10, r19	; 0x0a
    26a0:	29 87       	std	Y+9, r18	; 0x09
    26a2:	89 85       	ldd	r24, Y+9	; 0x09
    26a4:	9a 85       	ldd	r25, Y+10	; 0x0a
    26a6:	81 30       	cpi	r24, 0x01	; 1
    26a8:	91 05       	cpc	r25, r1
    26aa:	09 f4       	brne	.+2      	; 0x26ae <DIO_InitPin+0x6a>
    26ac:	3e c0       	rjmp	.+124    	; 0x272a <DIO_InitPin+0xe6>
    26ae:	29 85       	ldd	r18, Y+9	; 0x09
    26b0:	3a 85       	ldd	r19, Y+10	; 0x0a
    26b2:	22 30       	cpi	r18, 0x02	; 2
    26b4:	31 05       	cpc	r19, r1
    26b6:	2c f4       	brge	.+10     	; 0x26c2 <DIO_InitPin+0x7e>
    26b8:	89 85       	ldd	r24, Y+9	; 0x09
    26ba:	9a 85       	ldd	r25, Y+10	; 0x0a
    26bc:	00 97       	sbiw	r24, 0x00	; 0
    26be:	71 f0       	breq	.+28     	; 0x26dc <DIO_InitPin+0x98>
    26c0:	28 c2       	rjmp	.+1104   	; 0x2b12 <DIO_InitPin+0x4ce>
    26c2:	29 85       	ldd	r18, Y+9	; 0x09
    26c4:	3a 85       	ldd	r19, Y+10	; 0x0a
    26c6:	22 30       	cpi	r18, 0x02	; 2
    26c8:	31 05       	cpc	r19, r1
    26ca:	09 f4       	brne	.+2      	; 0x26ce <DIO_InitPin+0x8a>
    26cc:	55 c0       	rjmp	.+170    	; 0x2778 <DIO_InitPin+0x134>
    26ce:	89 85       	ldd	r24, Y+9	; 0x09
    26d0:	9a 85       	ldd	r25, Y+10	; 0x0a
    26d2:	83 30       	cpi	r24, 0x03	; 3
    26d4:	91 05       	cpc	r25, r1
    26d6:	09 f4       	brne	.+2      	; 0x26da <DIO_InitPin+0x96>
    26d8:	76 c0       	rjmp	.+236    	; 0x27c6 <DIO_InitPin+0x182>
    26da:	1b c2       	rjmp	.+1078   	; 0x2b12 <DIO_InitPin+0x4ce>
		{
			case PA:
			SET_BIT(DDRA_REG , pin_num);
    26dc:	aa e3       	ldi	r26, 0x3A	; 58
    26de:	b0 e0       	ldi	r27, 0x00	; 0
    26e0:	ea e3       	ldi	r30, 0x3A	; 58
    26e2:	f0 e0       	ldi	r31, 0x00	; 0
    26e4:	80 81       	ld	r24, Z
    26e6:	48 2f       	mov	r20, r24
    26e8:	89 81       	ldd	r24, Y+1	; 0x01
    26ea:	28 2f       	mov	r18, r24
    26ec:	30 e0       	ldi	r19, 0x00	; 0
    26ee:	81 e0       	ldi	r24, 0x01	; 1
    26f0:	90 e0       	ldi	r25, 0x00	; 0
    26f2:	02 c0       	rjmp	.+4      	; 0x26f8 <DIO_InitPin+0xb4>
    26f4:	88 0f       	add	r24, r24
    26f6:	99 1f       	adc	r25, r25
    26f8:	2a 95       	dec	r18
    26fa:	e2 f7       	brpl	.-8      	; 0x26f4 <DIO_InitPin+0xb0>
    26fc:	84 2b       	or	r24, r20
    26fe:	8c 93       	st	X, r24
			CLR_BIT(PORTA_REG , pin_num);
    2700:	ab e3       	ldi	r26, 0x3B	; 59
    2702:	b0 e0       	ldi	r27, 0x00	; 0
    2704:	eb e3       	ldi	r30, 0x3B	; 59
    2706:	f0 e0       	ldi	r31, 0x00	; 0
    2708:	80 81       	ld	r24, Z
    270a:	48 2f       	mov	r20, r24
    270c:	89 81       	ldd	r24, Y+1	; 0x01
    270e:	28 2f       	mov	r18, r24
    2710:	30 e0       	ldi	r19, 0x00	; 0
    2712:	81 e0       	ldi	r24, 0x01	; 1
    2714:	90 e0       	ldi	r25, 0x00	; 0
    2716:	02 2e       	mov	r0, r18
    2718:	02 c0       	rjmp	.+4      	; 0x271e <DIO_InitPin+0xda>
    271a:	88 0f       	add	r24, r24
    271c:	99 1f       	adc	r25, r25
    271e:	0a 94       	dec	r0
    2720:	e2 f7       	brpl	.-8      	; 0x271a <DIO_InitPin+0xd6>
    2722:	80 95       	com	r24
    2724:	84 23       	and	r24, r20
    2726:	8c 93       	st	X, r24
    2728:	f4 c1       	rjmp	.+1000   	; 0x2b12 <DIO_InitPin+0x4ce>
			break;
			case PB:
			SET_BIT(DDRB_REG , pin_num);
    272a:	a7 e3       	ldi	r26, 0x37	; 55
    272c:	b0 e0       	ldi	r27, 0x00	; 0
    272e:	e7 e3       	ldi	r30, 0x37	; 55
    2730:	f0 e0       	ldi	r31, 0x00	; 0
    2732:	80 81       	ld	r24, Z
    2734:	48 2f       	mov	r20, r24
    2736:	89 81       	ldd	r24, Y+1	; 0x01
    2738:	28 2f       	mov	r18, r24
    273a:	30 e0       	ldi	r19, 0x00	; 0
    273c:	81 e0       	ldi	r24, 0x01	; 1
    273e:	90 e0       	ldi	r25, 0x00	; 0
    2740:	02 c0       	rjmp	.+4      	; 0x2746 <DIO_InitPin+0x102>
    2742:	88 0f       	add	r24, r24
    2744:	99 1f       	adc	r25, r25
    2746:	2a 95       	dec	r18
    2748:	e2 f7       	brpl	.-8      	; 0x2742 <DIO_InitPin+0xfe>
    274a:	84 2b       	or	r24, r20
    274c:	8c 93       	st	X, r24
			CLR_BIT(PORTB_REG , pin_num);
    274e:	a8 e3       	ldi	r26, 0x38	; 56
    2750:	b0 e0       	ldi	r27, 0x00	; 0
    2752:	e8 e3       	ldi	r30, 0x38	; 56
    2754:	f0 e0       	ldi	r31, 0x00	; 0
    2756:	80 81       	ld	r24, Z
    2758:	48 2f       	mov	r20, r24
    275a:	89 81       	ldd	r24, Y+1	; 0x01
    275c:	28 2f       	mov	r18, r24
    275e:	30 e0       	ldi	r19, 0x00	; 0
    2760:	81 e0       	ldi	r24, 0x01	; 1
    2762:	90 e0       	ldi	r25, 0x00	; 0
    2764:	02 2e       	mov	r0, r18
    2766:	02 c0       	rjmp	.+4      	; 0x276c <DIO_InitPin+0x128>
    2768:	88 0f       	add	r24, r24
    276a:	99 1f       	adc	r25, r25
    276c:	0a 94       	dec	r0
    276e:	e2 f7       	brpl	.-8      	; 0x2768 <DIO_InitPin+0x124>
    2770:	80 95       	com	r24
    2772:	84 23       	and	r24, r20
    2774:	8c 93       	st	X, r24
    2776:	cd c1       	rjmp	.+922    	; 0x2b12 <DIO_InitPin+0x4ce>
			break;
			case PC:
			SET_BIT(DDRC_REG , pin_num);
    2778:	a4 e3       	ldi	r26, 0x34	; 52
    277a:	b0 e0       	ldi	r27, 0x00	; 0
    277c:	e4 e3       	ldi	r30, 0x34	; 52
    277e:	f0 e0       	ldi	r31, 0x00	; 0
    2780:	80 81       	ld	r24, Z
    2782:	48 2f       	mov	r20, r24
    2784:	89 81       	ldd	r24, Y+1	; 0x01
    2786:	28 2f       	mov	r18, r24
    2788:	30 e0       	ldi	r19, 0x00	; 0
    278a:	81 e0       	ldi	r24, 0x01	; 1
    278c:	90 e0       	ldi	r25, 0x00	; 0
    278e:	02 c0       	rjmp	.+4      	; 0x2794 <DIO_InitPin+0x150>
    2790:	88 0f       	add	r24, r24
    2792:	99 1f       	adc	r25, r25
    2794:	2a 95       	dec	r18
    2796:	e2 f7       	brpl	.-8      	; 0x2790 <DIO_InitPin+0x14c>
    2798:	84 2b       	or	r24, r20
    279a:	8c 93       	st	X, r24
			CLR_BIT(PORTC_REG , pin_num);
    279c:	a5 e3       	ldi	r26, 0x35	; 53
    279e:	b0 e0       	ldi	r27, 0x00	; 0
    27a0:	e5 e3       	ldi	r30, 0x35	; 53
    27a2:	f0 e0       	ldi	r31, 0x00	; 0
    27a4:	80 81       	ld	r24, Z
    27a6:	48 2f       	mov	r20, r24
    27a8:	89 81       	ldd	r24, Y+1	; 0x01
    27aa:	28 2f       	mov	r18, r24
    27ac:	30 e0       	ldi	r19, 0x00	; 0
    27ae:	81 e0       	ldi	r24, 0x01	; 1
    27b0:	90 e0       	ldi	r25, 0x00	; 0
    27b2:	02 2e       	mov	r0, r18
    27b4:	02 c0       	rjmp	.+4      	; 0x27ba <DIO_InitPin+0x176>
    27b6:	88 0f       	add	r24, r24
    27b8:	99 1f       	adc	r25, r25
    27ba:	0a 94       	dec	r0
    27bc:	e2 f7       	brpl	.-8      	; 0x27b6 <DIO_InitPin+0x172>
    27be:	80 95       	com	r24
    27c0:	84 23       	and	r24, r20
    27c2:	8c 93       	st	X, r24
    27c4:	a6 c1       	rjmp	.+844    	; 0x2b12 <DIO_InitPin+0x4ce>
			break;
			case PD:
			SET_BIT(DDRD_REG , pin_num);
    27c6:	a1 e3       	ldi	r26, 0x31	; 49
    27c8:	b0 e0       	ldi	r27, 0x00	; 0
    27ca:	e1 e3       	ldi	r30, 0x31	; 49
    27cc:	f0 e0       	ldi	r31, 0x00	; 0
    27ce:	80 81       	ld	r24, Z
    27d0:	48 2f       	mov	r20, r24
    27d2:	89 81       	ldd	r24, Y+1	; 0x01
    27d4:	28 2f       	mov	r18, r24
    27d6:	30 e0       	ldi	r19, 0x00	; 0
    27d8:	81 e0       	ldi	r24, 0x01	; 1
    27da:	90 e0       	ldi	r25, 0x00	; 0
    27dc:	02 c0       	rjmp	.+4      	; 0x27e2 <DIO_InitPin+0x19e>
    27de:	88 0f       	add	r24, r24
    27e0:	99 1f       	adc	r25, r25
    27e2:	2a 95       	dec	r18
    27e4:	e2 f7       	brpl	.-8      	; 0x27de <DIO_InitPin+0x19a>
    27e6:	84 2b       	or	r24, r20
    27e8:	8c 93       	st	X, r24
			CLR_BIT(PORTD_REG , pin_num);
    27ea:	a2 e3       	ldi	r26, 0x32	; 50
    27ec:	b0 e0       	ldi	r27, 0x00	; 0
    27ee:	e2 e3       	ldi	r30, 0x32	; 50
    27f0:	f0 e0       	ldi	r31, 0x00	; 0
    27f2:	80 81       	ld	r24, Z
    27f4:	48 2f       	mov	r20, r24
    27f6:	89 81       	ldd	r24, Y+1	; 0x01
    27f8:	28 2f       	mov	r18, r24
    27fa:	30 e0       	ldi	r19, 0x00	; 0
    27fc:	81 e0       	ldi	r24, 0x01	; 1
    27fe:	90 e0       	ldi	r25, 0x00	; 0
    2800:	02 2e       	mov	r0, r18
    2802:	02 c0       	rjmp	.+4      	; 0x2808 <DIO_InitPin+0x1c4>
    2804:	88 0f       	add	r24, r24
    2806:	99 1f       	adc	r25, r25
    2808:	0a 94       	dec	r0
    280a:	e2 f7       	brpl	.-8      	; 0x2804 <DIO_InitPin+0x1c0>
    280c:	80 95       	com	r24
    280e:	84 23       	and	r24, r20
    2810:	8c 93       	st	X, r24
    2812:	7f c1       	rjmp	.+766    	; 0x2b12 <DIO_InitPin+0x4ce>
			break;
		}
		break;
		case INFREE:
		switch(port)
    2814:	8a 81       	ldd	r24, Y+2	; 0x02
    2816:	28 2f       	mov	r18, r24
    2818:	30 e0       	ldi	r19, 0x00	; 0
    281a:	38 87       	std	Y+8, r19	; 0x08
    281c:	2f 83       	std	Y+7, r18	; 0x07
    281e:	8f 81       	ldd	r24, Y+7	; 0x07
    2820:	98 85       	ldd	r25, Y+8	; 0x08
    2822:	81 30       	cpi	r24, 0x01	; 1
    2824:	91 05       	cpc	r25, r1
    2826:	09 f4       	brne	.+2      	; 0x282a <DIO_InitPin+0x1e6>
    2828:	3f c0       	rjmp	.+126    	; 0x28a8 <DIO_InitPin+0x264>
    282a:	2f 81       	ldd	r18, Y+7	; 0x07
    282c:	38 85       	ldd	r19, Y+8	; 0x08
    282e:	22 30       	cpi	r18, 0x02	; 2
    2830:	31 05       	cpc	r19, r1
    2832:	2c f4       	brge	.+10     	; 0x283e <DIO_InitPin+0x1fa>
    2834:	8f 81       	ldd	r24, Y+7	; 0x07
    2836:	98 85       	ldd	r25, Y+8	; 0x08
    2838:	00 97       	sbiw	r24, 0x00	; 0
    283a:	71 f0       	breq	.+28     	; 0x2858 <DIO_InitPin+0x214>
    283c:	6a c1       	rjmp	.+724    	; 0x2b12 <DIO_InitPin+0x4ce>
    283e:	2f 81       	ldd	r18, Y+7	; 0x07
    2840:	38 85       	ldd	r19, Y+8	; 0x08
    2842:	22 30       	cpi	r18, 0x02	; 2
    2844:	31 05       	cpc	r19, r1
    2846:	09 f4       	brne	.+2      	; 0x284a <DIO_InitPin+0x206>
    2848:	57 c0       	rjmp	.+174    	; 0x28f8 <DIO_InitPin+0x2b4>
    284a:	8f 81       	ldd	r24, Y+7	; 0x07
    284c:	98 85       	ldd	r25, Y+8	; 0x08
    284e:	83 30       	cpi	r24, 0x03	; 3
    2850:	91 05       	cpc	r25, r1
    2852:	09 f4       	brne	.+2      	; 0x2856 <DIO_InitPin+0x212>
    2854:	79 c0       	rjmp	.+242    	; 0x2948 <DIO_InitPin+0x304>
    2856:	5d c1       	rjmp	.+698    	; 0x2b12 <DIO_InitPin+0x4ce>
		{
			case PA:
			CLR_BIT(DDRA_REG , pin_num);
    2858:	aa e3       	ldi	r26, 0x3A	; 58
    285a:	b0 e0       	ldi	r27, 0x00	; 0
    285c:	ea e3       	ldi	r30, 0x3A	; 58
    285e:	f0 e0       	ldi	r31, 0x00	; 0
    2860:	80 81       	ld	r24, Z
    2862:	48 2f       	mov	r20, r24
    2864:	89 81       	ldd	r24, Y+1	; 0x01
    2866:	28 2f       	mov	r18, r24
    2868:	30 e0       	ldi	r19, 0x00	; 0
    286a:	81 e0       	ldi	r24, 0x01	; 1
    286c:	90 e0       	ldi	r25, 0x00	; 0
    286e:	02 c0       	rjmp	.+4      	; 0x2874 <DIO_InitPin+0x230>
    2870:	88 0f       	add	r24, r24
    2872:	99 1f       	adc	r25, r25
    2874:	2a 95       	dec	r18
    2876:	e2 f7       	brpl	.-8      	; 0x2870 <DIO_InitPin+0x22c>
    2878:	80 95       	com	r24
    287a:	84 23       	and	r24, r20
    287c:	8c 93       	st	X, r24
			CLR_BIT(PORTA_REG , pin_num);
    287e:	ab e3       	ldi	r26, 0x3B	; 59
    2880:	b0 e0       	ldi	r27, 0x00	; 0
    2882:	eb e3       	ldi	r30, 0x3B	; 59
    2884:	f0 e0       	ldi	r31, 0x00	; 0
    2886:	80 81       	ld	r24, Z
    2888:	48 2f       	mov	r20, r24
    288a:	89 81       	ldd	r24, Y+1	; 0x01
    288c:	28 2f       	mov	r18, r24
    288e:	30 e0       	ldi	r19, 0x00	; 0
    2890:	81 e0       	ldi	r24, 0x01	; 1
    2892:	90 e0       	ldi	r25, 0x00	; 0
    2894:	02 2e       	mov	r0, r18
    2896:	02 c0       	rjmp	.+4      	; 0x289c <DIO_InitPin+0x258>
    2898:	88 0f       	add	r24, r24
    289a:	99 1f       	adc	r25, r25
    289c:	0a 94       	dec	r0
    289e:	e2 f7       	brpl	.-8      	; 0x2898 <DIO_InitPin+0x254>
    28a0:	80 95       	com	r24
    28a2:	84 23       	and	r24, r20
    28a4:	8c 93       	st	X, r24
    28a6:	35 c1       	rjmp	.+618    	; 0x2b12 <DIO_InitPin+0x4ce>
			break;
			case PB:
			CLR_BIT(DDRB_REG , pin_num);
    28a8:	a7 e3       	ldi	r26, 0x37	; 55
    28aa:	b0 e0       	ldi	r27, 0x00	; 0
    28ac:	e7 e3       	ldi	r30, 0x37	; 55
    28ae:	f0 e0       	ldi	r31, 0x00	; 0
    28b0:	80 81       	ld	r24, Z
    28b2:	48 2f       	mov	r20, r24
    28b4:	89 81       	ldd	r24, Y+1	; 0x01
    28b6:	28 2f       	mov	r18, r24
    28b8:	30 e0       	ldi	r19, 0x00	; 0
    28ba:	81 e0       	ldi	r24, 0x01	; 1
    28bc:	90 e0       	ldi	r25, 0x00	; 0
    28be:	02 c0       	rjmp	.+4      	; 0x28c4 <DIO_InitPin+0x280>
    28c0:	88 0f       	add	r24, r24
    28c2:	99 1f       	adc	r25, r25
    28c4:	2a 95       	dec	r18
    28c6:	e2 f7       	brpl	.-8      	; 0x28c0 <DIO_InitPin+0x27c>
    28c8:	80 95       	com	r24
    28ca:	84 23       	and	r24, r20
    28cc:	8c 93       	st	X, r24
			CLR_BIT(PORTB_REG , pin_num);
    28ce:	a8 e3       	ldi	r26, 0x38	; 56
    28d0:	b0 e0       	ldi	r27, 0x00	; 0
    28d2:	e8 e3       	ldi	r30, 0x38	; 56
    28d4:	f0 e0       	ldi	r31, 0x00	; 0
    28d6:	80 81       	ld	r24, Z
    28d8:	48 2f       	mov	r20, r24
    28da:	89 81       	ldd	r24, Y+1	; 0x01
    28dc:	28 2f       	mov	r18, r24
    28de:	30 e0       	ldi	r19, 0x00	; 0
    28e0:	81 e0       	ldi	r24, 0x01	; 1
    28e2:	90 e0       	ldi	r25, 0x00	; 0
    28e4:	02 2e       	mov	r0, r18
    28e6:	02 c0       	rjmp	.+4      	; 0x28ec <DIO_InitPin+0x2a8>
    28e8:	88 0f       	add	r24, r24
    28ea:	99 1f       	adc	r25, r25
    28ec:	0a 94       	dec	r0
    28ee:	e2 f7       	brpl	.-8      	; 0x28e8 <DIO_InitPin+0x2a4>
    28f0:	80 95       	com	r24
    28f2:	84 23       	and	r24, r20
    28f4:	8c 93       	st	X, r24
    28f6:	0d c1       	rjmp	.+538    	; 0x2b12 <DIO_InitPin+0x4ce>
			break;
			case PC:
			CLR_BIT(DDRC_REG , pin_num);
    28f8:	a4 e3       	ldi	r26, 0x34	; 52
    28fa:	b0 e0       	ldi	r27, 0x00	; 0
    28fc:	e4 e3       	ldi	r30, 0x34	; 52
    28fe:	f0 e0       	ldi	r31, 0x00	; 0
    2900:	80 81       	ld	r24, Z
    2902:	48 2f       	mov	r20, r24
    2904:	89 81       	ldd	r24, Y+1	; 0x01
    2906:	28 2f       	mov	r18, r24
    2908:	30 e0       	ldi	r19, 0x00	; 0
    290a:	81 e0       	ldi	r24, 0x01	; 1
    290c:	90 e0       	ldi	r25, 0x00	; 0
    290e:	02 c0       	rjmp	.+4      	; 0x2914 <DIO_InitPin+0x2d0>
    2910:	88 0f       	add	r24, r24
    2912:	99 1f       	adc	r25, r25
    2914:	2a 95       	dec	r18
    2916:	e2 f7       	brpl	.-8      	; 0x2910 <DIO_InitPin+0x2cc>
    2918:	80 95       	com	r24
    291a:	84 23       	and	r24, r20
    291c:	8c 93       	st	X, r24
			CLR_BIT(PORTC_REG , pin_num);
    291e:	a5 e3       	ldi	r26, 0x35	; 53
    2920:	b0 e0       	ldi	r27, 0x00	; 0
    2922:	e5 e3       	ldi	r30, 0x35	; 53
    2924:	f0 e0       	ldi	r31, 0x00	; 0
    2926:	80 81       	ld	r24, Z
    2928:	48 2f       	mov	r20, r24
    292a:	89 81       	ldd	r24, Y+1	; 0x01
    292c:	28 2f       	mov	r18, r24
    292e:	30 e0       	ldi	r19, 0x00	; 0
    2930:	81 e0       	ldi	r24, 0x01	; 1
    2932:	90 e0       	ldi	r25, 0x00	; 0
    2934:	02 2e       	mov	r0, r18
    2936:	02 c0       	rjmp	.+4      	; 0x293c <DIO_InitPin+0x2f8>
    2938:	88 0f       	add	r24, r24
    293a:	99 1f       	adc	r25, r25
    293c:	0a 94       	dec	r0
    293e:	e2 f7       	brpl	.-8      	; 0x2938 <DIO_InitPin+0x2f4>
    2940:	80 95       	com	r24
    2942:	84 23       	and	r24, r20
    2944:	8c 93       	st	X, r24
    2946:	e5 c0       	rjmp	.+458    	; 0x2b12 <DIO_InitPin+0x4ce>
			break;
			case PD:
			CLR_BIT(DDRD_REG , pin_num);
    2948:	a1 e3       	ldi	r26, 0x31	; 49
    294a:	b0 e0       	ldi	r27, 0x00	; 0
    294c:	e1 e3       	ldi	r30, 0x31	; 49
    294e:	f0 e0       	ldi	r31, 0x00	; 0
    2950:	80 81       	ld	r24, Z
    2952:	48 2f       	mov	r20, r24
    2954:	89 81       	ldd	r24, Y+1	; 0x01
    2956:	28 2f       	mov	r18, r24
    2958:	30 e0       	ldi	r19, 0x00	; 0
    295a:	81 e0       	ldi	r24, 0x01	; 1
    295c:	90 e0       	ldi	r25, 0x00	; 0
    295e:	02 c0       	rjmp	.+4      	; 0x2964 <DIO_InitPin+0x320>
    2960:	88 0f       	add	r24, r24
    2962:	99 1f       	adc	r25, r25
    2964:	2a 95       	dec	r18
    2966:	e2 f7       	brpl	.-8      	; 0x2960 <DIO_InitPin+0x31c>
    2968:	80 95       	com	r24
    296a:	84 23       	and	r24, r20
    296c:	8c 93       	st	X, r24
			CLR_BIT(PORTD_REG , pin_num);
    296e:	a2 e3       	ldi	r26, 0x32	; 50
    2970:	b0 e0       	ldi	r27, 0x00	; 0
    2972:	e2 e3       	ldi	r30, 0x32	; 50
    2974:	f0 e0       	ldi	r31, 0x00	; 0
    2976:	80 81       	ld	r24, Z
    2978:	48 2f       	mov	r20, r24
    297a:	89 81       	ldd	r24, Y+1	; 0x01
    297c:	28 2f       	mov	r18, r24
    297e:	30 e0       	ldi	r19, 0x00	; 0
    2980:	81 e0       	ldi	r24, 0x01	; 1
    2982:	90 e0       	ldi	r25, 0x00	; 0
    2984:	02 2e       	mov	r0, r18
    2986:	02 c0       	rjmp	.+4      	; 0x298c <DIO_InitPin+0x348>
    2988:	88 0f       	add	r24, r24
    298a:	99 1f       	adc	r25, r25
    298c:	0a 94       	dec	r0
    298e:	e2 f7       	brpl	.-8      	; 0x2988 <DIO_InitPin+0x344>
    2990:	80 95       	com	r24
    2992:	84 23       	and	r24, r20
    2994:	8c 93       	st	X, r24
    2996:	bd c0       	rjmp	.+378    	; 0x2b12 <DIO_InitPin+0x4ce>
			break;
		}
		break;
		case INPULLUP:
		switch(port)
    2998:	8a 81       	ldd	r24, Y+2	; 0x02
    299a:	28 2f       	mov	r18, r24
    299c:	30 e0       	ldi	r19, 0x00	; 0
    299e:	3e 83       	std	Y+6, r19	; 0x06
    29a0:	2d 83       	std	Y+5, r18	; 0x05
    29a2:	8d 81       	ldd	r24, Y+5	; 0x05
    29a4:	9e 81       	ldd	r25, Y+6	; 0x06
    29a6:	81 30       	cpi	r24, 0x01	; 1
    29a8:	91 05       	cpc	r25, r1
    29aa:	09 f4       	brne	.+2      	; 0x29ae <DIO_InitPin+0x36a>
    29ac:	3e c0       	rjmp	.+124    	; 0x2a2a <DIO_InitPin+0x3e6>
    29ae:	2d 81       	ldd	r18, Y+5	; 0x05
    29b0:	3e 81       	ldd	r19, Y+6	; 0x06
    29b2:	22 30       	cpi	r18, 0x02	; 2
    29b4:	31 05       	cpc	r19, r1
    29b6:	2c f4       	brge	.+10     	; 0x29c2 <DIO_InitPin+0x37e>
    29b8:	8d 81       	ldd	r24, Y+5	; 0x05
    29ba:	9e 81       	ldd	r25, Y+6	; 0x06
    29bc:	00 97       	sbiw	r24, 0x00	; 0
    29be:	71 f0       	breq	.+28     	; 0x29dc <DIO_InitPin+0x398>
    29c0:	a8 c0       	rjmp	.+336    	; 0x2b12 <DIO_InitPin+0x4ce>
    29c2:	2d 81       	ldd	r18, Y+5	; 0x05
    29c4:	3e 81       	ldd	r19, Y+6	; 0x06
    29c6:	22 30       	cpi	r18, 0x02	; 2
    29c8:	31 05       	cpc	r19, r1
    29ca:	09 f4       	brne	.+2      	; 0x29ce <DIO_InitPin+0x38a>
    29cc:	55 c0       	rjmp	.+170    	; 0x2a78 <DIO_InitPin+0x434>
    29ce:	8d 81       	ldd	r24, Y+5	; 0x05
    29d0:	9e 81       	ldd	r25, Y+6	; 0x06
    29d2:	83 30       	cpi	r24, 0x03	; 3
    29d4:	91 05       	cpc	r25, r1
    29d6:	09 f4       	brne	.+2      	; 0x29da <DIO_InitPin+0x396>
    29d8:	76 c0       	rjmp	.+236    	; 0x2ac6 <DIO_InitPin+0x482>
    29da:	9b c0       	rjmp	.+310    	; 0x2b12 <DIO_InitPin+0x4ce>
		{
			case PA:
			CLR_BIT(DDRA_REG , pin_num);
    29dc:	aa e3       	ldi	r26, 0x3A	; 58
    29de:	b0 e0       	ldi	r27, 0x00	; 0
    29e0:	ea e3       	ldi	r30, 0x3A	; 58
    29e2:	f0 e0       	ldi	r31, 0x00	; 0
    29e4:	80 81       	ld	r24, Z
    29e6:	48 2f       	mov	r20, r24
    29e8:	89 81       	ldd	r24, Y+1	; 0x01
    29ea:	28 2f       	mov	r18, r24
    29ec:	30 e0       	ldi	r19, 0x00	; 0
    29ee:	81 e0       	ldi	r24, 0x01	; 1
    29f0:	90 e0       	ldi	r25, 0x00	; 0
    29f2:	02 c0       	rjmp	.+4      	; 0x29f8 <DIO_InitPin+0x3b4>
    29f4:	88 0f       	add	r24, r24
    29f6:	99 1f       	adc	r25, r25
    29f8:	2a 95       	dec	r18
    29fa:	e2 f7       	brpl	.-8      	; 0x29f4 <DIO_InitPin+0x3b0>
    29fc:	80 95       	com	r24
    29fe:	84 23       	and	r24, r20
    2a00:	8c 93       	st	X, r24
			SET_BIT(PORTA_REG , pin_num);
    2a02:	ab e3       	ldi	r26, 0x3B	; 59
    2a04:	b0 e0       	ldi	r27, 0x00	; 0
    2a06:	eb e3       	ldi	r30, 0x3B	; 59
    2a08:	f0 e0       	ldi	r31, 0x00	; 0
    2a0a:	80 81       	ld	r24, Z
    2a0c:	48 2f       	mov	r20, r24
    2a0e:	89 81       	ldd	r24, Y+1	; 0x01
    2a10:	28 2f       	mov	r18, r24
    2a12:	30 e0       	ldi	r19, 0x00	; 0
    2a14:	81 e0       	ldi	r24, 0x01	; 1
    2a16:	90 e0       	ldi	r25, 0x00	; 0
    2a18:	02 2e       	mov	r0, r18
    2a1a:	02 c0       	rjmp	.+4      	; 0x2a20 <DIO_InitPin+0x3dc>
    2a1c:	88 0f       	add	r24, r24
    2a1e:	99 1f       	adc	r25, r25
    2a20:	0a 94       	dec	r0
    2a22:	e2 f7       	brpl	.-8      	; 0x2a1c <DIO_InitPin+0x3d8>
    2a24:	84 2b       	or	r24, r20
    2a26:	8c 93       	st	X, r24
    2a28:	74 c0       	rjmp	.+232    	; 0x2b12 <DIO_InitPin+0x4ce>
			break;
			case PB:
			CLR_BIT(DDRB_REG , pin_num);
    2a2a:	a7 e3       	ldi	r26, 0x37	; 55
    2a2c:	b0 e0       	ldi	r27, 0x00	; 0
    2a2e:	e7 e3       	ldi	r30, 0x37	; 55
    2a30:	f0 e0       	ldi	r31, 0x00	; 0
    2a32:	80 81       	ld	r24, Z
    2a34:	48 2f       	mov	r20, r24
    2a36:	89 81       	ldd	r24, Y+1	; 0x01
    2a38:	28 2f       	mov	r18, r24
    2a3a:	30 e0       	ldi	r19, 0x00	; 0
    2a3c:	81 e0       	ldi	r24, 0x01	; 1
    2a3e:	90 e0       	ldi	r25, 0x00	; 0
    2a40:	02 c0       	rjmp	.+4      	; 0x2a46 <DIO_InitPin+0x402>
    2a42:	88 0f       	add	r24, r24
    2a44:	99 1f       	adc	r25, r25
    2a46:	2a 95       	dec	r18
    2a48:	e2 f7       	brpl	.-8      	; 0x2a42 <DIO_InitPin+0x3fe>
    2a4a:	80 95       	com	r24
    2a4c:	84 23       	and	r24, r20
    2a4e:	8c 93       	st	X, r24
			SET_BIT(PORTB_REG , pin_num);
    2a50:	a8 e3       	ldi	r26, 0x38	; 56
    2a52:	b0 e0       	ldi	r27, 0x00	; 0
    2a54:	e8 e3       	ldi	r30, 0x38	; 56
    2a56:	f0 e0       	ldi	r31, 0x00	; 0
    2a58:	80 81       	ld	r24, Z
    2a5a:	48 2f       	mov	r20, r24
    2a5c:	89 81       	ldd	r24, Y+1	; 0x01
    2a5e:	28 2f       	mov	r18, r24
    2a60:	30 e0       	ldi	r19, 0x00	; 0
    2a62:	81 e0       	ldi	r24, 0x01	; 1
    2a64:	90 e0       	ldi	r25, 0x00	; 0
    2a66:	02 2e       	mov	r0, r18
    2a68:	02 c0       	rjmp	.+4      	; 0x2a6e <DIO_InitPin+0x42a>
    2a6a:	88 0f       	add	r24, r24
    2a6c:	99 1f       	adc	r25, r25
    2a6e:	0a 94       	dec	r0
    2a70:	e2 f7       	brpl	.-8      	; 0x2a6a <DIO_InitPin+0x426>
    2a72:	84 2b       	or	r24, r20
    2a74:	8c 93       	st	X, r24
    2a76:	4d c0       	rjmp	.+154    	; 0x2b12 <DIO_InitPin+0x4ce>
			break;
			case PC:
			CLR_BIT(DDRC_REG , pin_num);
    2a78:	a4 e3       	ldi	r26, 0x34	; 52
    2a7a:	b0 e0       	ldi	r27, 0x00	; 0
    2a7c:	e4 e3       	ldi	r30, 0x34	; 52
    2a7e:	f0 e0       	ldi	r31, 0x00	; 0
    2a80:	80 81       	ld	r24, Z
    2a82:	48 2f       	mov	r20, r24
    2a84:	89 81       	ldd	r24, Y+1	; 0x01
    2a86:	28 2f       	mov	r18, r24
    2a88:	30 e0       	ldi	r19, 0x00	; 0
    2a8a:	81 e0       	ldi	r24, 0x01	; 1
    2a8c:	90 e0       	ldi	r25, 0x00	; 0
    2a8e:	02 c0       	rjmp	.+4      	; 0x2a94 <DIO_InitPin+0x450>
    2a90:	88 0f       	add	r24, r24
    2a92:	99 1f       	adc	r25, r25
    2a94:	2a 95       	dec	r18
    2a96:	e2 f7       	brpl	.-8      	; 0x2a90 <DIO_InitPin+0x44c>
    2a98:	80 95       	com	r24
    2a9a:	84 23       	and	r24, r20
    2a9c:	8c 93       	st	X, r24
			SET_BIT(PORTC_REG , pin_num);
    2a9e:	a5 e3       	ldi	r26, 0x35	; 53
    2aa0:	b0 e0       	ldi	r27, 0x00	; 0
    2aa2:	e5 e3       	ldi	r30, 0x35	; 53
    2aa4:	f0 e0       	ldi	r31, 0x00	; 0
    2aa6:	80 81       	ld	r24, Z
    2aa8:	48 2f       	mov	r20, r24
    2aaa:	89 81       	ldd	r24, Y+1	; 0x01
    2aac:	28 2f       	mov	r18, r24
    2aae:	30 e0       	ldi	r19, 0x00	; 0
    2ab0:	81 e0       	ldi	r24, 0x01	; 1
    2ab2:	90 e0       	ldi	r25, 0x00	; 0
    2ab4:	02 2e       	mov	r0, r18
    2ab6:	02 c0       	rjmp	.+4      	; 0x2abc <DIO_InitPin+0x478>
    2ab8:	88 0f       	add	r24, r24
    2aba:	99 1f       	adc	r25, r25
    2abc:	0a 94       	dec	r0
    2abe:	e2 f7       	brpl	.-8      	; 0x2ab8 <DIO_InitPin+0x474>
    2ac0:	84 2b       	or	r24, r20
    2ac2:	8c 93       	st	X, r24
    2ac4:	26 c0       	rjmp	.+76     	; 0x2b12 <DIO_InitPin+0x4ce>
			break;
			case PD:
			CLR_BIT(DDRD_REG , pin_num);
    2ac6:	a1 e3       	ldi	r26, 0x31	; 49
    2ac8:	b0 e0       	ldi	r27, 0x00	; 0
    2aca:	e1 e3       	ldi	r30, 0x31	; 49
    2acc:	f0 e0       	ldi	r31, 0x00	; 0
    2ace:	80 81       	ld	r24, Z
    2ad0:	48 2f       	mov	r20, r24
    2ad2:	89 81       	ldd	r24, Y+1	; 0x01
    2ad4:	28 2f       	mov	r18, r24
    2ad6:	30 e0       	ldi	r19, 0x00	; 0
    2ad8:	81 e0       	ldi	r24, 0x01	; 1
    2ada:	90 e0       	ldi	r25, 0x00	; 0
    2adc:	02 c0       	rjmp	.+4      	; 0x2ae2 <DIO_InitPin+0x49e>
    2ade:	88 0f       	add	r24, r24
    2ae0:	99 1f       	adc	r25, r25
    2ae2:	2a 95       	dec	r18
    2ae4:	e2 f7       	brpl	.-8      	; 0x2ade <DIO_InitPin+0x49a>
    2ae6:	80 95       	com	r24
    2ae8:	84 23       	and	r24, r20
    2aea:	8c 93       	st	X, r24
			SET_BIT(PORTD_REG , pin_num);
    2aec:	a2 e3       	ldi	r26, 0x32	; 50
    2aee:	b0 e0       	ldi	r27, 0x00	; 0
    2af0:	e2 e3       	ldi	r30, 0x32	; 50
    2af2:	f0 e0       	ldi	r31, 0x00	; 0
    2af4:	80 81       	ld	r24, Z
    2af6:	48 2f       	mov	r20, r24
    2af8:	89 81       	ldd	r24, Y+1	; 0x01
    2afa:	28 2f       	mov	r18, r24
    2afc:	30 e0       	ldi	r19, 0x00	; 0
    2afe:	81 e0       	ldi	r24, 0x01	; 1
    2b00:	90 e0       	ldi	r25, 0x00	; 0
    2b02:	02 2e       	mov	r0, r18
    2b04:	02 c0       	rjmp	.+4      	; 0x2b0a <DIO_InitPin+0x4c6>
    2b06:	88 0f       	add	r24, r24
    2b08:	99 1f       	adc	r25, r25
    2b0a:	0a 94       	dec	r0
    2b0c:	e2 f7       	brpl	.-8      	; 0x2b06 <DIO_InitPin+0x4c2>
    2b0e:	84 2b       	or	r24, r20
    2b10:	8c 93       	st	X, r24
			break;
		}
		break;
	}
}
    2b12:	2c 96       	adiw	r28, 0x0c	; 12
    2b14:	0f b6       	in	r0, 0x3f	; 63
    2b16:	f8 94       	cli
    2b18:	de bf       	out	0x3e, r29	; 62
    2b1a:	0f be       	out	0x3f, r0	; 63
    2b1c:	cd bf       	out	0x3d, r28	; 61
    2b1e:	cf 91       	pop	r28
    2b20:	df 91       	pop	r29
    2b22:	08 95       	ret

00002b24 <DIO_WritePin>:

void DIO_WritePin(DIO_Pin_type pin, DIO_PinVoltage_type volt)
{
    2b24:	df 93       	push	r29
    2b26:	cf 93       	push	r28
    2b28:	cd b7       	in	r28, 0x3d	; 61
    2b2a:	de b7       	in	r29, 0x3e	; 62
    2b2c:	28 97       	sbiw	r28, 0x08	; 8
    2b2e:	0f b6       	in	r0, 0x3f	; 63
    2b30:	f8 94       	cli
    2b32:	de bf       	out	0x3e, r29	; 62
    2b34:	0f be       	out	0x3f, r0	; 63
    2b36:	cd bf       	out	0x3d, r28	; 61
    2b38:	8b 83       	std	Y+3, r24	; 0x03
    2b3a:	6c 83       	std	Y+4, r22	; 0x04
	DIO_Port_type port = pin/8;
    2b3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b3e:	86 95       	lsr	r24
    2b40:	86 95       	lsr	r24
    2b42:	86 95       	lsr	r24
    2b44:	8a 83       	std	Y+2, r24	; 0x02
	u8 pin_num  = pin % 8;
    2b46:	8b 81       	ldd	r24, Y+3	; 0x03
    2b48:	87 70       	andi	r24, 0x07	; 7
    2b4a:	89 83       	std	Y+1, r24	; 0x01
	
	if (volt == LOW)
    2b4c:	8c 81       	ldd	r24, Y+4	; 0x04
    2b4e:	88 23       	and	r24, r24
    2b50:	09 f0       	breq	.+2      	; 0x2b54 <DIO_WritePin+0x30>
    2b52:	74 c0       	rjmp	.+232    	; 0x2c3c <DIO_WritePin+0x118>
	{
		switch(port)
    2b54:	8a 81       	ldd	r24, Y+2	; 0x02
    2b56:	28 2f       	mov	r18, r24
    2b58:	30 e0       	ldi	r19, 0x00	; 0
    2b5a:	38 87       	std	Y+8, r19	; 0x08
    2b5c:	2f 83       	std	Y+7, r18	; 0x07
    2b5e:	8f 81       	ldd	r24, Y+7	; 0x07
    2b60:	98 85       	ldd	r25, Y+8	; 0x08
    2b62:	81 30       	cpi	r24, 0x01	; 1
    2b64:	91 05       	cpc	r25, r1
    2b66:	59 f1       	breq	.+86     	; 0x2bbe <DIO_WritePin+0x9a>
    2b68:	2f 81       	ldd	r18, Y+7	; 0x07
    2b6a:	38 85       	ldd	r19, Y+8	; 0x08
    2b6c:	22 30       	cpi	r18, 0x02	; 2
    2b6e:	31 05       	cpc	r19, r1
    2b70:	2c f4       	brge	.+10     	; 0x2b7c <DIO_WritePin+0x58>
    2b72:	8f 81       	ldd	r24, Y+7	; 0x07
    2b74:	98 85       	ldd	r25, Y+8	; 0x08
    2b76:	00 97       	sbiw	r24, 0x00	; 0
    2b78:	69 f0       	breq	.+26     	; 0x2b94 <DIO_WritePin+0x70>
    2b7a:	d2 c0       	rjmp	.+420    	; 0x2d20 <DIO_WritePin+0x1fc>
    2b7c:	2f 81       	ldd	r18, Y+7	; 0x07
    2b7e:	38 85       	ldd	r19, Y+8	; 0x08
    2b80:	22 30       	cpi	r18, 0x02	; 2
    2b82:	31 05       	cpc	r19, r1
    2b84:	89 f1       	breq	.+98     	; 0x2be8 <DIO_WritePin+0xc4>
    2b86:	8f 81       	ldd	r24, Y+7	; 0x07
    2b88:	98 85       	ldd	r25, Y+8	; 0x08
    2b8a:	83 30       	cpi	r24, 0x03	; 3
    2b8c:	91 05       	cpc	r25, r1
    2b8e:	09 f4       	brne	.+2      	; 0x2b92 <DIO_WritePin+0x6e>
    2b90:	40 c0       	rjmp	.+128    	; 0x2c12 <DIO_WritePin+0xee>
    2b92:	c6 c0       	rjmp	.+396    	; 0x2d20 <DIO_WritePin+0x1fc>
		{
			case PA:
			CLR_BIT(PORTA_REG,pin_num);
    2b94:	ab e3       	ldi	r26, 0x3B	; 59
    2b96:	b0 e0       	ldi	r27, 0x00	; 0
    2b98:	eb e3       	ldi	r30, 0x3B	; 59
    2b9a:	f0 e0       	ldi	r31, 0x00	; 0
    2b9c:	80 81       	ld	r24, Z
    2b9e:	48 2f       	mov	r20, r24
    2ba0:	89 81       	ldd	r24, Y+1	; 0x01
    2ba2:	28 2f       	mov	r18, r24
    2ba4:	30 e0       	ldi	r19, 0x00	; 0
    2ba6:	81 e0       	ldi	r24, 0x01	; 1
    2ba8:	90 e0       	ldi	r25, 0x00	; 0
    2baa:	02 2e       	mov	r0, r18
    2bac:	02 c0       	rjmp	.+4      	; 0x2bb2 <DIO_WritePin+0x8e>
    2bae:	88 0f       	add	r24, r24
    2bb0:	99 1f       	adc	r25, r25
    2bb2:	0a 94       	dec	r0
    2bb4:	e2 f7       	brpl	.-8      	; 0x2bae <DIO_WritePin+0x8a>
    2bb6:	80 95       	com	r24
    2bb8:	84 23       	and	r24, r20
    2bba:	8c 93       	st	X, r24
    2bbc:	b1 c0       	rjmp	.+354    	; 0x2d20 <DIO_WritePin+0x1fc>
			break;
			case PB:
			CLR_BIT(PORTB_REG,pin_num);
    2bbe:	a8 e3       	ldi	r26, 0x38	; 56
    2bc0:	b0 e0       	ldi	r27, 0x00	; 0
    2bc2:	e8 e3       	ldi	r30, 0x38	; 56
    2bc4:	f0 e0       	ldi	r31, 0x00	; 0
    2bc6:	80 81       	ld	r24, Z
    2bc8:	48 2f       	mov	r20, r24
    2bca:	89 81       	ldd	r24, Y+1	; 0x01
    2bcc:	28 2f       	mov	r18, r24
    2bce:	30 e0       	ldi	r19, 0x00	; 0
    2bd0:	81 e0       	ldi	r24, 0x01	; 1
    2bd2:	90 e0       	ldi	r25, 0x00	; 0
    2bd4:	02 2e       	mov	r0, r18
    2bd6:	02 c0       	rjmp	.+4      	; 0x2bdc <DIO_WritePin+0xb8>
    2bd8:	88 0f       	add	r24, r24
    2bda:	99 1f       	adc	r25, r25
    2bdc:	0a 94       	dec	r0
    2bde:	e2 f7       	brpl	.-8      	; 0x2bd8 <DIO_WritePin+0xb4>
    2be0:	80 95       	com	r24
    2be2:	84 23       	and	r24, r20
    2be4:	8c 93       	st	X, r24
    2be6:	9c c0       	rjmp	.+312    	; 0x2d20 <DIO_WritePin+0x1fc>
			break;
			case PC:
			CLR_BIT(PORTC_REG,pin_num);
    2be8:	a5 e3       	ldi	r26, 0x35	; 53
    2bea:	b0 e0       	ldi	r27, 0x00	; 0
    2bec:	e5 e3       	ldi	r30, 0x35	; 53
    2bee:	f0 e0       	ldi	r31, 0x00	; 0
    2bf0:	80 81       	ld	r24, Z
    2bf2:	48 2f       	mov	r20, r24
    2bf4:	89 81       	ldd	r24, Y+1	; 0x01
    2bf6:	28 2f       	mov	r18, r24
    2bf8:	30 e0       	ldi	r19, 0x00	; 0
    2bfa:	81 e0       	ldi	r24, 0x01	; 1
    2bfc:	90 e0       	ldi	r25, 0x00	; 0
    2bfe:	02 2e       	mov	r0, r18
    2c00:	02 c0       	rjmp	.+4      	; 0x2c06 <DIO_WritePin+0xe2>
    2c02:	88 0f       	add	r24, r24
    2c04:	99 1f       	adc	r25, r25
    2c06:	0a 94       	dec	r0
    2c08:	e2 f7       	brpl	.-8      	; 0x2c02 <DIO_WritePin+0xde>
    2c0a:	80 95       	com	r24
    2c0c:	84 23       	and	r24, r20
    2c0e:	8c 93       	st	X, r24
    2c10:	87 c0       	rjmp	.+270    	; 0x2d20 <DIO_WritePin+0x1fc>
			break;
			case PD:
			CLR_BIT(PORTD_REG,pin_num);
    2c12:	a2 e3       	ldi	r26, 0x32	; 50
    2c14:	b0 e0       	ldi	r27, 0x00	; 0
    2c16:	e2 e3       	ldi	r30, 0x32	; 50
    2c18:	f0 e0       	ldi	r31, 0x00	; 0
    2c1a:	80 81       	ld	r24, Z
    2c1c:	48 2f       	mov	r20, r24
    2c1e:	89 81       	ldd	r24, Y+1	; 0x01
    2c20:	28 2f       	mov	r18, r24
    2c22:	30 e0       	ldi	r19, 0x00	; 0
    2c24:	81 e0       	ldi	r24, 0x01	; 1
    2c26:	90 e0       	ldi	r25, 0x00	; 0
    2c28:	02 2e       	mov	r0, r18
    2c2a:	02 c0       	rjmp	.+4      	; 0x2c30 <DIO_WritePin+0x10c>
    2c2c:	88 0f       	add	r24, r24
    2c2e:	99 1f       	adc	r25, r25
    2c30:	0a 94       	dec	r0
    2c32:	e2 f7       	brpl	.-8      	; 0x2c2c <DIO_WritePin+0x108>
    2c34:	80 95       	com	r24
    2c36:	84 23       	and	r24, r20
    2c38:	8c 93       	st	X, r24
    2c3a:	72 c0       	rjmp	.+228    	; 0x2d20 <DIO_WritePin+0x1fc>
			break;
		}
	}
	else if (volt == HIGH)
    2c3c:	8c 81       	ldd	r24, Y+4	; 0x04
    2c3e:	81 30       	cpi	r24, 0x01	; 1
    2c40:	09 f0       	breq	.+2      	; 0x2c44 <DIO_WritePin+0x120>
    2c42:	6e c0       	rjmp	.+220    	; 0x2d20 <DIO_WritePin+0x1fc>
	{
		switch(port)
    2c44:	8a 81       	ldd	r24, Y+2	; 0x02
    2c46:	28 2f       	mov	r18, r24
    2c48:	30 e0       	ldi	r19, 0x00	; 0
    2c4a:	3e 83       	std	Y+6, r19	; 0x06
    2c4c:	2d 83       	std	Y+5, r18	; 0x05
    2c4e:	8d 81       	ldd	r24, Y+5	; 0x05
    2c50:	9e 81       	ldd	r25, Y+6	; 0x06
    2c52:	81 30       	cpi	r24, 0x01	; 1
    2c54:	91 05       	cpc	r25, r1
    2c56:	49 f1       	breq	.+82     	; 0x2caa <DIO_WritePin+0x186>
    2c58:	2d 81       	ldd	r18, Y+5	; 0x05
    2c5a:	3e 81       	ldd	r19, Y+6	; 0x06
    2c5c:	22 30       	cpi	r18, 0x02	; 2
    2c5e:	31 05       	cpc	r19, r1
    2c60:	2c f4       	brge	.+10     	; 0x2c6c <DIO_WritePin+0x148>
    2c62:	8d 81       	ldd	r24, Y+5	; 0x05
    2c64:	9e 81       	ldd	r25, Y+6	; 0x06
    2c66:	00 97       	sbiw	r24, 0x00	; 0
    2c68:	61 f0       	breq	.+24     	; 0x2c82 <DIO_WritePin+0x15e>
    2c6a:	5a c0       	rjmp	.+180    	; 0x2d20 <DIO_WritePin+0x1fc>
    2c6c:	2d 81       	ldd	r18, Y+5	; 0x05
    2c6e:	3e 81       	ldd	r19, Y+6	; 0x06
    2c70:	22 30       	cpi	r18, 0x02	; 2
    2c72:	31 05       	cpc	r19, r1
    2c74:	71 f1       	breq	.+92     	; 0x2cd2 <DIO_WritePin+0x1ae>
    2c76:	8d 81       	ldd	r24, Y+5	; 0x05
    2c78:	9e 81       	ldd	r25, Y+6	; 0x06
    2c7a:	83 30       	cpi	r24, 0x03	; 3
    2c7c:	91 05       	cpc	r25, r1
    2c7e:	e9 f1       	breq	.+122    	; 0x2cfa <DIO_WritePin+0x1d6>
    2c80:	4f c0       	rjmp	.+158    	; 0x2d20 <DIO_WritePin+0x1fc>
		{
			case PA:
			SET_BIT(PORTA_REG,pin_num);
    2c82:	ab e3       	ldi	r26, 0x3B	; 59
    2c84:	b0 e0       	ldi	r27, 0x00	; 0
    2c86:	eb e3       	ldi	r30, 0x3B	; 59
    2c88:	f0 e0       	ldi	r31, 0x00	; 0
    2c8a:	80 81       	ld	r24, Z
    2c8c:	48 2f       	mov	r20, r24
    2c8e:	89 81       	ldd	r24, Y+1	; 0x01
    2c90:	28 2f       	mov	r18, r24
    2c92:	30 e0       	ldi	r19, 0x00	; 0
    2c94:	81 e0       	ldi	r24, 0x01	; 1
    2c96:	90 e0       	ldi	r25, 0x00	; 0
    2c98:	02 2e       	mov	r0, r18
    2c9a:	02 c0       	rjmp	.+4      	; 0x2ca0 <DIO_WritePin+0x17c>
    2c9c:	88 0f       	add	r24, r24
    2c9e:	99 1f       	adc	r25, r25
    2ca0:	0a 94       	dec	r0
    2ca2:	e2 f7       	brpl	.-8      	; 0x2c9c <DIO_WritePin+0x178>
    2ca4:	84 2b       	or	r24, r20
    2ca6:	8c 93       	st	X, r24
    2ca8:	3b c0       	rjmp	.+118    	; 0x2d20 <DIO_WritePin+0x1fc>
			break;
			case PB:
			SET_BIT(PORTB_REG,pin_num);
    2caa:	a8 e3       	ldi	r26, 0x38	; 56
    2cac:	b0 e0       	ldi	r27, 0x00	; 0
    2cae:	e8 e3       	ldi	r30, 0x38	; 56
    2cb0:	f0 e0       	ldi	r31, 0x00	; 0
    2cb2:	80 81       	ld	r24, Z
    2cb4:	48 2f       	mov	r20, r24
    2cb6:	89 81       	ldd	r24, Y+1	; 0x01
    2cb8:	28 2f       	mov	r18, r24
    2cba:	30 e0       	ldi	r19, 0x00	; 0
    2cbc:	81 e0       	ldi	r24, 0x01	; 1
    2cbe:	90 e0       	ldi	r25, 0x00	; 0
    2cc0:	02 2e       	mov	r0, r18
    2cc2:	02 c0       	rjmp	.+4      	; 0x2cc8 <DIO_WritePin+0x1a4>
    2cc4:	88 0f       	add	r24, r24
    2cc6:	99 1f       	adc	r25, r25
    2cc8:	0a 94       	dec	r0
    2cca:	e2 f7       	brpl	.-8      	; 0x2cc4 <DIO_WritePin+0x1a0>
    2ccc:	84 2b       	or	r24, r20
    2cce:	8c 93       	st	X, r24
    2cd0:	27 c0       	rjmp	.+78     	; 0x2d20 <DIO_WritePin+0x1fc>
			break;
			case PC:
			SET_BIT(PORTC_REG,pin_num);
    2cd2:	a5 e3       	ldi	r26, 0x35	; 53
    2cd4:	b0 e0       	ldi	r27, 0x00	; 0
    2cd6:	e5 e3       	ldi	r30, 0x35	; 53
    2cd8:	f0 e0       	ldi	r31, 0x00	; 0
    2cda:	80 81       	ld	r24, Z
    2cdc:	48 2f       	mov	r20, r24
    2cde:	89 81       	ldd	r24, Y+1	; 0x01
    2ce0:	28 2f       	mov	r18, r24
    2ce2:	30 e0       	ldi	r19, 0x00	; 0
    2ce4:	81 e0       	ldi	r24, 0x01	; 1
    2ce6:	90 e0       	ldi	r25, 0x00	; 0
    2ce8:	02 2e       	mov	r0, r18
    2cea:	02 c0       	rjmp	.+4      	; 0x2cf0 <DIO_WritePin+0x1cc>
    2cec:	88 0f       	add	r24, r24
    2cee:	99 1f       	adc	r25, r25
    2cf0:	0a 94       	dec	r0
    2cf2:	e2 f7       	brpl	.-8      	; 0x2cec <DIO_WritePin+0x1c8>
    2cf4:	84 2b       	or	r24, r20
    2cf6:	8c 93       	st	X, r24
    2cf8:	13 c0       	rjmp	.+38     	; 0x2d20 <DIO_WritePin+0x1fc>
			break;
			case PD:
			SET_BIT(PORTD_REG,pin_num);
    2cfa:	a2 e3       	ldi	r26, 0x32	; 50
    2cfc:	b0 e0       	ldi	r27, 0x00	; 0
    2cfe:	e2 e3       	ldi	r30, 0x32	; 50
    2d00:	f0 e0       	ldi	r31, 0x00	; 0
    2d02:	80 81       	ld	r24, Z
    2d04:	48 2f       	mov	r20, r24
    2d06:	89 81       	ldd	r24, Y+1	; 0x01
    2d08:	28 2f       	mov	r18, r24
    2d0a:	30 e0       	ldi	r19, 0x00	; 0
    2d0c:	81 e0       	ldi	r24, 0x01	; 1
    2d0e:	90 e0       	ldi	r25, 0x00	; 0
    2d10:	02 2e       	mov	r0, r18
    2d12:	02 c0       	rjmp	.+4      	; 0x2d18 <DIO_WritePin+0x1f4>
    2d14:	88 0f       	add	r24, r24
    2d16:	99 1f       	adc	r25, r25
    2d18:	0a 94       	dec	r0
    2d1a:	e2 f7       	brpl	.-8      	; 0x2d14 <DIO_WritePin+0x1f0>
    2d1c:	84 2b       	or	r24, r20
    2d1e:	8c 93       	st	X, r24
			break;
		}
	}
}
    2d20:	28 96       	adiw	r28, 0x08	; 8
    2d22:	0f b6       	in	r0, 0x3f	; 63
    2d24:	f8 94       	cli
    2d26:	de bf       	out	0x3e, r29	; 62
    2d28:	0f be       	out	0x3f, r0	; 63
    2d2a:	cd bf       	out	0x3d, r28	; 61
    2d2c:	cf 91       	pop	r28
    2d2e:	df 91       	pop	r29
    2d30:	08 95       	ret

00002d32 <DIO_ReadPin>:

DIO_PinVoltage_type DIO_ReadPin(DIO_Pin_type pin)
{
    2d32:	df 93       	push	r29
    2d34:	cf 93       	push	r28
    2d36:	00 d0       	rcall	.+0      	; 0x2d38 <DIO_ReadPin+0x6>
    2d38:	00 d0       	rcall	.+0      	; 0x2d3a <DIO_ReadPin+0x8>
    2d3a:	00 d0       	rcall	.+0      	; 0x2d3c <DIO_ReadPin+0xa>
    2d3c:	cd b7       	in	r28, 0x3d	; 61
    2d3e:	de b7       	in	r29, 0x3e	; 62
    2d40:	8c 83       	std	Y+4, r24	; 0x04
	DIO_PinVoltage_type volt = LOW;
    2d42:	1b 82       	std	Y+3, r1	; 0x03
	DIO_Port_type port = pin/8;
    2d44:	8c 81       	ldd	r24, Y+4	; 0x04
    2d46:	86 95       	lsr	r24
    2d48:	86 95       	lsr	r24
    2d4a:	86 95       	lsr	r24
    2d4c:	8a 83       	std	Y+2, r24	; 0x02
	u8 pin_num  = pin % 8;
    2d4e:	8c 81       	ldd	r24, Y+4	; 0x04
    2d50:	87 70       	andi	r24, 0x07	; 7
    2d52:	89 83       	std	Y+1, r24	; 0x01
	
	switch (port)
    2d54:	8a 81       	ldd	r24, Y+2	; 0x02
    2d56:	28 2f       	mov	r18, r24
    2d58:	30 e0       	ldi	r19, 0x00	; 0
    2d5a:	3e 83       	std	Y+6, r19	; 0x06
    2d5c:	2d 83       	std	Y+5, r18	; 0x05
    2d5e:	4d 81       	ldd	r20, Y+5	; 0x05
    2d60:	5e 81       	ldd	r21, Y+6	; 0x06
    2d62:	41 30       	cpi	r20, 0x01	; 1
    2d64:	51 05       	cpc	r21, r1
    2d66:	41 f1       	breq	.+80     	; 0x2db8 <DIO_ReadPin+0x86>
    2d68:	8d 81       	ldd	r24, Y+5	; 0x05
    2d6a:	9e 81       	ldd	r25, Y+6	; 0x06
    2d6c:	82 30       	cpi	r24, 0x02	; 2
    2d6e:	91 05       	cpc	r25, r1
    2d70:	34 f4       	brge	.+12     	; 0x2d7e <DIO_ReadPin+0x4c>
    2d72:	2d 81       	ldd	r18, Y+5	; 0x05
    2d74:	3e 81       	ldd	r19, Y+6	; 0x06
    2d76:	21 15       	cp	r18, r1
    2d78:	31 05       	cpc	r19, r1
    2d7a:	61 f0       	breq	.+24     	; 0x2d94 <DIO_ReadPin+0x62>
    2d7c:	52 c0       	rjmp	.+164    	; 0x2e22 <DIO_ReadPin+0xf0>
    2d7e:	4d 81       	ldd	r20, Y+5	; 0x05
    2d80:	5e 81       	ldd	r21, Y+6	; 0x06
    2d82:	42 30       	cpi	r20, 0x02	; 2
    2d84:	51 05       	cpc	r21, r1
    2d86:	51 f1       	breq	.+84     	; 0x2ddc <DIO_ReadPin+0xaa>
    2d88:	8d 81       	ldd	r24, Y+5	; 0x05
    2d8a:	9e 81       	ldd	r25, Y+6	; 0x06
    2d8c:	83 30       	cpi	r24, 0x03	; 3
    2d8e:	91 05       	cpc	r25, r1
    2d90:	b9 f1       	breq	.+110    	; 0x2e00 <DIO_ReadPin+0xce>
    2d92:	47 c0       	rjmp	.+142    	; 0x2e22 <DIO_ReadPin+0xf0>
	{
		case PA:
		volt = READ_BIT(PINA_REG,pin_num);
    2d94:	e9 e3       	ldi	r30, 0x39	; 57
    2d96:	f0 e0       	ldi	r31, 0x00	; 0
    2d98:	80 81       	ld	r24, Z
    2d9a:	28 2f       	mov	r18, r24
    2d9c:	30 e0       	ldi	r19, 0x00	; 0
    2d9e:	89 81       	ldd	r24, Y+1	; 0x01
    2da0:	88 2f       	mov	r24, r24
    2da2:	90 e0       	ldi	r25, 0x00	; 0
    2da4:	a9 01       	movw	r20, r18
    2da6:	02 c0       	rjmp	.+4      	; 0x2dac <DIO_ReadPin+0x7a>
    2da8:	55 95       	asr	r21
    2daa:	47 95       	ror	r20
    2dac:	8a 95       	dec	r24
    2dae:	e2 f7       	brpl	.-8      	; 0x2da8 <DIO_ReadPin+0x76>
    2db0:	ca 01       	movw	r24, r20
    2db2:	81 70       	andi	r24, 0x01	; 1
    2db4:	8b 83       	std	Y+3, r24	; 0x03
    2db6:	35 c0       	rjmp	.+106    	; 0x2e22 <DIO_ReadPin+0xf0>
		break;
		case PB:
		volt = READ_BIT(PINB_REG,pin_num);
    2db8:	e6 e3       	ldi	r30, 0x36	; 54
    2dba:	f0 e0       	ldi	r31, 0x00	; 0
    2dbc:	80 81       	ld	r24, Z
    2dbe:	28 2f       	mov	r18, r24
    2dc0:	30 e0       	ldi	r19, 0x00	; 0
    2dc2:	89 81       	ldd	r24, Y+1	; 0x01
    2dc4:	88 2f       	mov	r24, r24
    2dc6:	90 e0       	ldi	r25, 0x00	; 0
    2dc8:	a9 01       	movw	r20, r18
    2dca:	02 c0       	rjmp	.+4      	; 0x2dd0 <DIO_ReadPin+0x9e>
    2dcc:	55 95       	asr	r21
    2dce:	47 95       	ror	r20
    2dd0:	8a 95       	dec	r24
    2dd2:	e2 f7       	brpl	.-8      	; 0x2dcc <DIO_ReadPin+0x9a>
    2dd4:	ca 01       	movw	r24, r20
    2dd6:	81 70       	andi	r24, 0x01	; 1
    2dd8:	8b 83       	std	Y+3, r24	; 0x03
    2dda:	23 c0       	rjmp	.+70     	; 0x2e22 <DIO_ReadPin+0xf0>
		break;
		case PC:
		volt = READ_BIT(PINC_REG,pin_num);
    2ddc:	e3 e3       	ldi	r30, 0x33	; 51
    2dde:	f0 e0       	ldi	r31, 0x00	; 0
    2de0:	80 81       	ld	r24, Z
    2de2:	28 2f       	mov	r18, r24
    2de4:	30 e0       	ldi	r19, 0x00	; 0
    2de6:	89 81       	ldd	r24, Y+1	; 0x01
    2de8:	88 2f       	mov	r24, r24
    2dea:	90 e0       	ldi	r25, 0x00	; 0
    2dec:	a9 01       	movw	r20, r18
    2dee:	02 c0       	rjmp	.+4      	; 0x2df4 <DIO_ReadPin+0xc2>
    2df0:	55 95       	asr	r21
    2df2:	47 95       	ror	r20
    2df4:	8a 95       	dec	r24
    2df6:	e2 f7       	brpl	.-8      	; 0x2df0 <DIO_ReadPin+0xbe>
    2df8:	ca 01       	movw	r24, r20
    2dfa:	81 70       	andi	r24, 0x01	; 1
    2dfc:	8b 83       	std	Y+3, r24	; 0x03
    2dfe:	11 c0       	rjmp	.+34     	; 0x2e22 <DIO_ReadPin+0xf0>
		break;
		case PD:
		volt = READ_BIT(PIND_REG,pin_num);
    2e00:	e0 e3       	ldi	r30, 0x30	; 48
    2e02:	f0 e0       	ldi	r31, 0x00	; 0
    2e04:	80 81       	ld	r24, Z
    2e06:	28 2f       	mov	r18, r24
    2e08:	30 e0       	ldi	r19, 0x00	; 0
    2e0a:	89 81       	ldd	r24, Y+1	; 0x01
    2e0c:	88 2f       	mov	r24, r24
    2e0e:	90 e0       	ldi	r25, 0x00	; 0
    2e10:	a9 01       	movw	r20, r18
    2e12:	02 c0       	rjmp	.+4      	; 0x2e18 <DIO_ReadPin+0xe6>
    2e14:	55 95       	asr	r21
    2e16:	47 95       	ror	r20
    2e18:	8a 95       	dec	r24
    2e1a:	e2 f7       	brpl	.-8      	; 0x2e14 <DIO_ReadPin+0xe2>
    2e1c:	ca 01       	movw	r24, r20
    2e1e:	81 70       	andi	r24, 0x01	; 1
    2e20:	8b 83       	std	Y+3, r24	; 0x03
		break;
	}
	return volt;
    2e22:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2e24:	26 96       	adiw	r28, 0x06	; 6
    2e26:	0f b6       	in	r0, 0x3f	; 63
    2e28:	f8 94       	cli
    2e2a:	de bf       	out	0x3e, r29	; 62
    2e2c:	0f be       	out	0x3f, r0	; 63
    2e2e:	cd bf       	out	0x3d, r28	; 61
    2e30:	cf 91       	pop	r28
    2e32:	df 91       	pop	r29
    2e34:	08 95       	ret

00002e36 <DIO_TogglePin>:

void DIO_TogglePin(DIO_Pin_type pin)
{
    2e36:	df 93       	push	r29
    2e38:	cf 93       	push	r28
    2e3a:	00 d0       	rcall	.+0      	; 0x2e3c <DIO_TogglePin+0x6>
    2e3c:	00 d0       	rcall	.+0      	; 0x2e3e <DIO_TogglePin+0x8>
    2e3e:	0f 92       	push	r0
    2e40:	cd b7       	in	r28, 0x3d	; 61
    2e42:	de b7       	in	r29, 0x3e	; 62
    2e44:	8b 83       	std	Y+3, r24	; 0x03
	DIO_Port_type port = pin/8;
    2e46:	8b 81       	ldd	r24, Y+3	; 0x03
    2e48:	86 95       	lsr	r24
    2e4a:	86 95       	lsr	r24
    2e4c:	86 95       	lsr	r24
    2e4e:	8a 83       	std	Y+2, r24	; 0x02
	u8 pin_num  = pin % 8;
    2e50:	8b 81       	ldd	r24, Y+3	; 0x03
    2e52:	87 70       	andi	r24, 0x07	; 7
    2e54:	89 83       	std	Y+1, r24	; 0x01
	switch (port)
    2e56:	8a 81       	ldd	r24, Y+2	; 0x02
    2e58:	28 2f       	mov	r18, r24
    2e5a:	30 e0       	ldi	r19, 0x00	; 0
    2e5c:	3d 83       	std	Y+5, r19	; 0x05
    2e5e:	2c 83       	std	Y+4, r18	; 0x04
    2e60:	8c 81       	ldd	r24, Y+4	; 0x04
    2e62:	9d 81       	ldd	r25, Y+5	; 0x05
    2e64:	81 30       	cpi	r24, 0x01	; 1
    2e66:	91 05       	cpc	r25, r1
    2e68:	49 f1       	breq	.+82     	; 0x2ebc <DIO_TogglePin+0x86>
    2e6a:	2c 81       	ldd	r18, Y+4	; 0x04
    2e6c:	3d 81       	ldd	r19, Y+5	; 0x05
    2e6e:	22 30       	cpi	r18, 0x02	; 2
    2e70:	31 05       	cpc	r19, r1
    2e72:	2c f4       	brge	.+10     	; 0x2e7e <DIO_TogglePin+0x48>
    2e74:	8c 81       	ldd	r24, Y+4	; 0x04
    2e76:	9d 81       	ldd	r25, Y+5	; 0x05
    2e78:	00 97       	sbiw	r24, 0x00	; 0
    2e7a:	61 f0       	breq	.+24     	; 0x2e94 <DIO_TogglePin+0x5e>
    2e7c:	5a c0       	rjmp	.+180    	; 0x2f32 <DIO_TogglePin+0xfc>
    2e7e:	2c 81       	ldd	r18, Y+4	; 0x04
    2e80:	3d 81       	ldd	r19, Y+5	; 0x05
    2e82:	22 30       	cpi	r18, 0x02	; 2
    2e84:	31 05       	cpc	r19, r1
    2e86:	71 f1       	breq	.+92     	; 0x2ee4 <DIO_TogglePin+0xae>
    2e88:	8c 81       	ldd	r24, Y+4	; 0x04
    2e8a:	9d 81       	ldd	r25, Y+5	; 0x05
    2e8c:	83 30       	cpi	r24, 0x03	; 3
    2e8e:	91 05       	cpc	r25, r1
    2e90:	e9 f1       	breq	.+122    	; 0x2f0c <DIO_TogglePin+0xd6>
    2e92:	4f c0       	rjmp	.+158    	; 0x2f32 <DIO_TogglePin+0xfc>
	{
		case PA:
		TOG_BIT(PORTA_REG,pin_num);
    2e94:	ab e3       	ldi	r26, 0x3B	; 59
    2e96:	b0 e0       	ldi	r27, 0x00	; 0
    2e98:	eb e3       	ldi	r30, 0x3B	; 59
    2e9a:	f0 e0       	ldi	r31, 0x00	; 0
    2e9c:	80 81       	ld	r24, Z
    2e9e:	48 2f       	mov	r20, r24
    2ea0:	89 81       	ldd	r24, Y+1	; 0x01
    2ea2:	28 2f       	mov	r18, r24
    2ea4:	30 e0       	ldi	r19, 0x00	; 0
    2ea6:	81 e0       	ldi	r24, 0x01	; 1
    2ea8:	90 e0       	ldi	r25, 0x00	; 0
    2eaa:	02 2e       	mov	r0, r18
    2eac:	02 c0       	rjmp	.+4      	; 0x2eb2 <DIO_TogglePin+0x7c>
    2eae:	88 0f       	add	r24, r24
    2eb0:	99 1f       	adc	r25, r25
    2eb2:	0a 94       	dec	r0
    2eb4:	e2 f7       	brpl	.-8      	; 0x2eae <DIO_TogglePin+0x78>
    2eb6:	84 27       	eor	r24, r20
    2eb8:	8c 93       	st	X, r24
    2eba:	3b c0       	rjmp	.+118    	; 0x2f32 <DIO_TogglePin+0xfc>
		break;
		case PB:
		TOG_BIT(PORTB_REG,pin_num);
    2ebc:	a8 e3       	ldi	r26, 0x38	; 56
    2ebe:	b0 e0       	ldi	r27, 0x00	; 0
    2ec0:	e8 e3       	ldi	r30, 0x38	; 56
    2ec2:	f0 e0       	ldi	r31, 0x00	; 0
    2ec4:	80 81       	ld	r24, Z
    2ec6:	48 2f       	mov	r20, r24
    2ec8:	89 81       	ldd	r24, Y+1	; 0x01
    2eca:	28 2f       	mov	r18, r24
    2ecc:	30 e0       	ldi	r19, 0x00	; 0
    2ece:	81 e0       	ldi	r24, 0x01	; 1
    2ed0:	90 e0       	ldi	r25, 0x00	; 0
    2ed2:	02 2e       	mov	r0, r18
    2ed4:	02 c0       	rjmp	.+4      	; 0x2eda <DIO_TogglePin+0xa4>
    2ed6:	88 0f       	add	r24, r24
    2ed8:	99 1f       	adc	r25, r25
    2eda:	0a 94       	dec	r0
    2edc:	e2 f7       	brpl	.-8      	; 0x2ed6 <DIO_TogglePin+0xa0>
    2ede:	84 27       	eor	r24, r20
    2ee0:	8c 93       	st	X, r24
    2ee2:	27 c0       	rjmp	.+78     	; 0x2f32 <DIO_TogglePin+0xfc>
		break;
		case PC:
		TOG_BIT(PORTC_REG,pin_num);
    2ee4:	a5 e3       	ldi	r26, 0x35	; 53
    2ee6:	b0 e0       	ldi	r27, 0x00	; 0
    2ee8:	e5 e3       	ldi	r30, 0x35	; 53
    2eea:	f0 e0       	ldi	r31, 0x00	; 0
    2eec:	80 81       	ld	r24, Z
    2eee:	48 2f       	mov	r20, r24
    2ef0:	89 81       	ldd	r24, Y+1	; 0x01
    2ef2:	28 2f       	mov	r18, r24
    2ef4:	30 e0       	ldi	r19, 0x00	; 0
    2ef6:	81 e0       	ldi	r24, 0x01	; 1
    2ef8:	90 e0       	ldi	r25, 0x00	; 0
    2efa:	02 2e       	mov	r0, r18
    2efc:	02 c0       	rjmp	.+4      	; 0x2f02 <DIO_TogglePin+0xcc>
    2efe:	88 0f       	add	r24, r24
    2f00:	99 1f       	adc	r25, r25
    2f02:	0a 94       	dec	r0
    2f04:	e2 f7       	brpl	.-8      	; 0x2efe <DIO_TogglePin+0xc8>
    2f06:	84 27       	eor	r24, r20
    2f08:	8c 93       	st	X, r24
    2f0a:	13 c0       	rjmp	.+38     	; 0x2f32 <DIO_TogglePin+0xfc>
		break;
		case PD:
		TOG_BIT(PORTD_REG,pin_num);
    2f0c:	a2 e3       	ldi	r26, 0x32	; 50
    2f0e:	b0 e0       	ldi	r27, 0x00	; 0
    2f10:	e2 e3       	ldi	r30, 0x32	; 50
    2f12:	f0 e0       	ldi	r31, 0x00	; 0
    2f14:	80 81       	ld	r24, Z
    2f16:	48 2f       	mov	r20, r24
    2f18:	89 81       	ldd	r24, Y+1	; 0x01
    2f1a:	28 2f       	mov	r18, r24
    2f1c:	30 e0       	ldi	r19, 0x00	; 0
    2f1e:	81 e0       	ldi	r24, 0x01	; 1
    2f20:	90 e0       	ldi	r25, 0x00	; 0
    2f22:	02 2e       	mov	r0, r18
    2f24:	02 c0       	rjmp	.+4      	; 0x2f2a <DIO_TogglePin+0xf4>
    2f26:	88 0f       	add	r24, r24
    2f28:	99 1f       	adc	r25, r25
    2f2a:	0a 94       	dec	r0
    2f2c:	e2 f7       	brpl	.-8      	; 0x2f26 <DIO_TogglePin+0xf0>
    2f2e:	84 27       	eor	r24, r20
    2f30:	8c 93       	st	X, r24
		break;
	}
}
    2f32:	0f 90       	pop	r0
    2f34:	0f 90       	pop	r0
    2f36:	0f 90       	pop	r0
    2f38:	0f 90       	pop	r0
    2f3a:	0f 90       	pop	r0
    2f3c:	cf 91       	pop	r28
    2f3e:	df 91       	pop	r29
    2f40:	08 95       	ret

00002f42 <DIO_WritePort>:

void DIO_WritePort(DIO_Port_type port , u8 Value)
{
    2f42:	df 93       	push	r29
    2f44:	cf 93       	push	r28
    2f46:	00 d0       	rcall	.+0      	; 0x2f48 <DIO_WritePort+0x6>
    2f48:	00 d0       	rcall	.+0      	; 0x2f4a <DIO_WritePort+0x8>
    2f4a:	cd b7       	in	r28, 0x3d	; 61
    2f4c:	de b7       	in	r29, 0x3e	; 62
    2f4e:	89 83       	std	Y+1, r24	; 0x01
    2f50:	6a 83       	std	Y+2, r22	; 0x02
	switch(port)
    2f52:	89 81       	ldd	r24, Y+1	; 0x01
    2f54:	28 2f       	mov	r18, r24
    2f56:	30 e0       	ldi	r19, 0x00	; 0
    2f58:	3c 83       	std	Y+4, r19	; 0x04
    2f5a:	2b 83       	std	Y+3, r18	; 0x03
    2f5c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f5e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f60:	81 30       	cpi	r24, 0x01	; 1
    2f62:	91 05       	cpc	r25, r1
    2f64:	d1 f0       	breq	.+52     	; 0x2f9a <DIO_WritePort+0x58>
    2f66:	2b 81       	ldd	r18, Y+3	; 0x03
    2f68:	3c 81       	ldd	r19, Y+4	; 0x04
    2f6a:	22 30       	cpi	r18, 0x02	; 2
    2f6c:	31 05       	cpc	r19, r1
    2f6e:	2c f4       	brge	.+10     	; 0x2f7a <DIO_WritePort+0x38>
    2f70:	8b 81       	ldd	r24, Y+3	; 0x03
    2f72:	9c 81       	ldd	r25, Y+4	; 0x04
    2f74:	00 97       	sbiw	r24, 0x00	; 0
    2f76:	61 f0       	breq	.+24     	; 0x2f90 <DIO_WritePort+0x4e>
    2f78:	1e c0       	rjmp	.+60     	; 0x2fb6 <DIO_WritePort+0x74>
    2f7a:	2b 81       	ldd	r18, Y+3	; 0x03
    2f7c:	3c 81       	ldd	r19, Y+4	; 0x04
    2f7e:	22 30       	cpi	r18, 0x02	; 2
    2f80:	31 05       	cpc	r19, r1
    2f82:	81 f0       	breq	.+32     	; 0x2fa4 <DIO_WritePort+0x62>
    2f84:	8b 81       	ldd	r24, Y+3	; 0x03
    2f86:	9c 81       	ldd	r25, Y+4	; 0x04
    2f88:	83 30       	cpi	r24, 0x03	; 3
    2f8a:	91 05       	cpc	r25, r1
    2f8c:	81 f0       	breq	.+32     	; 0x2fae <DIO_WritePort+0x6c>
    2f8e:	13 c0       	rjmp	.+38     	; 0x2fb6 <DIO_WritePort+0x74>
	{
		case PA:
		PORTA_REG = Value;
    2f90:	eb e3       	ldi	r30, 0x3B	; 59
    2f92:	f0 e0       	ldi	r31, 0x00	; 0
    2f94:	8a 81       	ldd	r24, Y+2	; 0x02
    2f96:	80 83       	st	Z, r24
    2f98:	0e c0       	rjmp	.+28     	; 0x2fb6 <DIO_WritePort+0x74>
		break;
		case PB:
		PORTB_REG = Value;
    2f9a:	e8 e3       	ldi	r30, 0x38	; 56
    2f9c:	f0 e0       	ldi	r31, 0x00	; 0
    2f9e:	8a 81       	ldd	r24, Y+2	; 0x02
    2fa0:	80 83       	st	Z, r24
    2fa2:	09 c0       	rjmp	.+18     	; 0x2fb6 <DIO_WritePort+0x74>
		break;
		case PC:
		PORTC_REG = Value;
    2fa4:	e5 e3       	ldi	r30, 0x35	; 53
    2fa6:	f0 e0       	ldi	r31, 0x00	; 0
    2fa8:	8a 81       	ldd	r24, Y+2	; 0x02
    2faa:	80 83       	st	Z, r24
    2fac:	04 c0       	rjmp	.+8      	; 0x2fb6 <DIO_WritePort+0x74>
		break;
		case PD:
		PORTD_REG = Value;
    2fae:	e2 e3       	ldi	r30, 0x32	; 50
    2fb0:	f0 e0       	ldi	r31, 0x00	; 0
    2fb2:	8a 81       	ldd	r24, Y+2	; 0x02
    2fb4:	80 83       	st	Z, r24
		break;
	}
}
    2fb6:	0f 90       	pop	r0
    2fb8:	0f 90       	pop	r0
    2fba:	0f 90       	pop	r0
    2fbc:	0f 90       	pop	r0
    2fbe:	cf 91       	pop	r28
    2fc0:	df 91       	pop	r29
    2fc2:	08 95       	ret

00002fc4 <KEYPAD_OS_Task>:
#include "FreeRTOS/task.h"

static u8 Key;

void KEYPAD_OS_Task(void *param)
{
    2fc4:	df 93       	push	r29
    2fc6:	cf 93       	push	r28
    2fc8:	00 d0       	rcall	.+0      	; 0x2fca <KEYPAD_OS_Task+0x6>
    2fca:	00 d0       	rcall	.+0      	; 0x2fcc <KEYPAD_OS_Task+0x8>
    2fcc:	cd b7       	in	r28, 0x3d	; 61
    2fce:	de b7       	in	r29, 0x3e	; 62
    2fd0:	9c 83       	std	Y+4, r25	; 0x04
    2fd2:	8b 83       	std	Y+3, r24	; 0x03

	u8 R , C;
	/* set rows to high */
	DIO_WritePin(FIRST_OUTPUT , HIGH);
    2fd4:	88 e1       	ldi	r24, 0x18	; 24
    2fd6:	61 e0       	ldi	r22, 0x01	; 1
    2fd8:	0e 94 92 15 	call	0x2b24	; 0x2b24 <DIO_WritePin>
	DIO_WritePin(FIRST_OUTPUT+1 , HIGH);
    2fdc:	89 e1       	ldi	r24, 0x19	; 25
    2fde:	61 e0       	ldi	r22, 0x01	; 1
    2fe0:	0e 94 92 15 	call	0x2b24	; 0x2b24 <DIO_WritePin>
	DIO_WritePin(FIRST_OUTPUT+2 , HIGH);
    2fe4:	8a e1       	ldi	r24, 0x1A	; 26
    2fe6:	61 e0       	ldi	r22, 0x01	; 1
    2fe8:	0e 94 92 15 	call	0x2b24	; 0x2b24 <DIO_WritePin>
	DIO_WritePin(FIRST_OUTPUT+3 , HIGH); 
    2fec:	8b e1       	ldi	r24, 0x1B	; 27
    2fee:	61 e0       	ldi	r22, 0x01	; 1
    2ff0:	0e 94 92 15 	call	0x2b24	; 0x2b24 <DIO_WritePin>
	
	while(1)
	{
		Key = NOTPRESSED;
    2ff4:	8f ef       	ldi	r24, 0xFF	; 255
    2ff6:	80 93 9f 03 	sts	0x039F, r24
		for(R=0; R<ROW; ++R)
    2ffa:	1a 82       	std	Y+2, r1	; 0x02
    2ffc:	34 c0       	rjmp	.+104    	; 0x3066 <KEYPAD_OS_Task+0xa2>
		{
			DIO_WritePin(FIRST_OUTPUT+R , LOW);
    2ffe:	8a 81       	ldd	r24, Y+2	; 0x02
    3000:	88 5e       	subi	r24, 0xE8	; 232
    3002:	60 e0       	ldi	r22, 0x00	; 0
    3004:	0e 94 92 15 	call	0x2b24	; 0x2b24 <DIO_WritePin>
			
			for (C=0; C<COL; ++C)
    3008:	19 82       	std	Y+1, r1	; 0x01
    300a:	22 c0       	rjmp	.+68     	; 0x3050 <KEYPAD_OS_Task+0x8c>
			{
				if (DIO_ReadPin(FIRST_INPUT+C) == LOW)
    300c:	89 81       	ldd	r24, Y+1	; 0x01
    300e:	80 5f       	subi	r24, 0xF0	; 240
    3010:	0e 94 99 16 	call	0x2d32	; 0x2d32 <DIO_ReadPin>
    3014:	88 23       	and	r24, r24
    3016:	c9 f4       	brne	.+50     	; 0x304a <KEYPAD_OS_Task+0x86>
				{
					Key = keypadchars[R][C];
    3018:	8a 81       	ldd	r24, Y+2	; 0x02
    301a:	48 2f       	mov	r20, r24
    301c:	50 e0       	ldi	r21, 0x00	; 0
    301e:	89 81       	ldd	r24, Y+1	; 0x01
    3020:	28 2f       	mov	r18, r24
    3022:	30 e0       	ldi	r19, 0x00	; 0
    3024:	ca 01       	movw	r24, r20
    3026:	88 0f       	add	r24, r24
    3028:	99 1f       	adc	r25, r25
    302a:	88 0f       	add	r24, r24
    302c:	99 1f       	adc	r25, r25
    302e:	82 0f       	add	r24, r18
    3030:	93 1f       	adc	r25, r19
    3032:	fc 01       	movw	r30, r24
    3034:	e9 59       	subi	r30, 0x99	; 153
    3036:	ff 4f       	sbci	r31, 0xFF	; 255
    3038:	80 81       	ld	r24, Z
    303a:	80 93 9f 03 	sts	0x039F, r24
					while(DIO_ReadPin(FIRST_INPUT+C) == LOW);
    303e:	89 81       	ldd	r24, Y+1	; 0x01
    3040:	80 5f       	subi	r24, 0xF0	; 240
    3042:	0e 94 99 16 	call	0x2d32	; 0x2d32 <DIO_ReadPin>
    3046:	88 23       	and	r24, r24
    3048:	d1 f3       	breq	.-12     	; 0x303e <KEYPAD_OS_Task+0x7a>
		Key = NOTPRESSED;
		for(R=0; R<ROW; ++R)
		{
			DIO_WritePin(FIRST_OUTPUT+R , LOW);
			
			for (C=0; C<COL; ++C)
    304a:	89 81       	ldd	r24, Y+1	; 0x01
    304c:	8f 5f       	subi	r24, 0xFF	; 255
    304e:	89 83       	std	Y+1, r24	; 0x01
    3050:	89 81       	ldd	r24, Y+1	; 0x01
    3052:	84 30       	cpi	r24, 0x04	; 4
    3054:	d8 f2       	brcs	.-74     	; 0x300c <KEYPAD_OS_Task+0x48>
				{
					Key = keypadchars[R][C];
					while(DIO_ReadPin(FIRST_INPUT+C) == LOW);
				}
			}
			DIO_WritePin(FIRST_OUTPUT+R , HIGH);
    3056:	8a 81       	ldd	r24, Y+2	; 0x02
    3058:	88 5e       	subi	r24, 0xE8	; 232
    305a:	61 e0       	ldi	r22, 0x01	; 1
    305c:	0e 94 92 15 	call	0x2b24	; 0x2b24 <DIO_WritePin>
	DIO_WritePin(FIRST_OUTPUT+3 , HIGH); 
	
	while(1)
	{
		Key = NOTPRESSED;
		for(R=0; R<ROW; ++R)
    3060:	8a 81       	ldd	r24, Y+2	; 0x02
    3062:	8f 5f       	subi	r24, 0xFF	; 255
    3064:	8a 83       	std	Y+2, r24	; 0x02
    3066:	8a 81       	ldd	r24, Y+2	; 0x02
    3068:	84 30       	cpi	r24, 0x04	; 4
    306a:	48 f2       	brcs	.-110    	; 0x2ffe <KEYPAD_OS_Task+0x3a>
					while(DIO_ReadPin(FIRST_INPUT+C) == LOW);
				}
			}
			DIO_WritePin(FIRST_OUTPUT+R , HIGH);
		}
		vTaskDelay(200);
    306c:	88 ec       	ldi	r24, 0xC8	; 200
    306e:	90 e0       	ldi	r25, 0x00	; 0
    3070:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vTaskDelay>
    3074:	bf cf       	rjmp	.-130    	; 0x2ff4 <KEYPAD_OS_Task+0x30>

00003076 <KEYPAD_OS_GetChar>:
	}
	
}
u8 KEYPAD_OS_GetChar(void)
{
    3076:	df 93       	push	r29
    3078:	cf 93       	push	r28
    307a:	cd b7       	in	r28, 0x3d	; 61
    307c:	de b7       	in	r29, 0x3e	; 62
	return Key;
    307e:	80 91 9f 03 	lds	r24, 0x039F
}
    3082:	cf 91       	pop	r28
    3084:	df 91       	pop	r29
    3086:	08 95       	ret

00003088 <LCD_OS_Init>:

static u8 state , WriteRequest , LCDInitialized;
static u8 gData;

void LCD_OS_Init(void)
{
    3088:	df 93       	push	r29
    308a:	cf 93       	push	r28
    308c:	cd b7       	in	r28, 0x3d	; 61
    308e:	de b7       	in	r29, 0x3e	; 62
	state = STATE_INIT_0;
    3090:	10 92 a2 03 	sts	0x03A2, r1
	WriteRequest = 0;
    3094:	10 92 a3 03 	sts	0x03A3, r1
	LCDInitialized = 0;
    3098:	10 92 a4 03 	sts	0x03A4, r1
}
    309c:	cf 91       	pop	r28
    309e:	df 91       	pop	r29
    30a0:	08 95       	ret

000030a2 <LCD_WriteCommand>:


static u8 LCD_WriteCommand(u8 Command)
{
    30a2:	df 93       	push	r29
    30a4:	cf 93       	push	r28
    30a6:	00 d0       	rcall	.+0      	; 0x30a8 <LCD_WriteCommand+0x6>
    30a8:	00 d0       	rcall	.+0      	; 0x30aa <LCD_WriteCommand+0x8>
    30aa:	cd b7       	in	r28, 0x3d	; 61
    30ac:	de b7       	in	r29, 0x3e	; 62
    30ae:	8a 83       	std	Y+2, r24	; 0x02
	static u8 state = 0 , counter = 0;
	u8 retVal = ON_GOING;
    30b0:	19 82       	std	Y+1, r1	; 0x01

	switch(state)
    30b2:	80 91 a1 03 	lds	r24, 0x03A1
    30b6:	28 2f       	mov	r18, r24
    30b8:	30 e0       	ldi	r19, 0x00	; 0
    30ba:	3c 83       	std	Y+4, r19	; 0x04
    30bc:	2b 83       	std	Y+3, r18	; 0x03
    30be:	8b 81       	ldd	r24, Y+3	; 0x03
    30c0:	9c 81       	ldd	r25, Y+4	; 0x04
    30c2:	81 30       	cpi	r24, 0x01	; 1
    30c4:	91 05       	cpc	r25, r1
    30c6:	e9 f0       	breq	.+58     	; 0x3102 <LCD_WriteCommand+0x60>
    30c8:	2b 81       	ldd	r18, Y+3	; 0x03
    30ca:	3c 81       	ldd	r19, Y+4	; 0x04
    30cc:	22 30       	cpi	r18, 0x02	; 2
    30ce:	31 05       	cpc	r19, r1
    30d0:	01 f1       	breq	.+64     	; 0x3112 <LCD_WriteCommand+0x70>
    30d2:	8b 81       	ldd	r24, Y+3	; 0x03
    30d4:	9c 81       	ldd	r25, Y+4	; 0x04
    30d6:	00 97       	sbiw	r24, 0x00	; 0
    30d8:	59 f5       	brne	.+86     	; 0x3130 <LCD_WriteCommand+0x8e>
	{
	case 0:
		DIO_WritePin(RS,LOW);
    30da:	8a e0       	ldi	r24, 0x0A	; 10
    30dc:	60 e0       	ldi	r22, 0x00	; 0
    30de:	0e 94 92 15 	call	0x2b24	; 0x2b24 <DIO_WritePin>

		DIO_WritePin(EN,HIGH);
    30e2:	88 e0       	ldi	r24, 0x08	; 8
    30e4:	61 e0       	ldi	r22, 0x01	; 1
    30e6:	0e 94 92 15 	call	0x2b24	; 0x2b24 <DIO_WritePin>
		DIO_WritePort(LCD_PORT , Command);
    30ea:	80 e0       	ldi	r24, 0x00	; 0
    30ec:	6a 81       	ldd	r22, Y+2	; 0x02
    30ee:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <DIO_WritePort>
		DIO_WritePin(EN , LOW);
    30f2:	88 e0       	ldi	r24, 0x08	; 8
    30f4:	60 e0       	ldi	r22, 0x00	; 0
    30f6:	0e 94 92 15 	call	0x2b24	; 0x2b24 <DIO_WritePin>

		state = 1;
    30fa:	81 e0       	ldi	r24, 0x01	; 1
    30fc:	80 93 a1 03 	sts	0x03A1, r24
    3100:	17 c0       	rjmp	.+46     	; 0x3130 <LCD_WriteCommand+0x8e>
		break;
	case 1:
		DIO_WritePin(EN,HIGH);
    3102:	88 e0       	ldi	r24, 0x08	; 8
    3104:	61 e0       	ldi	r22, 0x01	; 1
    3106:	0e 94 92 15 	call	0x2b24	; 0x2b24 <DIO_WritePin>
		state = 2;
    310a:	82 e0       	ldi	r24, 0x02	; 2
    310c:	80 93 a1 03 	sts	0x03A1, r24
    3110:	0f c0       	rjmp	.+30     	; 0x3130 <LCD_WriteCommand+0x8e>
		break;
	case 2:
		counter++;
    3112:	80 91 a0 03 	lds	r24, 0x03A0
    3116:	8f 5f       	subi	r24, 0xFF	; 255
    3118:	80 93 a0 03 	sts	0x03A0, r24
        /*10 ms elapsed */
		if(counter == 2){
    311c:	80 91 a0 03 	lds	r24, 0x03A0
    3120:	82 30       	cpi	r24, 0x02	; 2
    3122:	31 f4       	brne	.+12     	; 0x3130 <LCD_WriteCommand+0x8e>
			counter = 0;
    3124:	10 92 a0 03 	sts	0x03A0, r1
			state = 0;
    3128:	10 92 a1 03 	sts	0x03A1, r1
			retVal = DONE;
    312c:	81 e0       	ldi	r24, 0x01	; 1
    312e:	89 83       	std	Y+1, r24	; 0x01
		}
		break;
	}

	return retVal;
    3130:	89 81       	ldd	r24, Y+1	; 0x01
}
    3132:	0f 90       	pop	r0
    3134:	0f 90       	pop	r0
    3136:	0f 90       	pop	r0
    3138:	0f 90       	pop	r0
    313a:	cf 91       	pop	r28
    313c:	df 91       	pop	r29
    313e:	08 95       	ret

00003140 <LCD_WriteData_step1>:

static void LCD_WriteData_step1(void)
{
    3140:	df 93       	push	r29
    3142:	cf 93       	push	r28
    3144:	cd b7       	in	r28, 0x3d	; 61
    3146:	de b7       	in	r29, 0x3e	; 62
	DIO_WritePin(RS , HIGH);
    3148:	8a e0       	ldi	r24, 0x0A	; 10
    314a:	61 e0       	ldi	r22, 0x01	; 1
    314c:	0e 94 92 15 	call	0x2b24	; 0x2b24 <DIO_WritePin>

	DIO_WritePin(EN , HIGH);
    3150:	88 e0       	ldi	r24, 0x08	; 8
    3152:	61 e0       	ldi	r22, 0x01	; 1
    3154:	0e 94 92 15 	call	0x2b24	; 0x2b24 <DIO_WritePin>

	DIO_WritePort(LCD_PORT , gData);
    3158:	90 91 a5 03 	lds	r25, 0x03A5
    315c:	80 e0       	ldi	r24, 0x00	; 0
    315e:	69 2f       	mov	r22, r25
    3160:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <DIO_WritePort>

	DIO_WritePin(EN , LOW);
    3164:	88 e0       	ldi	r24, 0x08	; 8
    3166:	60 e0       	ldi	r22, 0x00	; 0
    3168:	0e 94 92 15 	call	0x2b24	; 0x2b24 <DIO_WritePin>
}
    316c:	cf 91       	pop	r28
    316e:	df 91       	pop	r29
    3170:	08 95       	ret

00003172 <LCD_WriteData_step2>:

static void LCD_WriteData_step2(void)
{
    3172:	df 93       	push	r29
    3174:	cf 93       	push	r28
    3176:	cd b7       	in	r28, 0x3d	; 61
    3178:	de b7       	in	r29, 0x3e	; 62
	DIO_WritePin(EN , HIGH);
    317a:	88 e0       	ldi	r24, 0x08	; 8
    317c:	61 e0       	ldi	r22, 0x01	; 1
    317e:	0e 94 92 15 	call	0x2b24	; 0x2b24 <DIO_WritePin>
}
    3182:	cf 91       	pop	r28
    3184:	df 91       	pop	r29
    3186:	08 95       	ret

00003188 <LCD_OS_Task>:

void LCD_OS_Task(void* pvoid)
{
    3188:	df 93       	push	r29
    318a:	cf 93       	push	r28
    318c:	00 d0       	rcall	.+0      	; 0x318e <LCD_OS_Task+0x6>
    318e:	00 d0       	rcall	.+0      	; 0x3190 <LCD_OS_Task+0x8>
    3190:	0f 92       	push	r0
    3192:	cd b7       	in	r28, 0x3d	; 61
    3194:	de b7       	in	r29, 0x3e	; 62
    3196:	9b 83       	std	Y+3, r25	; 0x03
    3198:	8a 83       	std	Y+2, r24	; 0x02
	u8 retval;

	while(1)
	{
		switch(state)
    319a:	80 91 a2 03 	lds	r24, 0x03A2
    319e:	28 2f       	mov	r18, r24
    31a0:	30 e0       	ldi	r19, 0x00	; 0
    31a2:	3d 83       	std	Y+5, r19	; 0x05
    31a4:	2c 83       	std	Y+4, r18	; 0x04
    31a6:	8c 81       	ldd	r24, Y+4	; 0x04
    31a8:	9d 81       	ldd	r25, Y+5	; 0x05
    31aa:	82 30       	cpi	r24, 0x02	; 2
    31ac:	91 05       	cpc	r25, r1
    31ae:	b1 f1       	breq	.+108    	; 0x321c <LCD_OS_Task+0x94>
    31b0:	2c 81       	ldd	r18, Y+4	; 0x04
    31b2:	3d 81       	ldd	r19, Y+5	; 0x05
    31b4:	23 30       	cpi	r18, 0x03	; 3
    31b6:	31 05       	cpc	r19, r1
    31b8:	54 f4       	brge	.+20     	; 0x31ce <LCD_OS_Task+0x46>
    31ba:	8c 81       	ldd	r24, Y+4	; 0x04
    31bc:	9d 81       	ldd	r25, Y+5	; 0x05
    31be:	00 97       	sbiw	r24, 0x00	; 0
    31c0:	b9 f0       	breq	.+46     	; 0x31f0 <LCD_OS_Task+0x68>
    31c2:	2c 81       	ldd	r18, Y+4	; 0x04
    31c4:	3d 81       	ldd	r19, Y+5	; 0x05
    31c6:	21 30       	cpi	r18, 0x01	; 1
    31c8:	31 05       	cpc	r19, r1
    31ca:	e9 f0       	breq	.+58     	; 0x3206 <LCD_OS_Task+0x7e>
    31cc:	51 c0       	rjmp	.+162    	; 0x3270 <LCD_OS_Task+0xe8>
    31ce:	8c 81       	ldd	r24, Y+4	; 0x04
    31d0:	9d 81       	ldd	r25, Y+5	; 0x05
    31d2:	86 30       	cpi	r24, 0x06	; 6
    31d4:	91 05       	cpc	r25, r1
    31d6:	d9 f1       	breq	.+118    	; 0x324e <LCD_OS_Task+0xc6>
    31d8:	2c 81       	ldd	r18, Y+4	; 0x04
    31da:	3d 81       	ldd	r19, Y+5	; 0x05
    31dc:	27 30       	cpi	r18, 0x07	; 7
    31de:	31 05       	cpc	r19, r1
    31e0:	09 f4       	brne	.+2      	; 0x31e4 <LCD_OS_Task+0x5c>
    31e2:	3f c0       	rjmp	.+126    	; 0x3262 <LCD_OS_Task+0xda>
    31e4:	8c 81       	ldd	r24, Y+4	; 0x04
    31e6:	9d 81       	ldd	r25, Y+5	; 0x05
    31e8:	83 30       	cpi	r24, 0x03	; 3
    31ea:	91 05       	cpc	r25, r1
    31ec:	11 f1       	breq	.+68     	; 0x3232 <LCD_OS_Task+0xaa>
    31ee:	40 c0       	rjmp	.+128    	; 0x3270 <LCD_OS_Task+0xe8>
		{
		case STATE_INIT_0:
			retval = LCD_WriteCommand(LCD_FUNCTION_8BIT_2LINES);
    31f0:	88 e3       	ldi	r24, 0x38	; 56
    31f2:	0e 94 51 18 	call	0x30a2	; 0x30a2 <LCD_WriteCommand>
    31f6:	89 83       	std	Y+1, r24	; 0x01
			if (retval == DONE)
    31f8:	89 81       	ldd	r24, Y+1	; 0x01
    31fa:	81 30       	cpi	r24, 0x01	; 1
    31fc:	c9 f5       	brne	.+114    	; 0x3270 <LCD_OS_Task+0xe8>
			{
				state = STATE_INIT_1;
    31fe:	81 e0       	ldi	r24, 0x01	; 1
    3200:	80 93 a2 03 	sts	0x03A2, r24
    3204:	35 c0       	rjmp	.+106    	; 0x3270 <LCD_OS_Task+0xe8>
			}
			break;
		case STATE_INIT_1:
			retval = LCD_WriteCommand(LCD_DISP_ON);
    3206:	8c e0       	ldi	r24, 0x0C	; 12
    3208:	0e 94 51 18 	call	0x30a2	; 0x30a2 <LCD_WriteCommand>
    320c:	89 83       	std	Y+1, r24	; 0x01
			if (retval == DONE)
    320e:	89 81       	ldd	r24, Y+1	; 0x01
    3210:	81 30       	cpi	r24, 0x01	; 1
    3212:	71 f5       	brne	.+92     	; 0x3270 <LCD_OS_Task+0xe8>
			{
				state = STATE_INIT_2;
    3214:	82 e0       	ldi	r24, 0x02	; 2
    3216:	80 93 a2 03 	sts	0x03A2, r24
    321a:	2a c0       	rjmp	.+84     	; 0x3270 <LCD_OS_Task+0xe8>
			}
			break;
		case STATE_INIT_2:
			retval = LCD_WriteCommand(LCD_CLR_SCREEN);
    321c:	81 e0       	ldi	r24, 0x01	; 1
    321e:	0e 94 51 18 	call	0x30a2	; 0x30a2 <LCD_WriteCommand>
    3222:	89 83       	std	Y+1, r24	; 0x01
			if (retval == DONE)
    3224:	89 81       	ldd	r24, Y+1	; 0x01
    3226:	81 30       	cpi	r24, 0x01	; 1
    3228:	19 f5       	brne	.+70     	; 0x3270 <LCD_OS_Task+0xe8>
			{
				state = STATE_INIT_3;
    322a:	83 e0       	ldi	r24, 0x03	; 3
    322c:	80 93 a2 03 	sts	0x03A2, r24
    3230:	1f c0       	rjmp	.+62     	; 0x3270 <LCD_OS_Task+0xe8>
			}
			break;
		case STATE_INIT_3:
			retval = LCD_WriteCommand(LCD_ENTRY_MODE);
    3232:	86 e0       	ldi	r24, 0x06	; 6
    3234:	0e 94 51 18 	call	0x30a2	; 0x30a2 <LCD_WriteCommand>
    3238:	89 83       	std	Y+1, r24	; 0x01
			if (retval == DONE)
    323a:	89 81       	ldd	r24, Y+1	; 0x01
    323c:	81 30       	cpi	r24, 0x01	; 1
    323e:	c1 f4       	brne	.+48     	; 0x3270 <LCD_OS_Task+0xe8>
			{
				state = STATE_0;
    3240:	86 e0       	ldi	r24, 0x06	; 6
    3242:	80 93 a2 03 	sts	0x03A2, r24
				LCDInitialized = 1;
    3246:	81 e0       	ldi	r24, 0x01	; 1
    3248:	80 93 a4 03 	sts	0x03A4, r24
    324c:	11 c0       	rjmp	.+34     	; 0x3270 <LCD_OS_Task+0xe8>
			}
			break;
		case STATE_0:
			if (WriteRequest == 1)
    324e:	80 91 a3 03 	lds	r24, 0x03A3
    3252:	81 30       	cpi	r24, 0x01	; 1
    3254:	69 f4       	brne	.+26     	; 0x3270 <LCD_OS_Task+0xe8>
			{
				LCD_WriteData_step1();
    3256:	0e 94 a0 18 	call	0x3140	; 0x3140 <LCD_WriteData_step1>
				state = STATE_1;
    325a:	87 e0       	ldi	r24, 0x07	; 7
    325c:	80 93 a2 03 	sts	0x03A2, r24
    3260:	07 c0       	rjmp	.+14     	; 0x3270 <LCD_OS_Task+0xe8>
			}
			break;
		case STATE_1:
			LCD_WriteData_step2();
    3262:	0e 94 b9 18 	call	0x3172	; 0x3172 <LCD_WriteData_step2>
			state = STATE_0;
    3266:	86 e0       	ldi	r24, 0x06	; 6
    3268:	80 93 a2 03 	sts	0x03A2, r24
			WriteRequest = 0;
    326c:	10 92 a3 03 	sts	0x03A3, r1
			break;

		}	
		vTaskDelay(5);
    3270:	85 e0       	ldi	r24, 0x05	; 5
    3272:	90 e0       	ldi	r25, 0x00	; 0
    3274:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vTaskDelay>
    3278:	90 cf       	rjmp	.-224    	; 0x319a <LCD_OS_Task+0x12>

0000327a <LCD_OS_WriteChar>:
	}

}

u8 LCD_OS_WriteChar(u8 character)
{
    327a:	df 93       	push	r29
    327c:	cf 93       	push	r28
    327e:	00 d0       	rcall	.+0      	; 0x3280 <LCD_OS_WriteChar+0x6>
    3280:	cd b7       	in	r28, 0x3d	; 61
    3282:	de b7       	in	r29, 0x3e	; 62
    3284:	89 83       	std	Y+1, r24	; 0x01
	if ((LCDInitialized==1) && (WriteRequest==0))
    3286:	80 91 a4 03 	lds	r24, 0x03A4
    328a:	81 30       	cpi	r24, 0x01	; 1
    328c:	61 f4       	brne	.+24     	; 0x32a6 <LCD_OS_WriteChar+0x2c>
    328e:	80 91 a3 03 	lds	r24, 0x03A3
    3292:	88 23       	and	r24, r24
    3294:	41 f4       	brne	.+16     	; 0x32a6 <LCD_OS_WriteChar+0x2c>
	{
		WriteRequest = 1;
    3296:	81 e0       	ldi	r24, 0x01	; 1
    3298:	80 93 a3 03 	sts	0x03A3, r24
		gData = character;
    329c:	89 81       	ldd	r24, Y+1	; 0x01
    329e:	80 93 a5 03 	sts	0x03A5, r24
		return E_OK;
    32a2:	1a 82       	std	Y+2, r1	; 0x02
    32a4:	02 c0       	rjmp	.+4      	; 0x32aa <LCD_OS_WriteChar+0x30>
	}
	else{
		return E_NOK;
    32a6:	81 e0       	ldi	r24, 0x01	; 1
    32a8:	8a 83       	std	Y+2, r24	; 0x02
    32aa:	8a 81       	ldd	r24, Y+2	; 0x02
	}
}
    32ac:	0f 90       	pop	r0
    32ae:	0f 90       	pop	r0
    32b0:	cf 91       	pop	r28
    32b2:	df 91       	pop	r29
    32b4:	08 95       	ret

000032b6 <APP_OS_TASK>:
#include "DIO_Interface.h"
#include "KEYPAD_OS.h"
#include "LCD_OS.h"

void APP_OS_TASK(void* pvoid)
{
    32b6:	df 93       	push	r29
    32b8:	cf 93       	push	r28
    32ba:	00 d0       	rcall	.+0      	; 0x32bc <APP_OS_TASK+0x6>
    32bc:	0f 92       	push	r0
    32be:	cd b7       	in	r28, 0x3d	; 61
    32c0:	de b7       	in	r29, 0x3e	; 62
    32c2:	9b 83       	std	Y+3, r25	; 0x03
    32c4:	8a 83       	std	Y+2, r24	; 0x02
	u8 enuPressedKey;
	while(1)
	{
		enuPressedKey = KEYPAD_OS_GetChar();
    32c6:	0e 94 3b 18 	call	0x3076	; 0x3076 <KEYPAD_OS_GetChar>
    32ca:	89 83       	std	Y+1, r24	; 0x01

		if (enuPressedKey != NOTPRESSED){
    32cc:	89 81       	ldd	r24, Y+1	; 0x01
    32ce:	8f 3f       	cpi	r24, 0xFF	; 255
    32d0:	19 f0       	breq	.+6      	; 0x32d8 <APP_OS_TASK+0x22>
			LCD_OS_WriteChar(enuPressedKey);
    32d2:	89 81       	ldd	r24, Y+1	; 0x01
    32d4:	0e 94 3d 19 	call	0x327a	; 0x327a <LCD_OS_WriteChar>
		}

		vTaskDelay(200);
    32d8:	88 ec       	ldi	r24, 0xC8	; 200
    32da:	90 e0       	ldi	r25, 0x00	; 0
    32dc:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vTaskDelay>
    32e0:	f2 cf       	rjmp	.-28     	; 0x32c6 <APP_OS_TASK+0x10>

000032e2 <main>:
	}
}

int main(void)
{
    32e2:	af 92       	push	r10
    32e4:	bf 92       	push	r11
    32e6:	cf 92       	push	r12
    32e8:	df 92       	push	r13
    32ea:	ef 92       	push	r14
    32ec:	ff 92       	push	r15
    32ee:	0f 93       	push	r16
    32f0:	df 93       	push	r29
    32f2:	cf 93       	push	r28
    32f4:	cd b7       	in	r28, 0x3d	; 61
    32f6:	de b7       	in	r29, 0x3e	; 62
	DIO_Init();
    32f8:	0e 94 06 13 	call	0x260c	; 0x260c <DIO_Init>

	LCD_OS_Init();
    32fc:	0e 94 44 18 	call	0x3088	; 0x3088 <LCD_OS_Init>

	xTaskCreate(KEYPAD_OS_Task,NULL,configMINIMAL_STACK_SIZE,NULL,
    3300:	82 ee       	ldi	r24, 0xE2	; 226
    3302:	97 e1       	ldi	r25, 0x17	; 23
    3304:	60 e0       	ldi	r22, 0x00	; 0
    3306:	70 e0       	ldi	r23, 0x00	; 0
    3308:	45 e5       	ldi	r20, 0x55	; 85
    330a:	50 e0       	ldi	r21, 0x00	; 0
    330c:	20 e0       	ldi	r18, 0x00	; 0
    330e:	30 e0       	ldi	r19, 0x00	; 0
    3310:	01 e0       	ldi	r16, 0x01	; 1
    3312:	ee 24       	eor	r14, r14
    3314:	ff 24       	eor	r15, r15
    3316:	cc 24       	eor	r12, r12
    3318:	dd 24       	eor	r13, r13
    331a:	aa 24       	eor	r10, r10
    331c:	bb 24       	eor	r11, r11
    331e:	0e 94 1b 0c 	call	0x1836	; 0x1836 <xTaskGenericCreate>
		 			1,NULL);

	xTaskCreate(APP_OS_TASK,NULL,configMINIMAL_STACK_SIZE,NULL,
    3322:	8b e5       	ldi	r24, 0x5B	; 91
    3324:	99 e1       	ldi	r25, 0x19	; 25
    3326:	60 e0       	ldi	r22, 0x00	; 0
    3328:	70 e0       	ldi	r23, 0x00	; 0
    332a:	45 e5       	ldi	r20, 0x55	; 85
    332c:	50 e0       	ldi	r21, 0x00	; 0
    332e:	20 e0       	ldi	r18, 0x00	; 0
    3330:	30 e0       	ldi	r19, 0x00	; 0
    3332:	02 e0       	ldi	r16, 0x02	; 2
    3334:	ee 24       	eor	r14, r14
    3336:	ff 24       	eor	r15, r15
    3338:	cc 24       	eor	r12, r12
    333a:	dd 24       	eor	r13, r13
    333c:	aa 24       	eor	r10, r10
    333e:	bb 24       	eor	r11, r11
    3340:	0e 94 1b 0c 	call	0x1836	; 0x1836 <xTaskGenericCreate>
		 			2,NULL);

	xTaskCreate(LCD_OS_Task,NULL,configMINIMAL_STACK_SIZE,NULL,
    3344:	84 ec       	ldi	r24, 0xC4	; 196
    3346:	98 e1       	ldi	r25, 0x18	; 24
    3348:	60 e0       	ldi	r22, 0x00	; 0
    334a:	70 e0       	ldi	r23, 0x00	; 0
    334c:	45 e5       	ldi	r20, 0x55	; 85
    334e:	50 e0       	ldi	r21, 0x00	; 0
    3350:	20 e0       	ldi	r18, 0x00	; 0
    3352:	30 e0       	ldi	r19, 0x00	; 0
    3354:	03 e0       	ldi	r16, 0x03	; 3
    3356:	ee 24       	eor	r14, r14
    3358:	ff 24       	eor	r15, r15
    335a:	cc 24       	eor	r12, r12
    335c:	dd 24       	eor	r13, r13
    335e:	aa 24       	eor	r10, r10
    3360:	bb 24       	eor	r11, r11
    3362:	0e 94 1b 0c 	call	0x1836	; 0x1836 <xTaskGenericCreate>
		 			3,NULL);

	vTaskStartScheduler();
    3366:	0e 94 14 0e 	call	0x1c28	; 0x1c28 <vTaskStartScheduler>
    336a:	ff cf       	rjmp	.-2      	; 0x336a <main+0x88>

0000336c <memcpy>:
    336c:	fb 01       	movw	r30, r22
    336e:	dc 01       	movw	r26, r24
    3370:	02 c0       	rjmp	.+4      	; 0x3376 <memcpy+0xa>
    3372:	01 90       	ld	r0, Z+
    3374:	0d 92       	st	X+, r0
    3376:	41 50       	subi	r20, 0x01	; 1
    3378:	50 40       	sbci	r21, 0x00	; 0
    337a:	d8 f7       	brcc	.-10     	; 0x3372 <memcpy+0x6>
    337c:	08 95       	ret

0000337e <memset>:
    337e:	dc 01       	movw	r26, r24
    3380:	01 c0       	rjmp	.+2      	; 0x3384 <memset+0x6>
    3382:	6d 93       	st	X+, r22
    3384:	41 50       	subi	r20, 0x01	; 1
    3386:	50 40       	sbci	r21, 0x00	; 0
    3388:	e0 f7       	brcc	.-8      	; 0x3382 <memset+0x4>
    338a:	08 95       	ret

0000338c <strncpy>:
    338c:	fb 01       	movw	r30, r22
    338e:	dc 01       	movw	r26, r24
    3390:	41 50       	subi	r20, 0x01	; 1
    3392:	50 40       	sbci	r21, 0x00	; 0
    3394:	48 f0       	brcs	.+18     	; 0x33a8 <strncpy+0x1c>
    3396:	01 90       	ld	r0, Z+
    3398:	0d 92       	st	X+, r0
    339a:	00 20       	and	r0, r0
    339c:	c9 f7       	brne	.-14     	; 0x3390 <strncpy+0x4>
    339e:	01 c0       	rjmp	.+2      	; 0x33a2 <strncpy+0x16>
    33a0:	1d 92       	st	X+, r1
    33a2:	41 50       	subi	r20, 0x01	; 1
    33a4:	50 40       	sbci	r21, 0x00	; 0
    33a6:	e0 f7       	brcc	.-8      	; 0x33a0 <strncpy+0x14>
    33a8:	08 95       	ret

000033aa <_exit>:
    33aa:	f8 94       	cli

000033ac <__stop_program>:
    33ac:	ff cf       	rjmp	.-2      	; 0x33ac <__stop_program>
