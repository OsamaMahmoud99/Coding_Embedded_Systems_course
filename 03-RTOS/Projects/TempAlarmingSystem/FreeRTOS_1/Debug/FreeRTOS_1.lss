
FreeRTOS_1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002602  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000b6  00800060  00002602  00002696  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000004dd  00800116  00800116  0000274c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000274c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000277c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000648  00000000  00000000  000027b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006b38  00000000  00000000  00002e00  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001987  00000000  00000000  00009938  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003870  00000000  00000000  0000b2bf  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001258  00000000  00000000  0000eb30  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001ce1  00000000  00000000  0000fd88  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000063cb  00000000  00000000  00011a69  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000590  00000000  00000000  00017e34  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 a7 11 	jmp	0x234e	; 0x234e <__vector_13>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 d0 11 	jmp	0x23a0	; 0x23a0 <__vector_15>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e0       	ldi	r30, 0x02	; 2
      68:	f6 e2       	ldi	r31, 0x26	; 38
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a6 31       	cpi	r26, 0x16	; 22
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	25 e0       	ldi	r18, 0x05	; 5
      78:	a6 e1       	ldi	r26, 0x16	; 22
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 3f       	cpi	r26, 0xF3	; 243
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <main>
      8a:	0c 94 ff 12 	jmp	0x25fe	; 0x25fe <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <prvTestWaitCondition>:
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
      92:	41 11       	cpse	r20, r1
      94:	06 c0       	rjmp	.+12     	; 0xa2 <prvTestWaitCondition+0x10>
      96:	68 23       	and	r22, r24
      98:	79 23       	and	r23, r25
      9a:	67 2b       	or	r22, r23
      9c:	49 f4       	brne	.+18     	; 0xb0 <prvTestWaitCondition+0x1e>
      9e:	80 e0       	ldi	r24, 0x00	; 0
      a0:	08 95       	ret
      a2:	86 23       	and	r24, r22
      a4:	97 23       	and	r25, r23
      a6:	68 17       	cp	r22, r24
      a8:	79 07       	cpc	r23, r25
      aa:	21 f0       	breq	.+8      	; 0xb4 <prvTestWaitCondition+0x22>
      ac:	80 e0       	ldi	r24, 0x00	; 0
      ae:	08 95       	ret
      b0:	81 e0       	ldi	r24, 0x01	; 1
      b2:	08 95       	ret
      b4:	81 e0       	ldi	r24, 0x01	; 1
      b6:	08 95       	ret

000000b8 <xEventGroupCreate>:
      b8:	cf 93       	push	r28
      ba:	df 93       	push	r29
      bc:	8b e0       	ldi	r24, 0x0B	; 11
      be:	90 e0       	ldi	r25, 0x00	; 0
      c0:	0e 94 54 01 	call	0x2a8	; 0x2a8 <pvPortMalloc>
      c4:	ec 01       	movw	r28, r24
      c6:	00 97       	sbiw	r24, 0x00	; 0
      c8:	31 f0       	breq	.+12     	; 0xd6 <xEventGroupCreate+0x1e>
      ca:	fc 01       	movw	r30, r24
      cc:	11 92       	st	Z+, r1
      ce:	11 92       	st	Z+, r1
      d0:	cf 01       	movw	r24, r30
      d2:	0e 94 8a 01 	call	0x314	; 0x314 <vListInitialise>
      d6:	ce 01       	movw	r24, r28
      d8:	df 91       	pop	r29
      da:	cf 91       	pop	r28
      dc:	08 95       	ret

000000de <xEventGroupWaitBits>:
      de:	af 92       	push	r10
      e0:	bf 92       	push	r11
      e2:	cf 92       	push	r12
      e4:	df 92       	push	r13
      e6:	ef 92       	push	r14
      e8:	ff 92       	push	r15
      ea:	0f 93       	push	r16
      ec:	1f 93       	push	r17
      ee:	cf 93       	push	r28
      f0:	df 93       	push	r29
      f2:	7c 01       	movw	r14, r24
      f4:	5b 01       	movw	r10, r22
      f6:	c4 2e       	mov	r12, r20
      f8:	d2 2e       	mov	r13, r18
      fa:	0e 94 d1 07 	call	0xfa2	; 0xfa2 <vTaskSuspendAll>
      fe:	f7 01       	movw	r30, r14
     100:	c0 81       	ld	r28, Z
     102:	d1 81       	ldd	r29, Z+1	; 0x01
     104:	4d 2d       	mov	r20, r13
     106:	b5 01       	movw	r22, r10
     108:	ce 01       	movw	r24, r28
     10a:	0e 94 49 00 	call	0x92	; 0x92 <prvTestWaitCondition>
     10e:	88 23       	and	r24, r24
     110:	69 f0       	breq	.+26     	; 0x12c <xEventGroupWaitBits+0x4e>
     112:	cc 20       	and	r12, r12
     114:	09 f1       	breq	.+66     	; 0x158 <xEventGroupWaitBits+0x7a>
     116:	c5 01       	movw	r24, r10
     118:	80 95       	com	r24
     11a:	90 95       	com	r25
     11c:	8c 23       	and	r24, r28
     11e:	9d 23       	and	r25, r29
     120:	f7 01       	movw	r30, r14
     122:	91 83       	std	Z+1, r25	; 0x01
     124:	80 83       	st	Z, r24
     126:	00 e0       	ldi	r16, 0x00	; 0
     128:	10 e0       	ldi	r17, 0x00	; 0
     12a:	18 c0       	rjmp	.+48     	; 0x15c <xEventGroupWaitBits+0x7e>
     12c:	01 15       	cp	r16, r1
     12e:	11 05       	cpc	r17, r1
     130:	a9 f0       	breq	.+42     	; 0x15c <xEventGroupWaitBits+0x7e>
     132:	c1 10       	cpse	r12, r1
     134:	03 c0       	rjmp	.+6      	; 0x13c <xEventGroupWaitBits+0x5e>
     136:	60 e0       	ldi	r22, 0x00	; 0
     138:	70 e0       	ldi	r23, 0x00	; 0
     13a:	02 c0       	rjmp	.+4      	; 0x140 <xEventGroupWaitBits+0x62>
     13c:	60 e0       	ldi	r22, 0x00	; 0
     13e:	71 e0       	ldi	r23, 0x01	; 1
     140:	d1 10       	cpse	r13, r1
     142:	74 60       	ori	r23, 0x04	; 4
     144:	6a 29       	or	r22, r10
     146:	7b 29       	or	r23, r11
     148:	a8 01       	movw	r20, r16
     14a:	c7 01       	movw	r24, r14
     14c:	02 96       	adiw	r24, 0x02	; 2
     14e:	0e 94 d6 09 	call	0x13ac	; 0x13ac <vTaskPlaceOnUnorderedEventList>
     152:	c0 e0       	ldi	r28, 0x00	; 0
     154:	d0 e0       	ldi	r29, 0x00	; 0
     156:	02 c0       	rjmp	.+4      	; 0x15c <xEventGroupWaitBits+0x7e>
     158:	00 e0       	ldi	r16, 0x00	; 0
     15a:	10 e0       	ldi	r17, 0x00	; 0
     15c:	0e 94 93 08 	call	0x1126	; 0x1126 <xTaskResumeAll>
     160:	01 2b       	or	r16, r17
     162:	19 f1       	breq	.+70     	; 0x1aa <xEventGroupWaitBits+0xcc>
     164:	81 11       	cpse	r24, r1
     166:	02 c0       	rjmp	.+4      	; 0x16c <xEventGroupWaitBits+0x8e>
     168:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
     16c:	0e 94 5f 0b 	call	0x16be	; 0x16be <uxTaskResetEventItemValue>
     170:	ec 01       	movw	r28, r24
     172:	91 fd       	sbrc	r25, 1
     174:	19 c0       	rjmp	.+50     	; 0x1a8 <xEventGroupWaitBits+0xca>
     176:	0f b6       	in	r0, 0x3f	; 63
     178:	f8 94       	cli
     17a:	0f 92       	push	r0
     17c:	f7 01       	movw	r30, r14
     17e:	c0 81       	ld	r28, Z
     180:	d1 81       	ldd	r29, Z+1	; 0x01
     182:	4d 2d       	mov	r20, r13
     184:	b5 01       	movw	r22, r10
     186:	ce 01       	movw	r24, r28
     188:	0e 94 49 00 	call	0x92	; 0x92 <prvTestWaitCondition>
     18c:	88 23       	and	r24, r24
     18e:	51 f0       	breq	.+20     	; 0x1a4 <xEventGroupWaitBits+0xc6>
     190:	cc 20       	and	r12, r12
     192:	41 f0       	breq	.+16     	; 0x1a4 <xEventGroupWaitBits+0xc6>
     194:	b5 01       	movw	r22, r10
     196:	60 95       	com	r22
     198:	70 95       	com	r23
     19a:	6c 23       	and	r22, r28
     19c:	7d 23       	and	r23, r29
     19e:	f7 01       	movw	r30, r14
     1a0:	71 83       	std	Z+1, r23	; 0x01
     1a2:	60 83       	st	Z, r22
     1a4:	0f 90       	pop	r0
     1a6:	0f be       	out	0x3f, r0	; 63
     1a8:	dd 27       	eor	r29, r29
     1aa:	ce 01       	movw	r24, r28
     1ac:	df 91       	pop	r29
     1ae:	cf 91       	pop	r28
     1b0:	1f 91       	pop	r17
     1b2:	0f 91       	pop	r16
     1b4:	ff 90       	pop	r15
     1b6:	ef 90       	pop	r14
     1b8:	df 90       	pop	r13
     1ba:	cf 90       	pop	r12
     1bc:	bf 90       	pop	r11
     1be:	af 90       	pop	r10
     1c0:	08 95       	ret

000001c2 <xEventGroupClearBits>:
     1c2:	fc 01       	movw	r30, r24
     1c4:	0f b6       	in	r0, 0x3f	; 63
     1c6:	f8 94       	cli
     1c8:	0f 92       	push	r0
     1ca:	80 81       	ld	r24, Z
     1cc:	91 81       	ldd	r25, Z+1	; 0x01
     1ce:	60 95       	com	r22
     1d0:	70 95       	com	r23
     1d2:	68 23       	and	r22, r24
     1d4:	79 23       	and	r23, r25
     1d6:	71 83       	std	Z+1, r23	; 0x01
     1d8:	60 83       	st	Z, r22
     1da:	0f 90       	pop	r0
     1dc:	0f be       	out	0x3f, r0	; 63
     1de:	08 95       	ret

000001e0 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     1e0:	cf 92       	push	r12
     1e2:	df 92       	push	r13
     1e4:	ef 92       	push	r14
     1e6:	ff 92       	push	r15
     1e8:	0f 93       	push	r16
     1ea:	1f 93       	push	r17
     1ec:	cf 93       	push	r28
     1ee:	df 93       	push	r29
     1f0:	7c 01       	movw	r14, r24
     1f2:	8b 01       	movw	r16, r22
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1f4:	ec 01       	movw	r28, r24
     1f6:	25 96       	adiw	r28, 0x05	; 5
	vTaskSuspendAll();
     1f8:	0e 94 d1 07 	call	0xfa2	; 0xfa2 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     1fc:	d7 01       	movw	r26, r14
     1fe:	17 96       	adiw	r26, 0x07	; 7
     200:	ed 91       	ld	r30, X+
     202:	fc 91       	ld	r31, X
     204:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     206:	8d 91       	ld	r24, X+
     208:	9c 91       	ld	r25, X
     20a:	11 97       	sbiw	r26, 0x01	; 1
     20c:	08 2b       	or	r16, r24
     20e:	19 2b       	or	r17, r25
     210:	0d 93       	st	X+, r16
     212:	1c 93       	st	X, r17
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     214:	00 e0       	ldi	r16, 0x00	; 0
     216:	10 e0       	ldi	r17, 0x00	; 0

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     218:	2d c0       	rjmp	.+90     	; 0x274 <xEventGroupSetBits+0x94>
		{
			pxNext = listGET_NEXT( pxListItem );
     21a:	c2 80       	ldd	r12, Z+2	; 0x02
     21c:	d3 80       	ldd	r13, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     21e:	80 81       	ld	r24, Z
     220:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     222:	9c 01       	movw	r18, r24
     224:	33 27       	eor	r19, r19

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     226:	92 fd       	sbrc	r25, 2
     228:	09 c0       	rjmp	.+18     	; 0x23c <xEventGroupSetBits+0x5c>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     22a:	d7 01       	movw	r26, r14
     22c:	4d 91       	ld	r20, X+
     22e:	5c 91       	ld	r21, X
     230:	42 23       	and	r20, r18
     232:	53 23       	and	r21, r19
     234:	45 2b       	or	r20, r21
     236:	61 f4       	brne	.+24     	; 0x250 <xEventGroupSetBits+0x70>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     238:	40 e0       	ldi	r20, 0x00	; 0
     23a:	0d c0       	rjmp	.+26     	; 0x256 <xEventGroupSetBits+0x76>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     23c:	d7 01       	movw	r26, r14
     23e:	4d 91       	ld	r20, X+
     240:	5c 91       	ld	r21, X
     242:	42 23       	and	r20, r18
     244:	53 23       	and	r21, r19
     246:	24 17       	cp	r18, r20
     248:	35 07       	cpc	r19, r21
     24a:	21 f0       	breq	.+8      	; 0x254 <xEventGroupSetBits+0x74>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     24c:	40 e0       	ldi	r20, 0x00	; 0
     24e:	03 c0       	rjmp	.+6      	; 0x256 <xEventGroupSetBits+0x76>
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     250:	41 e0       	ldi	r20, 0x01	; 1
     252:	01 c0       	rjmp	.+2      	; 0x256 <xEventGroupSetBits+0x76>
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     254:	41 e0       	ldi	r20, 0x01	; 1
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     256:	44 23       	and	r20, r20
     258:	59 f0       	breq	.+22     	; 0x270 <xEventGroupSetBits+0x90>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     25a:	90 ff       	sbrs	r25, 0
     25c:	02 c0       	rjmp	.+4      	; 0x262 <xEventGroupSetBits+0x82>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     25e:	02 2b       	or	r16, r18
     260:	13 2b       	or	r17, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     262:	d7 01       	movw	r26, r14
     264:	6d 91       	ld	r22, X+
     266:	7c 91       	ld	r23, X
     268:	72 60       	ori	r23, 0x02	; 2
     26a:	cf 01       	movw	r24, r30
     26c:	0e 94 42 0a 	call	0x1484	; 0x1484 <xTaskRemoveFromUnorderedEventList>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     270:	ec 2d       	mov	r30, r12
     272:	fd 2d       	mov	r31, r13

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     274:	ec 17       	cp	r30, r28
     276:	fd 07       	cpc	r31, r29
     278:	81 f6       	brne	.-96     	; 0x21a <xEventGroupSetBits+0x3a>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     27a:	00 95       	com	r16
     27c:	10 95       	com	r17
     27e:	f7 01       	movw	r30, r14
     280:	80 81       	ld	r24, Z
     282:	91 81       	ldd	r25, Z+1	; 0x01
     284:	08 23       	and	r16, r24
     286:	19 23       	and	r17, r25
     288:	11 83       	std	Z+1, r17	; 0x01
     28a:	00 83       	st	Z, r16
	}
	( void ) xTaskResumeAll();
     28c:	0e 94 93 08 	call	0x1126	; 0x1126 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
     290:	d7 01       	movw	r26, r14
     292:	8d 91       	ld	r24, X+
     294:	9c 91       	ld	r25, X
     296:	df 91       	pop	r29
     298:	cf 91       	pop	r28
     29a:	1f 91       	pop	r17
     29c:	0f 91       	pop	r16
     29e:	ff 90       	pop	r15
     2a0:	ef 90       	pop	r14
     2a2:	df 90       	pop	r13
     2a4:	cf 90       	pop	r12
     2a6:	08 95       	ret

000002a8 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     2a8:	cf 93       	push	r28
     2aa:	df 93       	push	r29
     2ac:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     2ae:	0e 94 d1 07 	call	0xfa2	; 0xfa2 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     2b2:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <__data_end>
     2b6:	90 91 17 01 	lds	r25, 0x0117	; 0x800117 <__data_end+0x1>
     2ba:	89 2b       	or	r24, r25
     2bc:	31 f4       	brne	.+12     	; 0x2ca <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     2be:	8b e1       	ldi	r24, 0x1B	; 27
     2c0:	91 e0       	ldi	r25, 0x01	; 1
     2c2:	90 93 17 01 	sts	0x0117, r25	; 0x800117 <__data_end+0x1>
     2c6:	80 93 16 01 	sts	0x0116, r24	; 0x800116 <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     2ca:	20 91 18 01 	lds	r18, 0x0118	; 0x800118 <xNextFreeByte>
     2ce:	30 91 19 01 	lds	r19, 0x0119	; 0x800119 <xNextFreeByte+0x1>
     2d2:	c9 01       	movw	r24, r18
     2d4:	8c 0f       	add	r24, r28
     2d6:	9d 1f       	adc	r25, r29
     2d8:	8b 34       	cpi	r24, 0x4B	; 75
     2da:	44 e0       	ldi	r20, 0x04	; 4
     2dc:	94 07       	cpc	r25, r20
     2de:	70 f4       	brcc	.+28     	; 0x2fc <pvPortMalloc+0x54>
     2e0:	28 17       	cp	r18, r24
     2e2:	39 07       	cpc	r19, r25
     2e4:	70 f4       	brcc	.+28     	; 0x302 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     2e6:	c0 91 16 01 	lds	r28, 0x0116	; 0x800116 <__data_end>
     2ea:	d0 91 17 01 	lds	r29, 0x0117	; 0x800117 <__data_end+0x1>
     2ee:	c2 0f       	add	r28, r18
     2f0:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     2f2:	90 93 19 01 	sts	0x0119, r25	; 0x800119 <xNextFreeByte+0x1>
     2f6:	80 93 18 01 	sts	0x0118, r24	; 0x800118 <xNextFreeByte>
     2fa:	05 c0       	rjmp	.+10     	; 0x306 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     2fc:	c0 e0       	ldi	r28, 0x00	; 0
     2fe:	d0 e0       	ldi	r29, 0x00	; 0
     300:	02 c0       	rjmp	.+4      	; 0x306 <pvPortMalloc+0x5e>
     302:	c0 e0       	ldi	r28, 0x00	; 0
     304:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     306:	0e 94 93 08 	call	0x1126	; 0x1126 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     30a:	ce 01       	movw	r24, r28
     30c:	df 91       	pop	r29
     30e:	cf 91       	pop	r28
     310:	08 95       	ret

00000312 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     312:	08 95       	ret

00000314 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     314:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     316:	03 96       	adiw	r24, 0x03	; 3
     318:	92 83       	std	Z+2, r25	; 0x02
     31a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     31c:	2f ef       	ldi	r18, 0xFF	; 255
     31e:	3f ef       	ldi	r19, 0xFF	; 255
     320:	34 83       	std	Z+4, r19	; 0x04
     322:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     324:	96 83       	std	Z+6, r25	; 0x06
     326:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     328:	90 87       	std	Z+8, r25	; 0x08
     32a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     32c:	10 82       	st	Z, r1
     32e:	08 95       	ret

00000330 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     330:	fc 01       	movw	r30, r24
     332:	11 86       	std	Z+9, r1	; 0x09
     334:	10 86       	std	Z+8, r1	; 0x08
     336:	08 95       	ret

00000338 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     338:	cf 93       	push	r28
     33a:	df 93       	push	r29
     33c:	9c 01       	movw	r18, r24
     33e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     340:	dc 01       	movw	r26, r24
     342:	11 96       	adiw	r26, 0x01	; 1
     344:	cd 91       	ld	r28, X+
     346:	dc 91       	ld	r29, X
     348:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     34a:	d3 83       	std	Z+3, r29	; 0x03
     34c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     34e:	8c 81       	ldd	r24, Y+4	; 0x04
     350:	9d 81       	ldd	r25, Y+5	; 0x05
     352:	95 83       	std	Z+5, r25	; 0x05
     354:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     356:	8c 81       	ldd	r24, Y+4	; 0x04
     358:	9d 81       	ldd	r25, Y+5	; 0x05
     35a:	dc 01       	movw	r26, r24
     35c:	13 96       	adiw	r26, 0x03	; 3
     35e:	7c 93       	st	X, r23
     360:	6e 93       	st	-X, r22
     362:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     364:	7d 83       	std	Y+5, r23	; 0x05
     366:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     368:	31 87       	std	Z+9, r19	; 0x09
     36a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     36c:	f9 01       	movw	r30, r18
     36e:	80 81       	ld	r24, Z
     370:	8f 5f       	subi	r24, 0xFF	; 255
     372:	80 83       	st	Z, r24
}
     374:	df 91       	pop	r29
     376:	cf 91       	pop	r28
     378:	08 95       	ret

0000037a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     37a:	cf 93       	push	r28
     37c:	df 93       	push	r29
     37e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     380:	48 81       	ld	r20, Y
     382:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     384:	4f 3f       	cpi	r20, 0xFF	; 255
     386:	2f ef       	ldi	r18, 0xFF	; 255
     388:	52 07       	cpc	r21, r18
     38a:	21 f4       	brne	.+8      	; 0x394 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     38c:	fc 01       	movw	r30, r24
     38e:	a7 81       	ldd	r26, Z+7	; 0x07
     390:	b0 85       	ldd	r27, Z+8	; 0x08
     392:	0d c0       	rjmp	.+26     	; 0x3ae <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     394:	dc 01       	movw	r26, r24
     396:	13 96       	adiw	r26, 0x03	; 3
     398:	01 c0       	rjmp	.+2      	; 0x39c <vListInsert+0x22>
     39a:	df 01       	movw	r26, r30
     39c:	12 96       	adiw	r26, 0x02	; 2
     39e:	ed 91       	ld	r30, X+
     3a0:	fc 91       	ld	r31, X
     3a2:	13 97       	sbiw	r26, 0x03	; 3
     3a4:	20 81       	ld	r18, Z
     3a6:	31 81       	ldd	r19, Z+1	; 0x01
     3a8:	42 17       	cp	r20, r18
     3aa:	53 07       	cpc	r21, r19
     3ac:	b0 f7       	brcc	.-20     	; 0x39a <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     3ae:	12 96       	adiw	r26, 0x02	; 2
     3b0:	ed 91       	ld	r30, X+
     3b2:	fc 91       	ld	r31, X
     3b4:	13 97       	sbiw	r26, 0x03	; 3
     3b6:	fb 83       	std	Y+3, r31	; 0x03
     3b8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     3ba:	d5 83       	std	Z+5, r29	; 0x05
     3bc:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     3be:	bd 83       	std	Y+5, r27	; 0x05
     3c0:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     3c2:	13 96       	adiw	r26, 0x03	; 3
     3c4:	dc 93       	st	X, r29
     3c6:	ce 93       	st	-X, r28
     3c8:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     3ca:	99 87       	std	Y+9, r25	; 0x09
     3cc:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     3ce:	fc 01       	movw	r30, r24
     3d0:	20 81       	ld	r18, Z
     3d2:	2f 5f       	subi	r18, 0xFF	; 255
     3d4:	20 83       	st	Z, r18
}
     3d6:	df 91       	pop	r29
     3d8:	cf 91       	pop	r28
     3da:	08 95       	ret

000003dc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     3dc:	cf 93       	push	r28
     3de:	df 93       	push	r29
     3e0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     3e2:	a0 85       	ldd	r26, Z+8	; 0x08
     3e4:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     3e6:	c2 81       	ldd	r28, Z+2	; 0x02
     3e8:	d3 81       	ldd	r29, Z+3	; 0x03
     3ea:	84 81       	ldd	r24, Z+4	; 0x04
     3ec:	95 81       	ldd	r25, Z+5	; 0x05
     3ee:	9d 83       	std	Y+5, r25	; 0x05
     3f0:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     3f2:	c4 81       	ldd	r28, Z+4	; 0x04
     3f4:	d5 81       	ldd	r29, Z+5	; 0x05
     3f6:	82 81       	ldd	r24, Z+2	; 0x02
     3f8:	93 81       	ldd	r25, Z+3	; 0x03
     3fa:	9b 83       	std	Y+3, r25	; 0x03
     3fc:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     3fe:	11 96       	adiw	r26, 0x01	; 1
     400:	8d 91       	ld	r24, X+
     402:	9c 91       	ld	r25, X
     404:	12 97       	sbiw	r26, 0x02	; 2
     406:	e8 17       	cp	r30, r24
     408:	f9 07       	cpc	r31, r25
     40a:	31 f4       	brne	.+12     	; 0x418 <__EEPROM_REGION_LENGTH__+0x18>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     40c:	84 81       	ldd	r24, Z+4	; 0x04
     40e:	95 81       	ldd	r25, Z+5	; 0x05
     410:	12 96       	adiw	r26, 0x02	; 2
     412:	9c 93       	st	X, r25
     414:	8e 93       	st	-X, r24
     416:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     418:	11 86       	std	Z+9, r1	; 0x09
     41a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     41c:	8c 91       	ld	r24, X
     41e:	81 50       	subi	r24, 0x01	; 1
     420:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     422:	df 91       	pop	r29
     424:	cf 91       	pop	r28
     426:	08 95       	ret

00000428 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     428:	1b bc       	out	0x2b, r1	; 43
     42a:	8c e7       	ldi	r24, 0x7C	; 124
     42c:	8a bd       	out	0x2a, r24	; 42
     42e:	8b e0       	ldi	r24, 0x0B	; 11
     430:	8e bd       	out	0x2e, r24	; 46
     432:	89 b7       	in	r24, 0x39	; 57
     434:	80 61       	ori	r24, 0x10	; 16
     436:	89 bf       	out	0x39, r24	; 57
     438:	08 95       	ret

0000043a <pxPortInitialiseStack>:
     43a:	31 e1       	ldi	r19, 0x11	; 17
     43c:	fc 01       	movw	r30, r24
     43e:	30 83       	st	Z, r19
     440:	31 97       	sbiw	r30, 0x01	; 1
     442:	22 e2       	ldi	r18, 0x22	; 34
     444:	20 83       	st	Z, r18
     446:	31 97       	sbiw	r30, 0x01	; 1
     448:	a3 e3       	ldi	r26, 0x33	; 51
     44a:	a0 83       	st	Z, r26
     44c:	31 97       	sbiw	r30, 0x01	; 1
     44e:	60 83       	st	Z, r22
     450:	31 97       	sbiw	r30, 0x01	; 1
     452:	70 83       	st	Z, r23
     454:	31 97       	sbiw	r30, 0x01	; 1
     456:	10 82       	st	Z, r1
     458:	31 97       	sbiw	r30, 0x01	; 1
     45a:	60 e8       	ldi	r22, 0x80	; 128
     45c:	60 83       	st	Z, r22
     45e:	31 97       	sbiw	r30, 0x01	; 1
     460:	10 82       	st	Z, r1
     462:	31 97       	sbiw	r30, 0x01	; 1
     464:	62 e0       	ldi	r22, 0x02	; 2
     466:	60 83       	st	Z, r22
     468:	31 97       	sbiw	r30, 0x01	; 1
     46a:	63 e0       	ldi	r22, 0x03	; 3
     46c:	60 83       	st	Z, r22
     46e:	31 97       	sbiw	r30, 0x01	; 1
     470:	64 e0       	ldi	r22, 0x04	; 4
     472:	60 83       	st	Z, r22
     474:	31 97       	sbiw	r30, 0x01	; 1
     476:	65 e0       	ldi	r22, 0x05	; 5
     478:	60 83       	st	Z, r22
     47a:	31 97       	sbiw	r30, 0x01	; 1
     47c:	66 e0       	ldi	r22, 0x06	; 6
     47e:	60 83       	st	Z, r22
     480:	31 97       	sbiw	r30, 0x01	; 1
     482:	67 e0       	ldi	r22, 0x07	; 7
     484:	60 83       	st	Z, r22
     486:	31 97       	sbiw	r30, 0x01	; 1
     488:	68 e0       	ldi	r22, 0x08	; 8
     48a:	60 83       	st	Z, r22
     48c:	31 97       	sbiw	r30, 0x01	; 1
     48e:	69 e0       	ldi	r22, 0x09	; 9
     490:	60 83       	st	Z, r22
     492:	31 97       	sbiw	r30, 0x01	; 1
     494:	60 e1       	ldi	r22, 0x10	; 16
     496:	60 83       	st	Z, r22
     498:	31 97       	sbiw	r30, 0x01	; 1
     49a:	30 83       	st	Z, r19
     49c:	31 97       	sbiw	r30, 0x01	; 1
     49e:	32 e1       	ldi	r19, 0x12	; 18
     4a0:	30 83       	st	Z, r19
     4a2:	31 97       	sbiw	r30, 0x01	; 1
     4a4:	33 e1       	ldi	r19, 0x13	; 19
     4a6:	30 83       	st	Z, r19
     4a8:	31 97       	sbiw	r30, 0x01	; 1
     4aa:	34 e1       	ldi	r19, 0x14	; 20
     4ac:	30 83       	st	Z, r19
     4ae:	31 97       	sbiw	r30, 0x01	; 1
     4b0:	35 e1       	ldi	r19, 0x15	; 21
     4b2:	30 83       	st	Z, r19
     4b4:	31 97       	sbiw	r30, 0x01	; 1
     4b6:	36 e1       	ldi	r19, 0x16	; 22
     4b8:	30 83       	st	Z, r19
     4ba:	31 97       	sbiw	r30, 0x01	; 1
     4bc:	37 e1       	ldi	r19, 0x17	; 23
     4be:	30 83       	st	Z, r19
     4c0:	31 97       	sbiw	r30, 0x01	; 1
     4c2:	38 e1       	ldi	r19, 0x18	; 24
     4c4:	30 83       	st	Z, r19
     4c6:	31 97       	sbiw	r30, 0x01	; 1
     4c8:	39 e1       	ldi	r19, 0x19	; 25
     4ca:	30 83       	st	Z, r19
     4cc:	31 97       	sbiw	r30, 0x01	; 1
     4ce:	30 e2       	ldi	r19, 0x20	; 32
     4d0:	30 83       	st	Z, r19
     4d2:	31 97       	sbiw	r30, 0x01	; 1
     4d4:	31 e2       	ldi	r19, 0x21	; 33
     4d6:	30 83       	st	Z, r19
     4d8:	31 97       	sbiw	r30, 0x01	; 1
     4da:	20 83       	st	Z, r18
     4dc:	31 97       	sbiw	r30, 0x01	; 1
     4de:	23 e2       	ldi	r18, 0x23	; 35
     4e0:	20 83       	st	Z, r18
     4e2:	31 97       	sbiw	r30, 0x01	; 1
     4e4:	40 83       	st	Z, r20
     4e6:	31 97       	sbiw	r30, 0x01	; 1
     4e8:	50 83       	st	Z, r21
     4ea:	31 97       	sbiw	r30, 0x01	; 1
     4ec:	26 e2       	ldi	r18, 0x26	; 38
     4ee:	20 83       	st	Z, r18
     4f0:	31 97       	sbiw	r30, 0x01	; 1
     4f2:	27 e2       	ldi	r18, 0x27	; 39
     4f4:	20 83       	st	Z, r18
     4f6:	31 97       	sbiw	r30, 0x01	; 1
     4f8:	28 e2       	ldi	r18, 0x28	; 40
     4fa:	20 83       	st	Z, r18
     4fc:	31 97       	sbiw	r30, 0x01	; 1
     4fe:	29 e2       	ldi	r18, 0x29	; 41
     500:	20 83       	st	Z, r18
     502:	31 97       	sbiw	r30, 0x01	; 1
     504:	20 e3       	ldi	r18, 0x30	; 48
     506:	20 83       	st	Z, r18
     508:	31 97       	sbiw	r30, 0x01	; 1
     50a:	21 e3       	ldi	r18, 0x31	; 49
     50c:	20 83       	st	Z, r18
     50e:	86 97       	sbiw	r24, 0x26	; 38
     510:	08 95       	ret

00000512 <xPortStartScheduler>:
     512:	0e 94 14 02 	call	0x428	; 0x428 <prvSetupTimerInterrupt>
     516:	a0 91 e1 05 	lds	r26, 0x05E1	; 0x8005e1 <pxCurrentTCB>
     51a:	b0 91 e2 05 	lds	r27, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
     51e:	cd 91       	ld	r28, X+
     520:	cd bf       	out	0x3d, r28	; 61
     522:	dd 91       	ld	r29, X+
     524:	de bf       	out	0x3e, r29	; 62
     526:	ff 91       	pop	r31
     528:	ef 91       	pop	r30
     52a:	df 91       	pop	r29
     52c:	cf 91       	pop	r28
     52e:	bf 91       	pop	r27
     530:	af 91       	pop	r26
     532:	9f 91       	pop	r25
     534:	8f 91       	pop	r24
     536:	7f 91       	pop	r23
     538:	6f 91       	pop	r22
     53a:	5f 91       	pop	r21
     53c:	4f 91       	pop	r20
     53e:	3f 91       	pop	r19
     540:	2f 91       	pop	r18
     542:	1f 91       	pop	r17
     544:	0f 91       	pop	r16
     546:	ff 90       	pop	r15
     548:	ef 90       	pop	r14
     54a:	df 90       	pop	r13
     54c:	cf 90       	pop	r12
     54e:	bf 90       	pop	r11
     550:	af 90       	pop	r10
     552:	9f 90       	pop	r9
     554:	8f 90       	pop	r8
     556:	7f 90       	pop	r7
     558:	6f 90       	pop	r6
     55a:	5f 90       	pop	r5
     55c:	4f 90       	pop	r4
     55e:	3f 90       	pop	r3
     560:	2f 90       	pop	r2
     562:	1f 90       	pop	r1
     564:	0f 90       	pop	r0
     566:	0f be       	out	0x3f, r0	; 63
     568:	0f 90       	pop	r0
     56a:	08 95       	ret
     56c:	81 e0       	ldi	r24, 0x01	; 1
     56e:	08 95       	ret

00000570 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     570:	0f 92       	push	r0
     572:	0f b6       	in	r0, 0x3f	; 63
     574:	f8 94       	cli
     576:	0f 92       	push	r0
     578:	1f 92       	push	r1
     57a:	11 24       	eor	r1, r1
     57c:	2f 92       	push	r2
     57e:	3f 92       	push	r3
     580:	4f 92       	push	r4
     582:	5f 92       	push	r5
     584:	6f 92       	push	r6
     586:	7f 92       	push	r7
     588:	8f 92       	push	r8
     58a:	9f 92       	push	r9
     58c:	af 92       	push	r10
     58e:	bf 92       	push	r11
     590:	cf 92       	push	r12
     592:	df 92       	push	r13
     594:	ef 92       	push	r14
     596:	ff 92       	push	r15
     598:	0f 93       	push	r16
     59a:	1f 93       	push	r17
     59c:	2f 93       	push	r18
     59e:	3f 93       	push	r19
     5a0:	4f 93       	push	r20
     5a2:	5f 93       	push	r21
     5a4:	6f 93       	push	r22
     5a6:	7f 93       	push	r23
     5a8:	8f 93       	push	r24
     5aa:	9f 93       	push	r25
     5ac:	af 93       	push	r26
     5ae:	bf 93       	push	r27
     5b0:	cf 93       	push	r28
     5b2:	df 93       	push	r29
     5b4:	ef 93       	push	r30
     5b6:	ff 93       	push	r31
     5b8:	a0 91 e1 05 	lds	r26, 0x05E1	; 0x8005e1 <pxCurrentTCB>
     5bc:	b0 91 e2 05 	lds	r27, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
     5c0:	0d b6       	in	r0, 0x3d	; 61
     5c2:	0d 92       	st	X+, r0
     5c4:	0e b6       	in	r0, 0x3e	; 62
     5c6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     5c8:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     5cc:	a0 91 e1 05 	lds	r26, 0x05E1	; 0x8005e1 <pxCurrentTCB>
     5d0:	b0 91 e2 05 	lds	r27, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
     5d4:	cd 91       	ld	r28, X+
     5d6:	cd bf       	out	0x3d, r28	; 61
     5d8:	dd 91       	ld	r29, X+
     5da:	de bf       	out	0x3e, r29	; 62
     5dc:	ff 91       	pop	r31
     5de:	ef 91       	pop	r30
     5e0:	df 91       	pop	r29
     5e2:	cf 91       	pop	r28
     5e4:	bf 91       	pop	r27
     5e6:	af 91       	pop	r26
     5e8:	9f 91       	pop	r25
     5ea:	8f 91       	pop	r24
     5ec:	7f 91       	pop	r23
     5ee:	6f 91       	pop	r22
     5f0:	5f 91       	pop	r21
     5f2:	4f 91       	pop	r20
     5f4:	3f 91       	pop	r19
     5f6:	2f 91       	pop	r18
     5f8:	1f 91       	pop	r17
     5fa:	0f 91       	pop	r16
     5fc:	ff 90       	pop	r15
     5fe:	ef 90       	pop	r14
     600:	df 90       	pop	r13
     602:	cf 90       	pop	r12
     604:	bf 90       	pop	r11
     606:	af 90       	pop	r10
     608:	9f 90       	pop	r9
     60a:	8f 90       	pop	r8
     60c:	7f 90       	pop	r7
     60e:	6f 90       	pop	r6
     610:	5f 90       	pop	r5
     612:	4f 90       	pop	r4
     614:	3f 90       	pop	r3
     616:	2f 90       	pop	r2
     618:	1f 90       	pop	r1
     61a:	0f 90       	pop	r0
     61c:	0f be       	out	0x3f, r0	; 63
     61e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     620:	08 95       	ret

00000622 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     622:	0f 92       	push	r0
     624:	0f b6       	in	r0, 0x3f	; 63
     626:	f8 94       	cli
     628:	0f 92       	push	r0
     62a:	1f 92       	push	r1
     62c:	11 24       	eor	r1, r1
     62e:	2f 92       	push	r2
     630:	3f 92       	push	r3
     632:	4f 92       	push	r4
     634:	5f 92       	push	r5
     636:	6f 92       	push	r6
     638:	7f 92       	push	r7
     63a:	8f 92       	push	r8
     63c:	9f 92       	push	r9
     63e:	af 92       	push	r10
     640:	bf 92       	push	r11
     642:	cf 92       	push	r12
     644:	df 92       	push	r13
     646:	ef 92       	push	r14
     648:	ff 92       	push	r15
     64a:	0f 93       	push	r16
     64c:	1f 93       	push	r17
     64e:	2f 93       	push	r18
     650:	3f 93       	push	r19
     652:	4f 93       	push	r20
     654:	5f 93       	push	r21
     656:	6f 93       	push	r22
     658:	7f 93       	push	r23
     65a:	8f 93       	push	r24
     65c:	9f 93       	push	r25
     65e:	af 93       	push	r26
     660:	bf 93       	push	r27
     662:	cf 93       	push	r28
     664:	df 93       	push	r29
     666:	ef 93       	push	r30
     668:	ff 93       	push	r31
     66a:	a0 91 e1 05 	lds	r26, 0x05E1	; 0x8005e1 <pxCurrentTCB>
     66e:	b0 91 e2 05 	lds	r27, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
     672:	0d b6       	in	r0, 0x3d	; 61
     674:	0d 92       	st	X+, r0
     676:	0e b6       	in	r0, 0x3e	; 62
     678:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     67a:	0e 94 d7 07 	call	0xfae	; 0xfae <xTaskIncrementTick>
     67e:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     680:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     684:	a0 91 e1 05 	lds	r26, 0x05E1	; 0x8005e1 <pxCurrentTCB>
     688:	b0 91 e2 05 	lds	r27, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
     68c:	cd 91       	ld	r28, X+
     68e:	cd bf       	out	0x3d, r28	; 61
     690:	dd 91       	ld	r29, X+
     692:	de bf       	out	0x3e, r29	; 62
     694:	ff 91       	pop	r31
     696:	ef 91       	pop	r30
     698:	df 91       	pop	r29
     69a:	cf 91       	pop	r28
     69c:	bf 91       	pop	r27
     69e:	af 91       	pop	r26
     6a0:	9f 91       	pop	r25
     6a2:	8f 91       	pop	r24
     6a4:	7f 91       	pop	r23
     6a6:	6f 91       	pop	r22
     6a8:	5f 91       	pop	r21
     6aa:	4f 91       	pop	r20
     6ac:	3f 91       	pop	r19
     6ae:	2f 91       	pop	r18
     6b0:	1f 91       	pop	r17
     6b2:	0f 91       	pop	r16
     6b4:	ff 90       	pop	r15
     6b6:	ef 90       	pop	r14
     6b8:	df 90       	pop	r13
     6ba:	cf 90       	pop	r12
     6bc:	bf 90       	pop	r11
     6be:	af 90       	pop	r10
     6c0:	9f 90       	pop	r9
     6c2:	8f 90       	pop	r8
     6c4:	7f 90       	pop	r7
     6c6:	6f 90       	pop	r6
     6c8:	5f 90       	pop	r5
     6ca:	4f 90       	pop	r4
     6cc:	3f 90       	pop	r3
     6ce:	2f 90       	pop	r2
     6d0:	1f 90       	pop	r1
     6d2:	0f 90       	pop	r0
     6d4:	0f be       	out	0x3f, r0	; 63
     6d6:	0f 90       	pop	r0

	asm volatile ( "ret" );
     6d8:	08 95       	ret

000006da <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     6da:	0e 94 11 03 	call	0x622	; 0x622 <vPortYieldFromTick>
		asm volatile ( "reti" );
     6de:	18 95       	reti

000006e0 <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     6e0:	0f b6       	in	r0, 0x3f	; 63
     6e2:	f8 94       	cli
     6e4:	0f 92       	push	r0
     6e6:	fc 01       	movw	r30, r24
     6e8:	82 8d       	ldd	r24, Z+26	; 0x1a
     6ea:	81 11       	cpse	r24, r1
     6ec:	02 c0       	rjmp	.+4      	; 0x6f2 <prvIsQueueEmpty+0x12>
     6ee:	81 e0       	ldi	r24, 0x01	; 1
     6f0:	01 c0       	rjmp	.+2      	; 0x6f4 <prvIsQueueEmpty+0x14>
     6f2:	80 e0       	ldi	r24, 0x00	; 0
     6f4:	0f 90       	pop	r0
     6f6:	0f be       	out	0x3f, r0	; 63
     6f8:	08 95       	ret

000006fa <prvIsQueueFull>:
     6fa:	0f b6       	in	r0, 0x3f	; 63
     6fc:	f8 94       	cli
     6fe:	0f 92       	push	r0
     700:	fc 01       	movw	r30, r24
     702:	22 8d       	ldd	r18, Z+26	; 0x1a
     704:	83 8d       	ldd	r24, Z+27	; 0x1b
     706:	28 13       	cpse	r18, r24
     708:	02 c0       	rjmp	.+4      	; 0x70e <prvIsQueueFull+0x14>
     70a:	81 e0       	ldi	r24, 0x01	; 1
     70c:	01 c0       	rjmp	.+2      	; 0x710 <prvIsQueueFull+0x16>
     70e:	80 e0       	ldi	r24, 0x00	; 0
     710:	0f 90       	pop	r0
     712:	0f be       	out	0x3f, r0	; 63
     714:	08 95       	ret

00000716 <prvCopyDataToQueue>:
     716:	1f 93       	push	r17
     718:	cf 93       	push	r28
     71a:	df 93       	push	r29
     71c:	ec 01       	movw	r28, r24
     71e:	14 2f       	mov	r17, r20
     720:	4c 8d       	ldd	r20, Y+28	; 0x1c
     722:	41 11       	cpse	r20, r1
     724:	0c c0       	rjmp	.+24     	; 0x73e <prvCopyDataToQueue+0x28>
     726:	88 81       	ld	r24, Y
     728:	99 81       	ldd	r25, Y+1	; 0x01
     72a:	89 2b       	or	r24, r25
     72c:	09 f0       	breq	.+2      	; 0x730 <prvCopyDataToQueue+0x1a>
     72e:	45 c0       	rjmp	.+138    	; 0x7ba <prvCopyDataToQueue+0xa4>
     730:	8a 81       	ldd	r24, Y+2	; 0x02
     732:	9b 81       	ldd	r25, Y+3	; 0x03
     734:	0e 94 1f 0b 	call	0x163e	; 0x163e <xTaskPriorityDisinherit>
     738:	1b 82       	std	Y+3, r1	; 0x03
     73a:	1a 82       	std	Y+2, r1	; 0x02
     73c:	45 c0       	rjmp	.+138    	; 0x7c8 <prvCopyDataToQueue+0xb2>
     73e:	11 11       	cpse	r17, r1
     740:	17 c0       	rjmp	.+46     	; 0x770 <prvCopyDataToQueue+0x5a>
     742:	50 e0       	ldi	r21, 0x00	; 0
     744:	8c 81       	ldd	r24, Y+4	; 0x04
     746:	9d 81       	ldd	r25, Y+5	; 0x05
     748:	0e 94 f6 12 	call	0x25ec	; 0x25ec <memcpy>
     74c:	2c 8d       	ldd	r18, Y+28	; 0x1c
     74e:	8c 81       	ldd	r24, Y+4	; 0x04
     750:	9d 81       	ldd	r25, Y+5	; 0x05
     752:	82 0f       	add	r24, r18
     754:	91 1d       	adc	r25, r1
     756:	9d 83       	std	Y+5, r25	; 0x05
     758:	8c 83       	std	Y+4, r24	; 0x04
     75a:	2a 81       	ldd	r18, Y+2	; 0x02
     75c:	3b 81       	ldd	r19, Y+3	; 0x03
     75e:	82 17       	cp	r24, r18
     760:	93 07       	cpc	r25, r19
     762:	68 f1       	brcs	.+90     	; 0x7be <prvCopyDataToQueue+0xa8>
     764:	88 81       	ld	r24, Y
     766:	99 81       	ldd	r25, Y+1	; 0x01
     768:	9d 83       	std	Y+5, r25	; 0x05
     76a:	8c 83       	std	Y+4, r24	; 0x04
     76c:	80 e0       	ldi	r24, 0x00	; 0
     76e:	2c c0       	rjmp	.+88     	; 0x7c8 <prvCopyDataToQueue+0xb2>
     770:	50 e0       	ldi	r21, 0x00	; 0
     772:	8e 81       	ldd	r24, Y+6	; 0x06
     774:	9f 81       	ldd	r25, Y+7	; 0x07
     776:	0e 94 f6 12 	call	0x25ec	; 0x25ec <memcpy>
     77a:	8c 8d       	ldd	r24, Y+28	; 0x1c
     77c:	90 e0       	ldi	r25, 0x00	; 0
     77e:	91 95       	neg	r25
     780:	81 95       	neg	r24
     782:	91 09       	sbc	r25, r1
     784:	2e 81       	ldd	r18, Y+6	; 0x06
     786:	3f 81       	ldd	r19, Y+7	; 0x07
     788:	28 0f       	add	r18, r24
     78a:	39 1f       	adc	r19, r25
     78c:	3f 83       	std	Y+7, r19	; 0x07
     78e:	2e 83       	std	Y+6, r18	; 0x06
     790:	48 81       	ld	r20, Y
     792:	59 81       	ldd	r21, Y+1	; 0x01
     794:	24 17       	cp	r18, r20
     796:	35 07       	cpc	r19, r21
     798:	30 f4       	brcc	.+12     	; 0x7a6 <prvCopyDataToQueue+0x90>
     79a:	2a 81       	ldd	r18, Y+2	; 0x02
     79c:	3b 81       	ldd	r19, Y+3	; 0x03
     79e:	82 0f       	add	r24, r18
     7a0:	93 1f       	adc	r25, r19
     7a2:	9f 83       	std	Y+7, r25	; 0x07
     7a4:	8e 83       	std	Y+6, r24	; 0x06
     7a6:	12 30       	cpi	r17, 0x02	; 2
     7a8:	61 f4       	brne	.+24     	; 0x7c2 <prvCopyDataToQueue+0xac>
     7aa:	8a 8d       	ldd	r24, Y+26	; 0x1a
     7ac:	88 23       	and	r24, r24
     7ae:	59 f0       	breq	.+22     	; 0x7c6 <prvCopyDataToQueue+0xb0>
     7b0:	8a 8d       	ldd	r24, Y+26	; 0x1a
     7b2:	81 50       	subi	r24, 0x01	; 1
     7b4:	8a 8f       	std	Y+26, r24	; 0x1a
     7b6:	80 e0       	ldi	r24, 0x00	; 0
     7b8:	07 c0       	rjmp	.+14     	; 0x7c8 <prvCopyDataToQueue+0xb2>
     7ba:	80 e0       	ldi	r24, 0x00	; 0
     7bc:	05 c0       	rjmp	.+10     	; 0x7c8 <prvCopyDataToQueue+0xb2>
     7be:	80 e0       	ldi	r24, 0x00	; 0
     7c0:	03 c0       	rjmp	.+6      	; 0x7c8 <prvCopyDataToQueue+0xb2>
     7c2:	80 e0       	ldi	r24, 0x00	; 0
     7c4:	01 c0       	rjmp	.+2      	; 0x7c8 <prvCopyDataToQueue+0xb2>
     7c6:	80 e0       	ldi	r24, 0x00	; 0
     7c8:	9a 8d       	ldd	r25, Y+26	; 0x1a
     7ca:	9f 5f       	subi	r25, 0xFF	; 255
     7cc:	9a 8f       	std	Y+26, r25	; 0x1a
     7ce:	df 91       	pop	r29
     7d0:	cf 91       	pop	r28
     7d2:	1f 91       	pop	r17
     7d4:	08 95       	ret

000007d6 <prvCopyDataFromQueue>:
     7d6:	fc 01       	movw	r30, r24
     7d8:	44 8d       	ldd	r20, Z+28	; 0x1c
     7da:	44 23       	and	r20, r20
     7dc:	a9 f0       	breq	.+42     	; 0x808 <__DATA_REGION_LENGTH__+0x8>
     7de:	50 e0       	ldi	r21, 0x00	; 0
     7e0:	26 81       	ldd	r18, Z+6	; 0x06
     7e2:	37 81       	ldd	r19, Z+7	; 0x07
     7e4:	24 0f       	add	r18, r20
     7e6:	35 1f       	adc	r19, r21
     7e8:	37 83       	std	Z+7, r19	; 0x07
     7ea:	26 83       	std	Z+6, r18	; 0x06
     7ec:	82 81       	ldd	r24, Z+2	; 0x02
     7ee:	93 81       	ldd	r25, Z+3	; 0x03
     7f0:	28 17       	cp	r18, r24
     7f2:	39 07       	cpc	r19, r25
     7f4:	20 f0       	brcs	.+8      	; 0x7fe <prvCopyDataFromQueue+0x28>
     7f6:	80 81       	ld	r24, Z
     7f8:	91 81       	ldd	r25, Z+1	; 0x01
     7fa:	97 83       	std	Z+7, r25	; 0x07
     7fc:	86 83       	std	Z+6, r24	; 0x06
     7fe:	cb 01       	movw	r24, r22
     800:	66 81       	ldd	r22, Z+6	; 0x06
     802:	77 81       	ldd	r23, Z+7	; 0x07
     804:	0e 94 f6 12 	call	0x25ec	; 0x25ec <memcpy>
     808:	08 95       	ret

0000080a <prvUnlockQueue>:
     80a:	cf 93       	push	r28
     80c:	df 93       	push	r29
     80e:	ec 01       	movw	r28, r24
     810:	0f b6       	in	r0, 0x3f	; 63
     812:	f8 94       	cli
     814:	0f 92       	push	r0
     816:	0d c0       	rjmp	.+26     	; 0x832 <prvUnlockQueue+0x28>
     818:	89 89       	ldd	r24, Y+17	; 0x11
     81a:	88 23       	and	r24, r24
     81c:	69 f0       	breq	.+26     	; 0x838 <prvUnlockQueue+0x2e>
     81e:	ce 01       	movw	r24, r28
     820:	41 96       	adiw	r24, 0x11	; 17
     822:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <xTaskRemoveFromEventList>
     826:	81 11       	cpse	r24, r1
     828:	0e 94 b9 0a 	call	0x1572	; 0x1572 <vTaskMissedYield>
     82c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     82e:	81 50       	subi	r24, 0x01	; 1
     830:	8e 8f       	std	Y+30, r24	; 0x1e
     832:	8e 8d       	ldd	r24, Y+30	; 0x1e
     834:	18 16       	cp	r1, r24
     836:	84 f3       	brlt	.-32     	; 0x818 <prvUnlockQueue+0xe>
     838:	8f ef       	ldi	r24, 0xFF	; 255
     83a:	8e 8f       	std	Y+30, r24	; 0x1e
     83c:	0f 90       	pop	r0
     83e:	0f be       	out	0x3f, r0	; 63
     840:	0f b6       	in	r0, 0x3f	; 63
     842:	f8 94       	cli
     844:	0f 92       	push	r0
     846:	0d c0       	rjmp	.+26     	; 0x862 <__stack+0x3>
     848:	88 85       	ldd	r24, Y+8	; 0x08
     84a:	88 23       	and	r24, r24
     84c:	69 f0       	breq	.+26     	; 0x868 <__stack+0x9>
     84e:	ce 01       	movw	r24, r28
     850:	08 96       	adiw	r24, 0x08	; 8
     852:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <xTaskRemoveFromEventList>
     856:	81 11       	cpse	r24, r1
     858:	0e 94 b9 0a 	call	0x1572	; 0x1572 <vTaskMissedYield>
     85c:	8d 8d       	ldd	r24, Y+29	; 0x1d
     85e:	81 50       	subi	r24, 0x01	; 1
     860:	8d 8f       	std	Y+29, r24	; 0x1d
     862:	8d 8d       	ldd	r24, Y+29	; 0x1d
     864:	18 16       	cp	r1, r24
     866:	84 f3       	brlt	.-32     	; 0x848 <prvUnlockQueue+0x3e>
     868:	8f ef       	ldi	r24, 0xFF	; 255
     86a:	8d 8f       	std	Y+29, r24	; 0x1d
     86c:	0f 90       	pop	r0
     86e:	0f be       	out	0x3f, r0	; 63
     870:	df 91       	pop	r29
     872:	cf 91       	pop	r28
     874:	08 95       	ret

00000876 <xQueueGenericReset>:
     876:	cf 93       	push	r28
     878:	df 93       	push	r29
     87a:	ec 01       	movw	r28, r24
     87c:	0f b6       	in	r0, 0x3f	; 63
     87e:	f8 94       	cli
     880:	0f 92       	push	r0
     882:	e8 81       	ld	r30, Y
     884:	f9 81       	ldd	r31, Y+1	; 0x01
     886:	8b 8d       	ldd	r24, Y+27	; 0x1b
     888:	90 e0       	ldi	r25, 0x00	; 0
     88a:	2c 8d       	ldd	r18, Y+28	; 0x1c
     88c:	30 e0       	ldi	r19, 0x00	; 0
     88e:	82 9f       	mul	r24, r18
     890:	a0 01       	movw	r20, r0
     892:	83 9f       	mul	r24, r19
     894:	50 0d       	add	r21, r0
     896:	92 9f       	mul	r25, r18
     898:	50 0d       	add	r21, r0
     89a:	11 24       	eor	r1, r1
     89c:	4e 0f       	add	r20, r30
     89e:	5f 1f       	adc	r21, r31
     8a0:	5b 83       	std	Y+3, r21	; 0x03
     8a2:	4a 83       	std	Y+2, r20	; 0x02
     8a4:	1a 8e       	std	Y+26, r1	; 0x1a
     8a6:	fd 83       	std	Y+5, r31	; 0x05
     8a8:	ec 83       	std	Y+4, r30	; 0x04
     8aa:	01 97       	sbiw	r24, 0x01	; 1
     8ac:	28 9f       	mul	r18, r24
     8ae:	a0 01       	movw	r20, r0
     8b0:	29 9f       	mul	r18, r25
     8b2:	50 0d       	add	r21, r0
     8b4:	38 9f       	mul	r19, r24
     8b6:	50 0d       	add	r21, r0
     8b8:	11 24       	eor	r1, r1
     8ba:	cf 01       	movw	r24, r30
     8bc:	84 0f       	add	r24, r20
     8be:	95 1f       	adc	r25, r21
     8c0:	9f 83       	std	Y+7, r25	; 0x07
     8c2:	8e 83       	std	Y+6, r24	; 0x06
     8c4:	8f ef       	ldi	r24, 0xFF	; 255
     8c6:	8d 8f       	std	Y+29, r24	; 0x1d
     8c8:	8e 8f       	std	Y+30, r24	; 0x1e
     8ca:	61 11       	cpse	r22, r1
     8cc:	0c c0       	rjmp	.+24     	; 0x8e6 <xQueueGenericReset+0x70>
     8ce:	88 85       	ldd	r24, Y+8	; 0x08
     8d0:	88 23       	and	r24, r24
     8d2:	89 f0       	breq	.+34     	; 0x8f6 <xQueueGenericReset+0x80>
     8d4:	ce 01       	movw	r24, r28
     8d6:	08 96       	adiw	r24, 0x08	; 8
     8d8:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <xTaskRemoveFromEventList>
     8dc:	81 30       	cpi	r24, 0x01	; 1
     8de:	59 f4       	brne	.+22     	; 0x8f6 <xQueueGenericReset+0x80>
     8e0:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
     8e4:	08 c0       	rjmp	.+16     	; 0x8f6 <xQueueGenericReset+0x80>
     8e6:	ce 01       	movw	r24, r28
     8e8:	08 96       	adiw	r24, 0x08	; 8
     8ea:	0e 94 8a 01 	call	0x314	; 0x314 <vListInitialise>
     8ee:	ce 01       	movw	r24, r28
     8f0:	41 96       	adiw	r24, 0x11	; 17
     8f2:	0e 94 8a 01 	call	0x314	; 0x314 <vListInitialise>
     8f6:	0f 90       	pop	r0
     8f8:	0f be       	out	0x3f, r0	; 63
     8fa:	81 e0       	ldi	r24, 0x01	; 1
     8fc:	df 91       	pop	r29
     8fe:	cf 91       	pop	r28
     900:	08 95       	ret

00000902 <xQueueGenericCreate>:
     902:	0f 93       	push	r16
     904:	1f 93       	push	r17
     906:	cf 93       	push	r28
     908:	df 93       	push	r29
     90a:	88 23       	and	r24, r24
     90c:	01 f1       	breq	.+64     	; 0x94e <xQueueGenericCreate+0x4c>
     90e:	06 2f       	mov	r16, r22
     910:	18 2f       	mov	r17, r24
     912:	8f e1       	ldi	r24, 0x1F	; 31
     914:	90 e0       	ldi	r25, 0x00	; 0
     916:	0e 94 54 01 	call	0x2a8	; 0x2a8 <pvPortMalloc>
     91a:	ec 01       	movw	r28, r24
     91c:	89 2b       	or	r24, r25
     91e:	c9 f0       	breq	.+50     	; 0x952 <xQueueGenericCreate+0x50>
     920:	10 9f       	mul	r17, r16
     922:	c0 01       	movw	r24, r0
     924:	11 24       	eor	r1, r1
     926:	01 96       	adiw	r24, 0x01	; 1
     928:	0e 94 54 01 	call	0x2a8	; 0x2a8 <pvPortMalloc>
     92c:	99 83       	std	Y+1, r25	; 0x01
     92e:	88 83       	st	Y, r24
     930:	89 2b       	or	r24, r25
     932:	39 f0       	breq	.+14     	; 0x942 <xQueueGenericCreate+0x40>
     934:	1b 8f       	std	Y+27, r17	; 0x1b
     936:	0c 8f       	std	Y+28, r16	; 0x1c
     938:	61 e0       	ldi	r22, 0x01	; 1
     93a:	ce 01       	movw	r24, r28
     93c:	0e 94 3b 04 	call	0x876	; 0x876 <xQueueGenericReset>
     940:	08 c0       	rjmp	.+16     	; 0x952 <xQueueGenericCreate+0x50>
     942:	ce 01       	movw	r24, r28
     944:	0e 94 89 01 	call	0x312	; 0x312 <vPortFree>
     948:	c0 e0       	ldi	r28, 0x00	; 0
     94a:	d0 e0       	ldi	r29, 0x00	; 0
     94c:	02 c0       	rjmp	.+4      	; 0x952 <xQueueGenericCreate+0x50>
     94e:	c0 e0       	ldi	r28, 0x00	; 0
     950:	d0 e0       	ldi	r29, 0x00	; 0
     952:	ce 01       	movw	r24, r28
     954:	df 91       	pop	r29
     956:	cf 91       	pop	r28
     958:	1f 91       	pop	r17
     95a:	0f 91       	pop	r16
     95c:	08 95       	ret

0000095e <xQueueGenericSend>:
     95e:	cf 92       	push	r12
     960:	df 92       	push	r13
     962:	ef 92       	push	r14
     964:	ff 92       	push	r15
     966:	0f 93       	push	r16
     968:	1f 93       	push	r17
     96a:	cf 93       	push	r28
     96c:	df 93       	push	r29
     96e:	00 d0       	rcall	.+0      	; 0x970 <xQueueGenericSend+0x12>
     970:	00 d0       	rcall	.+0      	; 0x972 <xQueueGenericSend+0x14>
     972:	1f 92       	push	r1
     974:	cd b7       	in	r28, 0x3d	; 61
     976:	de b7       	in	r29, 0x3e	; 62
     978:	8c 01       	movw	r16, r24
     97a:	7b 01       	movw	r14, r22
     97c:	5d 83       	std	Y+5, r21	; 0x05
     97e:	4c 83       	std	Y+4, r20	; 0x04
     980:	c2 2e       	mov	r12, r18
     982:	d1 2c       	mov	r13, r1
     984:	0f b6       	in	r0, 0x3f	; 63
     986:	f8 94       	cli
     988:	0f 92       	push	r0
     98a:	f8 01       	movw	r30, r16
     98c:	92 8d       	ldd	r25, Z+26	; 0x1a
     98e:	83 8d       	ldd	r24, Z+27	; 0x1b
     990:	98 17       	cp	r25, r24
     992:	18 f0       	brcs	.+6      	; 0x99a <xQueueGenericSend+0x3c>
     994:	f2 e0       	ldi	r31, 0x02	; 2
     996:	cf 12       	cpse	r12, r31
     998:	19 c0       	rjmp	.+50     	; 0x9cc <xQueueGenericSend+0x6e>
     99a:	4c 2d       	mov	r20, r12
     99c:	b7 01       	movw	r22, r14
     99e:	c8 01       	movw	r24, r16
     9a0:	0e 94 8b 03 	call	0x716	; 0x716 <prvCopyDataToQueue>
     9a4:	f8 01       	movw	r30, r16
     9a6:	91 89       	ldd	r25, Z+17	; 0x11
     9a8:	99 23       	and	r25, r25
     9aa:	49 f0       	breq	.+18     	; 0x9be <xQueueGenericSend+0x60>
     9ac:	c8 01       	movw	r24, r16
     9ae:	41 96       	adiw	r24, 0x11	; 17
     9b0:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <xTaskRemoveFromEventList>
     9b4:	81 30       	cpi	r24, 0x01	; 1
     9b6:	31 f4       	brne	.+12     	; 0x9c4 <xQueueGenericSend+0x66>
     9b8:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
     9bc:	03 c0       	rjmp	.+6      	; 0x9c4 <xQueueGenericSend+0x66>
     9be:	81 11       	cpse	r24, r1
     9c0:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
     9c4:	0f 90       	pop	r0
     9c6:	0f be       	out	0x3f, r0	; 63
     9c8:	81 e0       	ldi	r24, 0x01	; 1
     9ca:	4d c0       	rjmp	.+154    	; 0xa66 <xQueueGenericSend+0x108>
     9cc:	8c 81       	ldd	r24, Y+4	; 0x04
     9ce:	9d 81       	ldd	r25, Y+5	; 0x05
     9d0:	89 2b       	or	r24, r25
     9d2:	21 f4       	brne	.+8      	; 0x9dc <xQueueGenericSend+0x7e>
     9d4:	0f 90       	pop	r0
     9d6:	0f be       	out	0x3f, r0	; 63
     9d8:	80 e0       	ldi	r24, 0x00	; 0
     9da:	45 c0       	rjmp	.+138    	; 0xa66 <xQueueGenericSend+0x108>
     9dc:	d1 10       	cpse	r13, r1
     9de:	06 c0       	rjmp	.+12     	; 0x9ec <xQueueGenericSend+0x8e>
     9e0:	ce 01       	movw	r24, r28
     9e2:	01 96       	adiw	r24, 0x01	; 1
     9e4:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <vTaskSetTimeOutState>
     9e8:	dd 24       	eor	r13, r13
     9ea:	d3 94       	inc	r13
     9ec:	0f 90       	pop	r0
     9ee:	0f be       	out	0x3f, r0	; 63
     9f0:	0e 94 d1 07 	call	0xfa2	; 0xfa2 <vTaskSuspendAll>
     9f4:	0f b6       	in	r0, 0x3f	; 63
     9f6:	f8 94       	cli
     9f8:	0f 92       	push	r0
     9fa:	f8 01       	movw	r30, r16
     9fc:	85 8d       	ldd	r24, Z+29	; 0x1d
     9fe:	8f 3f       	cpi	r24, 0xFF	; 255
     a00:	09 f4       	brne	.+2      	; 0xa04 <xQueueGenericSend+0xa6>
     a02:	15 8e       	std	Z+29, r1	; 0x1d
     a04:	f8 01       	movw	r30, r16
     a06:	86 8d       	ldd	r24, Z+30	; 0x1e
     a08:	8f 3f       	cpi	r24, 0xFF	; 255
     a0a:	09 f4       	brne	.+2      	; 0xa0e <xQueueGenericSend+0xb0>
     a0c:	16 8e       	std	Z+30, r1	; 0x1e
     a0e:	0f 90       	pop	r0
     a10:	0f be       	out	0x3f, r0	; 63
     a12:	be 01       	movw	r22, r28
     a14:	6c 5f       	subi	r22, 0xFC	; 252
     a16:	7f 4f       	sbci	r23, 0xFF	; 255
     a18:	ce 01       	movw	r24, r28
     a1a:	01 96       	adiw	r24, 0x01	; 1
     a1c:	0e 94 87 0a 	call	0x150e	; 0x150e <xTaskCheckForTimeOut>
     a20:	81 11       	cpse	r24, r1
     a22:	1b c0       	rjmp	.+54     	; 0xa5a <xQueueGenericSend+0xfc>
     a24:	c8 01       	movw	r24, r16
     a26:	0e 94 7d 03 	call	0x6fa	; 0x6fa <prvIsQueueFull>
     a2a:	88 23       	and	r24, r24
     a2c:	81 f0       	breq	.+32     	; 0xa4e <xQueueGenericSend+0xf0>
     a2e:	6c 81       	ldd	r22, Y+4	; 0x04
     a30:	7d 81       	ldd	r23, Y+5	; 0x05
     a32:	c8 01       	movw	r24, r16
     a34:	08 96       	adiw	r24, 0x08	; 8
     a36:	0e 94 b9 09 	call	0x1372	; 0x1372 <vTaskPlaceOnEventList>
     a3a:	c8 01       	movw	r24, r16
     a3c:	0e 94 05 04 	call	0x80a	; 0x80a <prvUnlockQueue>
     a40:	0e 94 93 08 	call	0x1126	; 0x1126 <xTaskResumeAll>
     a44:	81 11       	cpse	r24, r1
     a46:	9e cf       	rjmp	.-196    	; 0x984 <xQueueGenericSend+0x26>
     a48:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
     a4c:	9b cf       	rjmp	.-202    	; 0x984 <xQueueGenericSend+0x26>
     a4e:	c8 01       	movw	r24, r16
     a50:	0e 94 05 04 	call	0x80a	; 0x80a <prvUnlockQueue>
     a54:	0e 94 93 08 	call	0x1126	; 0x1126 <xTaskResumeAll>
     a58:	95 cf       	rjmp	.-214    	; 0x984 <xQueueGenericSend+0x26>
     a5a:	c8 01       	movw	r24, r16
     a5c:	0e 94 05 04 	call	0x80a	; 0x80a <prvUnlockQueue>
     a60:	0e 94 93 08 	call	0x1126	; 0x1126 <xTaskResumeAll>
     a64:	80 e0       	ldi	r24, 0x00	; 0
     a66:	0f 90       	pop	r0
     a68:	0f 90       	pop	r0
     a6a:	0f 90       	pop	r0
     a6c:	0f 90       	pop	r0
     a6e:	0f 90       	pop	r0
     a70:	df 91       	pop	r29
     a72:	cf 91       	pop	r28
     a74:	1f 91       	pop	r17
     a76:	0f 91       	pop	r16
     a78:	ff 90       	pop	r15
     a7a:	ef 90       	pop	r14
     a7c:	df 90       	pop	r13
     a7e:	cf 90       	pop	r12
     a80:	08 95       	ret

00000a82 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     a82:	af 92       	push	r10
     a84:	bf 92       	push	r11
     a86:	cf 92       	push	r12
     a88:	df 92       	push	r13
     a8a:	ef 92       	push	r14
     a8c:	ff 92       	push	r15
     a8e:	0f 93       	push	r16
     a90:	1f 93       	push	r17
     a92:	cf 93       	push	r28
     a94:	df 93       	push	r29
     a96:	00 d0       	rcall	.+0      	; 0xa98 <xQueueGenericReceive+0x16>
     a98:	00 d0       	rcall	.+0      	; 0xa9a <xQueueGenericReceive+0x18>
     a9a:	1f 92       	push	r1
     a9c:	cd b7       	in	r28, 0x3d	; 61
     a9e:	de b7       	in	r29, 0x3e	; 62
     aa0:	8c 01       	movw	r16, r24
     aa2:	6b 01       	movw	r12, r22
     aa4:	5d 83       	std	Y+5, r21	; 0x05
     aa6:	4c 83       	std	Y+4, r20	; 0x04
     aa8:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE;
     aaa:	f1 2c       	mov	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     aac:	0f b6       	in	r0, 0x3f	; 63
     aae:	f8 94       	cli
     ab0:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     ab2:	f8 01       	movw	r30, r16
     ab4:	82 8d       	ldd	r24, Z+26	; 0x1a
     ab6:	88 23       	and	r24, r24
     ab8:	99 f1       	breq	.+102    	; 0xb20 <xQueueGenericReceive+0x9e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     aba:	a6 80       	ldd	r10, Z+6	; 0x06
     abc:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     abe:	b6 01       	movw	r22, r12
     ac0:	c8 01       	movw	r24, r16
     ac2:	0e 94 eb 03 	call	0x7d6	; 0x7d6 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     ac6:	e1 10       	cpse	r14, r1
     ac8:	1a c0       	rjmp	.+52     	; 0xafe <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
     aca:	f8 01       	movw	r30, r16
     acc:	82 8d       	ldd	r24, Z+26	; 0x1a
     ace:	81 50       	subi	r24, 0x01	; 1
     ad0:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     ad2:	80 81       	ld	r24, Z
     ad4:	91 81       	ldd	r25, Z+1	; 0x01
     ad6:	89 2b       	or	r24, r25
     ad8:	29 f4       	brne	.+10     	; 0xae4 <xQueueGenericReceive+0x62>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     ada:	0e 94 76 0b 	call	0x16ec	; 0x16ec <pvTaskIncrementMutexHeldCount>
     ade:	f8 01       	movw	r30, r16
     ae0:	93 83       	std	Z+3, r25	; 0x03
     ae2:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ae4:	f8 01       	movw	r30, r16
     ae6:	80 85       	ldd	r24, Z+8	; 0x08
     ae8:	88 23       	and	r24, r24
     aea:	b1 f0       	breq	.+44     	; 0xb18 <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     aec:	c8 01       	movw	r24, r16
     aee:	08 96       	adiw	r24, 0x08	; 8
     af0:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <xTaskRemoveFromEventList>
     af4:	81 30       	cpi	r24, 0x01	; 1
     af6:	81 f4       	brne	.+32     	; 0xb18 <xQueueGenericReceive+0x96>
						{
							queueYIELD_IF_USING_PREEMPTION();
     af8:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
     afc:	0d c0       	rjmp	.+26     	; 0xb18 <xQueueGenericReceive+0x96>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     afe:	f8 01       	movw	r30, r16
     b00:	b7 82       	std	Z+7, r11	; 0x07
     b02:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     b04:	81 89       	ldd	r24, Z+17	; 0x11
     b06:	88 23       	and	r24, r24
     b08:	39 f0       	breq	.+14     	; 0xb18 <xQueueGenericReceive+0x96>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     b0a:	c8 01       	movw	r24, r16
     b0c:	41 96       	adiw	r24, 0x11	; 17
     b0e:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <xTaskRemoveFromEventList>
     b12:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     b14:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     b18:	0f 90       	pop	r0
     b1a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     b1c:	81 e0       	ldi	r24, 0x01	; 1
     b1e:	5b c0       	rjmp	.+182    	; 0xbd6 <xQueueGenericReceive+0x154>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     b20:	8c 81       	ldd	r24, Y+4	; 0x04
     b22:	9d 81       	ldd	r25, Y+5	; 0x05
     b24:	89 2b       	or	r24, r25
     b26:	21 f4       	brne	.+8      	; 0xb30 <xQueueGenericReceive+0xae>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     b28:	0f 90       	pop	r0
     b2a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     b2c:	80 e0       	ldi	r24, 0x00	; 0
     b2e:	53 c0       	rjmp	.+166    	; 0xbd6 <xQueueGenericReceive+0x154>
				}
				else if( xEntryTimeSet == pdFALSE )
     b30:	f1 10       	cpse	r15, r1
     b32:	06 c0       	rjmp	.+12     	; 0xb40 <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     b34:	ce 01       	movw	r24, r28
     b36:	01 96       	adiw	r24, 0x01	; 1
     b38:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     b3c:	ff 24       	eor	r15, r15
     b3e:	f3 94       	inc	r15
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     b40:	0f 90       	pop	r0
     b42:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     b44:	0e 94 d1 07 	call	0xfa2	; 0xfa2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     b48:	0f b6       	in	r0, 0x3f	; 63
     b4a:	f8 94       	cli
     b4c:	0f 92       	push	r0
     b4e:	f8 01       	movw	r30, r16
     b50:	85 8d       	ldd	r24, Z+29	; 0x1d
     b52:	8f 3f       	cpi	r24, 0xFF	; 255
     b54:	09 f4       	brne	.+2      	; 0xb58 <xQueueGenericReceive+0xd6>
     b56:	15 8e       	std	Z+29, r1	; 0x1d
     b58:	f8 01       	movw	r30, r16
     b5a:	86 8d       	ldd	r24, Z+30	; 0x1e
     b5c:	8f 3f       	cpi	r24, 0xFF	; 255
     b5e:	09 f4       	brne	.+2      	; 0xb62 <xQueueGenericReceive+0xe0>
     b60:	16 8e       	std	Z+30, r1	; 0x1e
     b62:	0f 90       	pop	r0
     b64:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     b66:	be 01       	movw	r22, r28
     b68:	6c 5f       	subi	r22, 0xFC	; 252
     b6a:	7f 4f       	sbci	r23, 0xFF	; 255
     b6c:	ce 01       	movw	r24, r28
     b6e:	01 96       	adiw	r24, 0x01	; 1
     b70:	0e 94 87 0a 	call	0x150e	; 0x150e <xTaskCheckForTimeOut>
     b74:	81 11       	cpse	r24, r1
     b76:	29 c0       	rjmp	.+82     	; 0xbca <xQueueGenericReceive+0x148>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     b78:	c8 01       	movw	r24, r16
     b7a:	0e 94 70 03 	call	0x6e0	; 0x6e0 <prvIsQueueEmpty>
     b7e:	88 23       	and	r24, r24
     b80:	f1 f0       	breq	.+60     	; 0xbbe <xQueueGenericReceive+0x13c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     b82:	f8 01       	movw	r30, r16
     b84:	80 81       	ld	r24, Z
     b86:	91 81       	ldd	r25, Z+1	; 0x01
     b88:	89 2b       	or	r24, r25
     b8a:	49 f4       	brne	.+18     	; 0xb9e <xQueueGenericReceive+0x11c>
					{
						taskENTER_CRITICAL();
     b8c:	0f b6       	in	r0, 0x3f	; 63
     b8e:	f8 94       	cli
     b90:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     b92:	82 81       	ldd	r24, Z+2	; 0x02
     b94:	93 81       	ldd	r25, Z+3	; 0x03
     b96:	0e 94 bd 0a 	call	0x157a	; 0x157a <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
     b9a:	0f 90       	pop	r0
     b9c:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b9e:	6c 81       	ldd	r22, Y+4	; 0x04
     ba0:	7d 81       	ldd	r23, Y+5	; 0x05
     ba2:	c8 01       	movw	r24, r16
     ba4:	41 96       	adiw	r24, 0x11	; 17
     ba6:	0e 94 b9 09 	call	0x1372	; 0x1372 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     baa:	c8 01       	movw	r24, r16
     bac:	0e 94 05 04 	call	0x80a	; 0x80a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     bb0:	0e 94 93 08 	call	0x1126	; 0x1126 <xTaskResumeAll>
     bb4:	81 11       	cpse	r24, r1
     bb6:	7a cf       	rjmp	.-268    	; 0xaac <xQueueGenericReceive+0x2a>
				{
					portYIELD_WITHIN_API();
     bb8:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
     bbc:	77 cf       	rjmp	.-274    	; 0xaac <xQueueGenericReceive+0x2a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     bbe:	c8 01       	movw	r24, r16
     bc0:	0e 94 05 04 	call	0x80a	; 0x80a <prvUnlockQueue>
				( void ) xTaskResumeAll();
     bc4:	0e 94 93 08 	call	0x1126	; 0x1126 <xTaskResumeAll>
     bc8:	71 cf       	rjmp	.-286    	; 0xaac <xQueueGenericReceive+0x2a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     bca:	c8 01       	movw	r24, r16
     bcc:	0e 94 05 04 	call	0x80a	; 0x80a <prvUnlockQueue>
			( void ) xTaskResumeAll();
     bd0:	0e 94 93 08 	call	0x1126	; 0x1126 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     bd4:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     bd6:	0f 90       	pop	r0
     bd8:	0f 90       	pop	r0
     bda:	0f 90       	pop	r0
     bdc:	0f 90       	pop	r0
     bde:	0f 90       	pop	r0
     be0:	df 91       	pop	r29
     be2:	cf 91       	pop	r28
     be4:	1f 91       	pop	r17
     be6:	0f 91       	pop	r16
     be8:	ff 90       	pop	r15
     bea:	ef 90       	pop	r14
     bec:	df 90       	pop	r13
     bee:	cf 90       	pop	r12
     bf0:	bf 90       	pop	r11
     bf2:	af 90       	pop	r10
     bf4:	08 95       	ret

00000bf6 <prvResetNextTaskUnblockTime>:
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;

		return xReturn;
	}
     bf6:	e0 91 85 05 	lds	r30, 0x0585	; 0x800585 <pxDelayedTaskList>
     bfa:	f0 91 86 05 	lds	r31, 0x0586	; 0x800586 <pxDelayedTaskList+0x1>
     bfe:	80 81       	ld	r24, Z
     c00:	81 11       	cpse	r24, r1
     c02:	07 c0       	rjmp	.+14     	; 0xc12 <prvResetNextTaskUnblockTime+0x1c>
     c04:	8f ef       	ldi	r24, 0xFF	; 255
     c06:	9f ef       	ldi	r25, 0xFF	; 255
     c08:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     c0c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     c10:	08 95       	ret
     c12:	e0 91 85 05 	lds	r30, 0x0585	; 0x800585 <pxDelayedTaskList>
     c16:	f0 91 86 05 	lds	r31, 0x0586	; 0x800586 <pxDelayedTaskList+0x1>
     c1a:	05 80       	ldd	r0, Z+5	; 0x05
     c1c:	f6 81       	ldd	r31, Z+6	; 0x06
     c1e:	e0 2d       	mov	r30, r0
     c20:	06 80       	ldd	r0, Z+6	; 0x06
     c22:	f7 81       	ldd	r31, Z+7	; 0x07
     c24:	e0 2d       	mov	r30, r0
     c26:	82 81       	ldd	r24, Z+2	; 0x02
     c28:	93 81       	ldd	r25, Z+3	; 0x03
     c2a:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     c2e:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     c32:	08 95       	ret

00000c34 <prvAllocateTCBAndStack>:
     c34:	ef 92       	push	r14
     c36:	ff 92       	push	r15
     c38:	0f 93       	push	r16
     c3a:	1f 93       	push	r17
     c3c:	cf 93       	push	r28
     c3e:	df 93       	push	r29
     c40:	7c 01       	movw	r14, r24
     c42:	eb 01       	movw	r28, r22
     c44:	8f e2       	ldi	r24, 0x2F	; 47
     c46:	90 e0       	ldi	r25, 0x00	; 0
     c48:	0e 94 54 01 	call	0x2a8	; 0x2a8 <pvPortMalloc>
     c4c:	8c 01       	movw	r16, r24
     c4e:	89 2b       	or	r24, r25
     c50:	89 f0       	breq	.+34     	; 0xc74 <prvAllocateTCBAndStack+0x40>
     c52:	20 97       	sbiw	r28, 0x00	; 0
     c54:	21 f4       	brne	.+8      	; 0xc5e <prvAllocateTCBAndStack+0x2a>
     c56:	c7 01       	movw	r24, r14
     c58:	0e 94 54 01 	call	0x2a8	; 0x2a8 <pvPortMalloc>
     c5c:	01 c0       	rjmp	.+2      	; 0xc60 <prvAllocateTCBAndStack+0x2c>
     c5e:	ce 01       	movw	r24, r28
     c60:	f8 01       	movw	r30, r16
     c62:	90 8f       	std	Z+24, r25	; 0x18
     c64:	87 8b       	std	Z+23, r24	; 0x17
     c66:	89 2b       	or	r24, r25
     c68:	29 f4       	brne	.+10     	; 0xc74 <prvAllocateTCBAndStack+0x40>
     c6a:	c8 01       	movw	r24, r16
     c6c:	0e 94 89 01 	call	0x312	; 0x312 <vPortFree>
     c70:	00 e0       	ldi	r16, 0x00	; 0
     c72:	10 e0       	ldi	r17, 0x00	; 0
     c74:	c8 01       	movw	r24, r16
     c76:	df 91       	pop	r29
     c78:	cf 91       	pop	r28
     c7a:	1f 91       	pop	r17
     c7c:	0f 91       	pop	r16
     c7e:	ff 90       	pop	r15
     c80:	ef 90       	pop	r14
     c82:	08 95       	ret

00000c84 <prvDeleteTCB>:
     c84:	cf 93       	push	r28
     c86:	df 93       	push	r29
     c88:	ec 01       	movw	r28, r24
     c8a:	8f 89       	ldd	r24, Y+23	; 0x17
     c8c:	98 8d       	ldd	r25, Y+24	; 0x18
     c8e:	0e 94 89 01 	call	0x312	; 0x312 <vPortFree>
     c92:	ce 01       	movw	r24, r28
     c94:	0e 94 89 01 	call	0x312	; 0x312 <vPortFree>
     c98:	df 91       	pop	r29
     c9a:	cf 91       	pop	r28
     c9c:	08 95       	ret

00000c9e <prvInitialiseTCBVariables>:
     c9e:	1f 93       	push	r17
     ca0:	cf 93       	push	r28
     ca2:	df 93       	push	r29
     ca4:	ec 01       	movw	r28, r24
     ca6:	14 2f       	mov	r17, r20
     ca8:	20 e0       	ldi	r18, 0x00	; 0
     caa:	0f c0       	rjmp	.+30     	; 0xcca <prvInitialiseTCBVariables+0x2c>
     cac:	82 2f       	mov	r24, r18
     cae:	90 e0       	ldi	r25, 0x00	; 0
     cb0:	fb 01       	movw	r30, r22
     cb2:	e8 0f       	add	r30, r24
     cb4:	f9 1f       	adc	r31, r25
     cb6:	30 81       	ld	r19, Z
     cb8:	de 01       	movw	r26, r28
     cba:	a8 0f       	add	r26, r24
     cbc:	b9 1f       	adc	r27, r25
     cbe:	59 96       	adiw	r26, 0x19	; 25
     cc0:	3c 93       	st	X, r19
     cc2:	80 81       	ld	r24, Z
     cc4:	88 23       	and	r24, r24
     cc6:	19 f0       	breq	.+6      	; 0xcce <prvInitialiseTCBVariables+0x30>
     cc8:	2f 5f       	subi	r18, 0xFF	; 255
     cca:	24 31       	cpi	r18, 0x14	; 20
     ccc:	78 f3       	brcs	.-34     	; 0xcac <prvInitialiseTCBVariables+0xe>
     cce:	1c a6       	std	Y+44, r1	; 0x2c
     cd0:	18 30       	cpi	r17, 0x08	; 8
     cd2:	08 f0       	brcs	.+2      	; 0xcd6 <prvInitialiseTCBVariables+0x38>
     cd4:	17 e0       	ldi	r17, 0x07	; 7
     cd6:	1e 8b       	std	Y+22, r17	; 0x16
     cd8:	1d a7       	std	Y+45, r17	; 0x2d
     cda:	1e a6       	std	Y+46, r1	; 0x2e
     cdc:	ce 01       	movw	r24, r28
     cde:	02 96       	adiw	r24, 0x02	; 2
     ce0:	0e 94 98 01 	call	0x330	; 0x330 <vListInitialiseItem>
     ce4:	ce 01       	movw	r24, r28
     ce6:	0c 96       	adiw	r24, 0x0c	; 12
     ce8:	0e 94 98 01 	call	0x330	; 0x330 <vListInitialiseItem>
     cec:	d9 87       	std	Y+9, r29	; 0x09
     cee:	c8 87       	std	Y+8, r28	; 0x08
     cf0:	88 e0       	ldi	r24, 0x08	; 8
     cf2:	90 e0       	ldi	r25, 0x00	; 0
     cf4:	81 1b       	sub	r24, r17
     cf6:	91 09       	sbc	r25, r1
     cf8:	9d 87       	std	Y+13, r25	; 0x0d
     cfa:	8c 87       	std	Y+12, r24	; 0x0c
     cfc:	db 8b       	std	Y+19, r29	; 0x13
     cfe:	ca 8b       	std	Y+18, r28	; 0x12
     d00:	df 91       	pop	r29
     d02:	cf 91       	pop	r28
     d04:	1f 91       	pop	r17
     d06:	08 95       	ret

00000d08 <prvInitialiseTaskLists>:
     d08:	cf 93       	push	r28
     d0a:	c0 e0       	ldi	r28, 0x00	; 0
     d0c:	10 c0       	rjmp	.+32     	; 0xd2e <prvInitialiseTaskLists+0x26>
     d0e:	8c 2f       	mov	r24, r28
     d10:	90 e0       	ldi	r25, 0x00	; 0
     d12:	9c 01       	movw	r18, r24
     d14:	22 0f       	add	r18, r18
     d16:	33 1f       	adc	r19, r19
     d18:	22 0f       	add	r18, r18
     d1a:	33 1f       	adc	r19, r19
     d1c:	22 0f       	add	r18, r18
     d1e:	33 1f       	adc	r19, r19
     d20:	82 0f       	add	r24, r18
     d22:	93 1f       	adc	r25, r19
     d24:	87 56       	subi	r24, 0x67	; 103
     d26:	9a 4f       	sbci	r25, 0xFA	; 250
     d28:	0e 94 8a 01 	call	0x314	; 0x314 <vListInitialise>
     d2c:	cf 5f       	subi	r28, 0xFF	; 255
     d2e:	c8 30       	cpi	r28, 0x08	; 8
     d30:	70 f3       	brcs	.-36     	; 0xd0e <prvInitialiseTaskLists+0x6>
     d32:	80 e9       	ldi	r24, 0x90	; 144
     d34:	95 e0       	ldi	r25, 0x05	; 5
     d36:	0e 94 8a 01 	call	0x314	; 0x314 <vListInitialise>
     d3a:	87 e8       	ldi	r24, 0x87	; 135
     d3c:	95 e0       	ldi	r25, 0x05	; 5
     d3e:	0e 94 8a 01 	call	0x314	; 0x314 <vListInitialise>
     d42:	8a e7       	ldi	r24, 0x7A	; 122
     d44:	95 e0       	ldi	r25, 0x05	; 5
     d46:	0e 94 8a 01 	call	0x314	; 0x314 <vListInitialise>
     d4a:	81 e7       	ldi	r24, 0x71	; 113
     d4c:	95 e0       	ldi	r25, 0x05	; 5
     d4e:	0e 94 8a 01 	call	0x314	; 0x314 <vListInitialise>
     d52:	80 e9       	ldi	r24, 0x90	; 144
     d54:	95 e0       	ldi	r25, 0x05	; 5
     d56:	90 93 86 05 	sts	0x0586, r25	; 0x800586 <pxDelayedTaskList+0x1>
     d5a:	80 93 85 05 	sts	0x0585, r24	; 0x800585 <pxDelayedTaskList>
     d5e:	87 e8       	ldi	r24, 0x87	; 135
     d60:	95 e0       	ldi	r25, 0x05	; 5
     d62:	90 93 84 05 	sts	0x0584, r25	; 0x800584 <pxOverflowDelayedTaskList+0x1>
     d66:	80 93 83 05 	sts	0x0583, r24	; 0x800583 <pxOverflowDelayedTaskList>
     d6a:	cf 91       	pop	r28
     d6c:	08 95       	ret

00000d6e <prvAddCurrentTaskToDelayedList>:
     d6e:	cf 93       	push	r28
     d70:	df 93       	push	r29
     d72:	ec 01       	movw	r28, r24
     d74:	e0 91 e1 05 	lds	r30, 0x05E1	; 0x8005e1 <pxCurrentTCB>
     d78:	f0 91 e2 05 	lds	r31, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
     d7c:	93 83       	std	Z+3, r25	; 0x03
     d7e:	82 83       	std	Z+2, r24	; 0x02
     d80:	80 91 6d 05 	lds	r24, 0x056D	; 0x80056d <xTickCount>
     d84:	90 91 6e 05 	lds	r25, 0x056E	; 0x80056e <xTickCount+0x1>
     d88:	c8 17       	cp	r28, r24
     d8a:	d9 07       	cpc	r29, r25
     d8c:	68 f4       	brcc	.+26     	; 0xda8 <prvAddCurrentTaskToDelayedList+0x3a>
     d8e:	60 91 e1 05 	lds	r22, 0x05E1	; 0x8005e1 <pxCurrentTCB>
     d92:	70 91 e2 05 	lds	r23, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
     d96:	80 91 83 05 	lds	r24, 0x0583	; 0x800583 <pxOverflowDelayedTaskList>
     d9a:	90 91 84 05 	lds	r25, 0x0584	; 0x800584 <pxOverflowDelayedTaskList+0x1>
     d9e:	6e 5f       	subi	r22, 0xFE	; 254
     da0:	7f 4f       	sbci	r23, 0xFF	; 255
     da2:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInsert>
     da6:	17 c0       	rjmp	.+46     	; 0xdd6 <prvAddCurrentTaskToDelayedList+0x68>
     da8:	60 91 e1 05 	lds	r22, 0x05E1	; 0x8005e1 <pxCurrentTCB>
     dac:	70 91 e2 05 	lds	r23, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
     db0:	80 91 85 05 	lds	r24, 0x0585	; 0x800585 <pxDelayedTaskList>
     db4:	90 91 86 05 	lds	r25, 0x0586	; 0x800586 <pxDelayedTaskList+0x1>
     db8:	6e 5f       	subi	r22, 0xFE	; 254
     dba:	7f 4f       	sbci	r23, 0xFF	; 255
     dbc:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInsert>
     dc0:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     dc4:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     dc8:	c8 17       	cp	r28, r24
     dca:	d9 07       	cpc	r29, r25
     dcc:	20 f4       	brcc	.+8      	; 0xdd6 <prvAddCurrentTaskToDelayedList+0x68>
     dce:	d0 93 61 00 	sts	0x0061, r29	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     dd2:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <__DATA_REGION_ORIGIN__>
     dd6:	df 91       	pop	r29
     dd8:	cf 91       	pop	r28
     dda:	08 95       	ret

00000ddc <xTaskGenericCreate>:
     ddc:	2f 92       	push	r2
     dde:	3f 92       	push	r3
     de0:	4f 92       	push	r4
     de2:	5f 92       	push	r5
     de4:	7f 92       	push	r7
     de6:	8f 92       	push	r8
     de8:	9f 92       	push	r9
     dea:	af 92       	push	r10
     dec:	bf 92       	push	r11
     dee:	cf 92       	push	r12
     df0:	df 92       	push	r13
     df2:	ef 92       	push	r14
     df4:	ff 92       	push	r15
     df6:	0f 93       	push	r16
     df8:	1f 93       	push	r17
     dfa:	cf 93       	push	r28
     dfc:	df 93       	push	r29
     dfe:	00 d0       	rcall	.+0      	; 0xe00 <xTaskGenericCreate+0x24>
     e00:	00 d0       	rcall	.+0      	; 0xe02 <xTaskGenericCreate+0x26>
     e02:	cd b7       	in	r28, 0x3d	; 61
     e04:	de b7       	in	r29, 0x3e	; 62
     e06:	9a 83       	std	Y+2, r25	; 0x02
     e08:	89 83       	std	Y+1, r24	; 0x01
     e0a:	4b 01       	movw	r8, r22
     e0c:	5c 83       	std	Y+4, r21	; 0x04
     e0e:	4b 83       	std	Y+3, r20	; 0x03
     e10:	19 01       	movw	r2, r18
     e12:	70 2e       	mov	r7, r16
     e14:	b6 01       	movw	r22, r12
     e16:	25 01       	movw	r4, r10
     e18:	ca 01       	movw	r24, r20
     e1a:	0e 94 1a 06 	call	0xc34	; 0xc34 <prvAllocateTCBAndStack>
     e1e:	5c 01       	movw	r10, r24
     e20:	00 97       	sbiw	r24, 0x00	; 0
     e22:	09 f4       	brne	.+2      	; 0xe26 <xTaskGenericCreate+0x4a>
     e24:	6a c0       	rjmp	.+212    	; 0xefa <xTaskGenericCreate+0x11e>
     e26:	fc 01       	movw	r30, r24
     e28:	c7 88       	ldd	r12, Z+23	; 0x17
     e2a:	d0 8c       	ldd	r13, Z+24	; 0x18
     e2c:	8b 81       	ldd	r24, Y+3	; 0x03
     e2e:	9c 81       	ldd	r25, Y+4	; 0x04
     e30:	01 97       	sbiw	r24, 0x01	; 1
     e32:	c8 0e       	add	r12, r24
     e34:	d9 1e       	adc	r13, r25
     e36:	0b 81       	ldd	r16, Y+3	; 0x03
     e38:	1c 81       	ldd	r17, Y+4	; 0x04
     e3a:	92 01       	movw	r18, r4
     e3c:	47 2d       	mov	r20, r7
     e3e:	b4 01       	movw	r22, r8
     e40:	c5 01       	movw	r24, r10
     e42:	0e 94 4f 06 	call	0xc9e	; 0xc9e <prvInitialiseTCBVariables>
     e46:	a1 01       	movw	r20, r2
     e48:	69 81       	ldd	r22, Y+1	; 0x01
     e4a:	7a 81       	ldd	r23, Y+2	; 0x02
     e4c:	c6 01       	movw	r24, r12
     e4e:	0e 94 1d 02 	call	0x43a	; 0x43a <pxPortInitialiseStack>
     e52:	f5 01       	movw	r30, r10
     e54:	91 83       	std	Z+1, r25	; 0x01
     e56:	80 83       	st	Z, r24
     e58:	e1 14       	cp	r14, r1
     e5a:	f1 04       	cpc	r15, r1
     e5c:	19 f0       	breq	.+6      	; 0xe64 <xTaskGenericCreate+0x88>
     e5e:	f7 01       	movw	r30, r14
     e60:	b1 82       	std	Z+1, r11	; 0x01
     e62:	a0 82       	st	Z, r10
     e64:	0f b6       	in	r0, 0x3f	; 63
     e66:	f8 94       	cli
     e68:	0f 92       	push	r0
     e6a:	80 91 6f 05 	lds	r24, 0x056F	; 0x80056f <uxCurrentNumberOfTasks>
     e6e:	8f 5f       	subi	r24, 0xFF	; 255
     e70:	80 93 6f 05 	sts	0x056F, r24	; 0x80056f <uxCurrentNumberOfTasks>
     e74:	80 91 e1 05 	lds	r24, 0x05E1	; 0x8005e1 <pxCurrentTCB>
     e78:	90 91 e2 05 	lds	r25, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
     e7c:	89 2b       	or	r24, r25
     e7e:	59 f4       	brne	.+22     	; 0xe96 <xTaskGenericCreate+0xba>
     e80:	b0 92 e2 05 	sts	0x05E2, r11	; 0x8005e2 <pxCurrentTCB+0x1>
     e84:	a0 92 e1 05 	sts	0x05E1, r10	; 0x8005e1 <pxCurrentTCB>
     e88:	80 91 6f 05 	lds	r24, 0x056F	; 0x80056f <uxCurrentNumberOfTasks>
     e8c:	81 30       	cpi	r24, 0x01	; 1
     e8e:	91 f4       	brne	.+36     	; 0xeb4 <xTaskGenericCreate+0xd8>
     e90:	0e 94 84 06 	call	0xd08	; 0xd08 <prvInitialiseTaskLists>
     e94:	0f c0       	rjmp	.+30     	; 0xeb4 <xTaskGenericCreate+0xd8>
     e96:	80 91 6b 05 	lds	r24, 0x056B	; 0x80056b <xSchedulerRunning>
     e9a:	81 11       	cpse	r24, r1
     e9c:	0b c0       	rjmp	.+22     	; 0xeb4 <xTaskGenericCreate+0xd8>
     e9e:	e0 91 e1 05 	lds	r30, 0x05E1	; 0x8005e1 <pxCurrentTCB>
     ea2:	f0 91 e2 05 	lds	r31, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
     ea6:	86 89       	ldd	r24, Z+22	; 0x16
     ea8:	78 16       	cp	r7, r24
     eaa:	20 f0       	brcs	.+8      	; 0xeb4 <xTaskGenericCreate+0xd8>
     eac:	b0 92 e2 05 	sts	0x05E2, r11	; 0x8005e2 <pxCurrentTCB+0x1>
     eb0:	a0 92 e1 05 	sts	0x05E1, r10	; 0x8005e1 <pxCurrentTCB>
     eb4:	80 91 67 05 	lds	r24, 0x0567	; 0x800567 <uxTaskNumber>
     eb8:	8f 5f       	subi	r24, 0xFF	; 255
     eba:	80 93 67 05 	sts	0x0567, r24	; 0x800567 <uxTaskNumber>
     ebe:	f5 01       	movw	r30, r10
     ec0:	86 89       	ldd	r24, Z+22	; 0x16
     ec2:	90 91 6c 05 	lds	r25, 0x056C	; 0x80056c <uxTopReadyPriority>
     ec6:	98 17       	cp	r25, r24
     ec8:	10 f4       	brcc	.+4      	; 0xece <xTaskGenericCreate+0xf2>
     eca:	80 93 6c 05 	sts	0x056C, r24	; 0x80056c <uxTopReadyPriority>
     ece:	90 e0       	ldi	r25, 0x00	; 0
     ed0:	b5 01       	movw	r22, r10
     ed2:	6e 5f       	subi	r22, 0xFE	; 254
     ed4:	7f 4f       	sbci	r23, 0xFF	; 255
     ed6:	9c 01       	movw	r18, r24
     ed8:	22 0f       	add	r18, r18
     eda:	33 1f       	adc	r19, r19
     edc:	22 0f       	add	r18, r18
     ede:	33 1f       	adc	r19, r19
     ee0:	22 0f       	add	r18, r18
     ee2:	33 1f       	adc	r19, r19
     ee4:	82 0f       	add	r24, r18
     ee6:	93 1f       	adc	r25, r19
     ee8:	87 56       	subi	r24, 0x67	; 103
     eea:	9a 4f       	sbci	r25, 0xFA	; 250
     eec:	0e 94 9c 01 	call	0x338	; 0x338 <vListInsertEnd>
     ef0:	0f 90       	pop	r0
     ef2:	0f be       	out	0x3f, r0	; 63
     ef4:	f1 e0       	ldi	r31, 0x01	; 1
     ef6:	f9 83       	std	Y+1, r31	; 0x01
     ef8:	02 c0       	rjmp	.+4      	; 0xefe <xTaskGenericCreate+0x122>
     efa:	8f ef       	ldi	r24, 0xFF	; 255
     efc:	89 83       	std	Y+1, r24	; 0x01
     efe:	e9 81       	ldd	r30, Y+1	; 0x01
     f00:	e1 30       	cpi	r30, 0x01	; 1
     f02:	69 f4       	brne	.+26     	; 0xf1e <xTaskGenericCreate+0x142>
     f04:	80 91 6b 05 	lds	r24, 0x056B	; 0x80056b <xSchedulerRunning>
     f08:	88 23       	and	r24, r24
     f0a:	49 f0       	breq	.+18     	; 0xf1e <xTaskGenericCreate+0x142>
     f0c:	e0 91 e1 05 	lds	r30, 0x05E1	; 0x8005e1 <pxCurrentTCB>
     f10:	f0 91 e2 05 	lds	r31, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
     f14:	86 89       	ldd	r24, Z+22	; 0x16
     f16:	87 15       	cp	r24, r7
     f18:	10 f4       	brcc	.+4      	; 0xf1e <xTaskGenericCreate+0x142>
     f1a:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
     f1e:	89 81       	ldd	r24, Y+1	; 0x01
     f20:	0f 90       	pop	r0
     f22:	0f 90       	pop	r0
     f24:	0f 90       	pop	r0
     f26:	0f 90       	pop	r0
     f28:	df 91       	pop	r29
     f2a:	cf 91       	pop	r28
     f2c:	1f 91       	pop	r17
     f2e:	0f 91       	pop	r16
     f30:	ff 90       	pop	r15
     f32:	ef 90       	pop	r14
     f34:	df 90       	pop	r13
     f36:	cf 90       	pop	r12
     f38:	bf 90       	pop	r11
     f3a:	af 90       	pop	r10
     f3c:	9f 90       	pop	r9
     f3e:	8f 90       	pop	r8
     f40:	7f 90       	pop	r7
     f42:	5f 90       	pop	r5
     f44:	4f 90       	pop	r4
     f46:	3f 90       	pop	r3
     f48:	2f 90       	pop	r2
     f4a:	08 95       	ret

00000f4c <vTaskStartScheduler>:
     f4c:	af 92       	push	r10
     f4e:	bf 92       	push	r11
     f50:	cf 92       	push	r12
     f52:	df 92       	push	r13
     f54:	ef 92       	push	r14
     f56:	ff 92       	push	r15
     f58:	0f 93       	push	r16
     f5a:	a1 2c       	mov	r10, r1
     f5c:	b1 2c       	mov	r11, r1
     f5e:	c1 2c       	mov	r12, r1
     f60:	d1 2c       	mov	r13, r1
     f62:	e1 2c       	mov	r14, r1
     f64:	f1 2c       	mov	r15, r1
     f66:	00 e0       	ldi	r16, 0x00	; 0
     f68:	20 e0       	ldi	r18, 0x00	; 0
     f6a:	30 e0       	ldi	r19, 0x00	; 0
     f6c:	45 e5       	ldi	r20, 0x55	; 85
     f6e:	50 e0       	ldi	r21, 0x00	; 0
     f70:	62 e6       	ldi	r22, 0x62	; 98
     f72:	70 e0       	ldi	r23, 0x00	; 0
     f74:	84 e5       	ldi	r24, 0x54	; 84
     f76:	99 e0       	ldi	r25, 0x09	; 9
     f78:	0e 94 ee 06 	call	0xddc	; 0xddc <xTaskGenericCreate>
     f7c:	81 30       	cpi	r24, 0x01	; 1
     f7e:	49 f4       	brne	.+18     	; 0xf92 <vTaskStartScheduler+0x46>
     f80:	f8 94       	cli
     f82:	80 93 6b 05 	sts	0x056B, r24	; 0x80056b <xSchedulerRunning>
     f86:	10 92 6e 05 	sts	0x056E, r1	; 0x80056e <xTickCount+0x1>
     f8a:	10 92 6d 05 	sts	0x056D, r1	; 0x80056d <xTickCount>
     f8e:	0e 94 89 02 	call	0x512	; 0x512 <xPortStartScheduler>
     f92:	0f 91       	pop	r16
     f94:	ff 90       	pop	r15
     f96:	ef 90       	pop	r14
     f98:	df 90       	pop	r13
     f9a:	cf 90       	pop	r12
     f9c:	bf 90       	pop	r11
     f9e:	af 90       	pop	r10
     fa0:	08 95       	ret

00000fa2 <vTaskSuspendAll>:
     fa2:	80 91 66 05 	lds	r24, 0x0566	; 0x800566 <uxSchedulerSuspended>
     fa6:	8f 5f       	subi	r24, 0xFF	; 255
     fa8:	80 93 66 05 	sts	0x0566, r24	; 0x800566 <uxSchedulerSuspended>
     fac:	08 95       	ret

00000fae <xTaskIncrementTick>:
     fae:	df 92       	push	r13
     fb0:	ef 92       	push	r14
     fb2:	ff 92       	push	r15
     fb4:	0f 93       	push	r16
     fb6:	1f 93       	push	r17
     fb8:	cf 93       	push	r28
     fba:	df 93       	push	r29
     fbc:	80 91 66 05 	lds	r24, 0x0566	; 0x800566 <uxSchedulerSuspended>
     fc0:	81 11       	cpse	r24, r1
     fc2:	99 c0       	rjmp	.+306    	; 0x10f6 <xTaskIncrementTick+0x148>
     fc4:	80 91 6d 05 	lds	r24, 0x056D	; 0x80056d <xTickCount>
     fc8:	90 91 6e 05 	lds	r25, 0x056E	; 0x80056e <xTickCount+0x1>
     fcc:	01 96       	adiw	r24, 0x01	; 1
     fce:	90 93 6e 05 	sts	0x056E, r25	; 0x80056e <xTickCount+0x1>
     fd2:	80 93 6d 05 	sts	0x056D, r24	; 0x80056d <xTickCount>
     fd6:	e0 90 6d 05 	lds	r14, 0x056D	; 0x80056d <xTickCount>
     fda:	f0 90 6e 05 	lds	r15, 0x056E	; 0x80056e <xTickCount+0x1>
     fde:	e1 14       	cp	r14, r1
     fe0:	f1 04       	cpc	r15, r1
     fe2:	b9 f4       	brne	.+46     	; 0x1012 <xTaskIncrementTick+0x64>
     fe4:	80 91 85 05 	lds	r24, 0x0585	; 0x800585 <pxDelayedTaskList>
     fe8:	90 91 86 05 	lds	r25, 0x0586	; 0x800586 <pxDelayedTaskList+0x1>
     fec:	20 91 83 05 	lds	r18, 0x0583	; 0x800583 <pxOverflowDelayedTaskList>
     ff0:	30 91 84 05 	lds	r19, 0x0584	; 0x800584 <pxOverflowDelayedTaskList+0x1>
     ff4:	30 93 86 05 	sts	0x0586, r19	; 0x800586 <pxDelayedTaskList+0x1>
     ff8:	20 93 85 05 	sts	0x0585, r18	; 0x800585 <pxDelayedTaskList>
     ffc:	90 93 84 05 	sts	0x0584, r25	; 0x800584 <pxOverflowDelayedTaskList+0x1>
    1000:	80 93 83 05 	sts	0x0583, r24	; 0x800583 <pxOverflowDelayedTaskList>
    1004:	80 91 68 05 	lds	r24, 0x0568	; 0x800568 <xNumOfOverflows>
    1008:	8f 5f       	subi	r24, 0xFF	; 255
    100a:	80 93 68 05 	sts	0x0568, r24	; 0x800568 <xNumOfOverflows>
    100e:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <prvResetNextTaskUnblockTime>
    1012:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    1016:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    101a:	e8 16       	cp	r14, r24
    101c:	f9 06       	cpc	r15, r25
    101e:	28 f4       	brcc	.+10     	; 0x102a <xTaskIncrementTick+0x7c>
    1020:	d1 2c       	mov	r13, r1
    1022:	53 c0       	rjmp	.+166    	; 0x10ca <xTaskIncrementTick+0x11c>
    1024:	dd 24       	eor	r13, r13
    1026:	d3 94       	inc	r13
    1028:	01 c0       	rjmp	.+2      	; 0x102c <xTaskIncrementTick+0x7e>
    102a:	d1 2c       	mov	r13, r1
    102c:	e0 91 85 05 	lds	r30, 0x0585	; 0x800585 <pxDelayedTaskList>
    1030:	f0 91 86 05 	lds	r31, 0x0586	; 0x800586 <pxDelayedTaskList+0x1>
    1034:	80 81       	ld	r24, Z
    1036:	81 11       	cpse	r24, r1
    1038:	07 c0       	rjmp	.+14     	; 0x1048 <xTaskIncrementTick+0x9a>
    103a:	8f ef       	ldi	r24, 0xFF	; 255
    103c:	9f ef       	ldi	r25, 0xFF	; 255
    103e:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    1042:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    1046:	41 c0       	rjmp	.+130    	; 0x10ca <xTaskIncrementTick+0x11c>
    1048:	e0 91 85 05 	lds	r30, 0x0585	; 0x800585 <pxDelayedTaskList>
    104c:	f0 91 86 05 	lds	r31, 0x0586	; 0x800586 <pxDelayedTaskList+0x1>
    1050:	05 80       	ldd	r0, Z+5	; 0x05
    1052:	f6 81       	ldd	r31, Z+6	; 0x06
    1054:	e0 2d       	mov	r30, r0
    1056:	c6 81       	ldd	r28, Z+6	; 0x06
    1058:	d7 81       	ldd	r29, Z+7	; 0x07
    105a:	8a 81       	ldd	r24, Y+2	; 0x02
    105c:	9b 81       	ldd	r25, Y+3	; 0x03
    105e:	e8 16       	cp	r14, r24
    1060:	f9 06       	cpc	r15, r25
    1062:	28 f4       	brcc	.+10     	; 0x106e <xTaskIncrementTick+0xc0>
    1064:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    1068:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    106c:	2e c0       	rjmp	.+92     	; 0x10ca <xTaskIncrementTick+0x11c>
    106e:	8e 01       	movw	r16, r28
    1070:	0e 5f       	subi	r16, 0xFE	; 254
    1072:	1f 4f       	sbci	r17, 0xFF	; 255
    1074:	c8 01       	movw	r24, r16
    1076:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
    107a:	8c 89       	ldd	r24, Y+20	; 0x14
    107c:	9d 89       	ldd	r25, Y+21	; 0x15
    107e:	89 2b       	or	r24, r25
    1080:	21 f0       	breq	.+8      	; 0x108a <xTaskIncrementTick+0xdc>
    1082:	ce 01       	movw	r24, r28
    1084:	0c 96       	adiw	r24, 0x0c	; 12
    1086:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
    108a:	8e 89       	ldd	r24, Y+22	; 0x16
    108c:	90 91 6c 05 	lds	r25, 0x056C	; 0x80056c <uxTopReadyPriority>
    1090:	98 17       	cp	r25, r24
    1092:	10 f4       	brcc	.+4      	; 0x1098 <xTaskIncrementTick+0xea>
    1094:	80 93 6c 05 	sts	0x056C, r24	; 0x80056c <uxTopReadyPriority>
    1098:	90 e0       	ldi	r25, 0x00	; 0
    109a:	9c 01       	movw	r18, r24
    109c:	22 0f       	add	r18, r18
    109e:	33 1f       	adc	r19, r19
    10a0:	22 0f       	add	r18, r18
    10a2:	33 1f       	adc	r19, r19
    10a4:	22 0f       	add	r18, r18
    10a6:	33 1f       	adc	r19, r19
    10a8:	82 0f       	add	r24, r18
    10aa:	93 1f       	adc	r25, r19
    10ac:	b8 01       	movw	r22, r16
    10ae:	87 56       	subi	r24, 0x67	; 103
    10b0:	9a 4f       	sbci	r25, 0xFA	; 250
    10b2:	0e 94 9c 01 	call	0x338	; 0x338 <vListInsertEnd>
    10b6:	9e 89       	ldd	r25, Y+22	; 0x16
    10b8:	e0 91 e1 05 	lds	r30, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    10bc:	f0 91 e2 05 	lds	r31, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    10c0:	86 89       	ldd	r24, Z+22	; 0x16
    10c2:	98 17       	cp	r25, r24
    10c4:	08 f0       	brcs	.+2      	; 0x10c8 <xTaskIncrementTick+0x11a>
    10c6:	ae cf       	rjmp	.-164    	; 0x1024 <xTaskIncrementTick+0x76>
    10c8:	b1 cf       	rjmp	.-158    	; 0x102c <xTaskIncrementTick+0x7e>
    10ca:	e0 91 e1 05 	lds	r30, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    10ce:	f0 91 e2 05 	lds	r31, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    10d2:	86 89       	ldd	r24, Z+22	; 0x16
    10d4:	90 e0       	ldi	r25, 0x00	; 0
    10d6:	fc 01       	movw	r30, r24
    10d8:	ee 0f       	add	r30, r30
    10da:	ff 1f       	adc	r31, r31
    10dc:	ee 0f       	add	r30, r30
    10de:	ff 1f       	adc	r31, r31
    10e0:	ee 0f       	add	r30, r30
    10e2:	ff 1f       	adc	r31, r31
    10e4:	8e 0f       	add	r24, r30
    10e6:	9f 1f       	adc	r25, r31
    10e8:	fc 01       	movw	r30, r24
    10ea:	e7 56       	subi	r30, 0x67	; 103
    10ec:	fa 4f       	sbci	r31, 0xFA	; 250
    10ee:	80 81       	ld	r24, Z
    10f0:	82 30       	cpi	r24, 0x02	; 2
    10f2:	40 f4       	brcc	.+16     	; 0x1104 <xTaskIncrementTick+0x156>
    10f4:	09 c0       	rjmp	.+18     	; 0x1108 <xTaskIncrementTick+0x15a>
    10f6:	80 91 6a 05 	lds	r24, 0x056A	; 0x80056a <uxPendedTicks>
    10fa:	8f 5f       	subi	r24, 0xFF	; 255
    10fc:	80 93 6a 05 	sts	0x056A, r24	; 0x80056a <uxPendedTicks>
    1100:	d1 2c       	mov	r13, r1
    1102:	02 c0       	rjmp	.+4      	; 0x1108 <xTaskIncrementTick+0x15a>
    1104:	dd 24       	eor	r13, r13
    1106:	d3 94       	inc	r13
    1108:	80 91 69 05 	lds	r24, 0x0569	; 0x800569 <xYieldPending>
    110c:	88 23       	and	r24, r24
    110e:	11 f0       	breq	.+4      	; 0x1114 <xTaskIncrementTick+0x166>
    1110:	dd 24       	eor	r13, r13
    1112:	d3 94       	inc	r13
    1114:	8d 2d       	mov	r24, r13
    1116:	df 91       	pop	r29
    1118:	cf 91       	pop	r28
    111a:	1f 91       	pop	r17
    111c:	0f 91       	pop	r16
    111e:	ff 90       	pop	r15
    1120:	ef 90       	pop	r14
    1122:	df 90       	pop	r13
    1124:	08 95       	ret

00001126 <xTaskResumeAll>:
    1126:	0f 93       	push	r16
    1128:	1f 93       	push	r17
    112a:	cf 93       	push	r28
    112c:	df 93       	push	r29
    112e:	0f b6       	in	r0, 0x3f	; 63
    1130:	f8 94       	cli
    1132:	0f 92       	push	r0
    1134:	80 91 66 05 	lds	r24, 0x0566	; 0x800566 <uxSchedulerSuspended>
    1138:	81 50       	subi	r24, 0x01	; 1
    113a:	80 93 66 05 	sts	0x0566, r24	; 0x800566 <uxSchedulerSuspended>
    113e:	80 91 66 05 	lds	r24, 0x0566	; 0x800566 <uxSchedulerSuspended>
    1142:	81 11       	cpse	r24, r1
    1144:	57 c0       	rjmp	.+174    	; 0x11f4 <xTaskResumeAll+0xce>
    1146:	80 91 6f 05 	lds	r24, 0x056F	; 0x80056f <uxCurrentNumberOfTasks>
    114a:	81 11       	cpse	r24, r1
    114c:	32 c0       	rjmp	.+100    	; 0x11b2 <xTaskResumeAll+0x8c>
    114e:	55 c0       	rjmp	.+170    	; 0x11fa <xTaskResumeAll+0xd4>
    1150:	e0 91 7f 05 	lds	r30, 0x057F	; 0x80057f <xPendingReadyList+0x5>
    1154:	f0 91 80 05 	lds	r31, 0x0580	; 0x800580 <xPendingReadyList+0x6>
    1158:	c6 81       	ldd	r28, Z+6	; 0x06
    115a:	d7 81       	ldd	r29, Z+7	; 0x07
    115c:	ce 01       	movw	r24, r28
    115e:	0c 96       	adiw	r24, 0x0c	; 12
    1160:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
    1164:	8e 01       	movw	r16, r28
    1166:	0e 5f       	subi	r16, 0xFE	; 254
    1168:	1f 4f       	sbci	r17, 0xFF	; 255
    116a:	c8 01       	movw	r24, r16
    116c:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
    1170:	8e 89       	ldd	r24, Y+22	; 0x16
    1172:	90 91 6c 05 	lds	r25, 0x056C	; 0x80056c <uxTopReadyPriority>
    1176:	98 17       	cp	r25, r24
    1178:	10 f4       	brcc	.+4      	; 0x117e <xTaskResumeAll+0x58>
    117a:	80 93 6c 05 	sts	0x056C, r24	; 0x80056c <uxTopReadyPriority>
    117e:	90 e0       	ldi	r25, 0x00	; 0
    1180:	9c 01       	movw	r18, r24
    1182:	22 0f       	add	r18, r18
    1184:	33 1f       	adc	r19, r19
    1186:	22 0f       	add	r18, r18
    1188:	33 1f       	adc	r19, r19
    118a:	22 0f       	add	r18, r18
    118c:	33 1f       	adc	r19, r19
    118e:	82 0f       	add	r24, r18
    1190:	93 1f       	adc	r25, r19
    1192:	b8 01       	movw	r22, r16
    1194:	87 56       	subi	r24, 0x67	; 103
    1196:	9a 4f       	sbci	r25, 0xFA	; 250
    1198:	0e 94 9c 01 	call	0x338	; 0x338 <vListInsertEnd>
    119c:	9e 89       	ldd	r25, Y+22	; 0x16
    119e:	e0 91 e1 05 	lds	r30, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    11a2:	f0 91 e2 05 	lds	r31, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    11a6:	86 89       	ldd	r24, Z+22	; 0x16
    11a8:	98 17       	cp	r25, r24
    11aa:	18 f0       	brcs	.+6      	; 0x11b2 <xTaskResumeAll+0x8c>
    11ac:	81 e0       	ldi	r24, 0x01	; 1
    11ae:	80 93 69 05 	sts	0x0569, r24	; 0x800569 <xYieldPending>
    11b2:	80 91 7a 05 	lds	r24, 0x057A	; 0x80057a <xPendingReadyList>
    11b6:	81 11       	cpse	r24, r1
    11b8:	cb cf       	rjmp	.-106    	; 0x1150 <xTaskResumeAll+0x2a>
    11ba:	80 91 6a 05 	lds	r24, 0x056A	; 0x80056a <uxPendedTicks>
    11be:	81 11       	cpse	r24, r1
    11c0:	0d c0       	rjmp	.+26     	; 0x11dc <xTaskResumeAll+0xb6>
    11c2:	10 c0       	rjmp	.+32     	; 0x11e4 <xTaskResumeAll+0xbe>
    11c4:	0e 94 d7 07 	call	0xfae	; 0xfae <xTaskIncrementTick>
    11c8:	88 23       	and	r24, r24
    11ca:	19 f0       	breq	.+6      	; 0x11d2 <xTaskResumeAll+0xac>
    11cc:	81 e0       	ldi	r24, 0x01	; 1
    11ce:	80 93 69 05 	sts	0x0569, r24	; 0x800569 <xYieldPending>
    11d2:	80 91 6a 05 	lds	r24, 0x056A	; 0x80056a <uxPendedTicks>
    11d6:	81 50       	subi	r24, 0x01	; 1
    11d8:	80 93 6a 05 	sts	0x056A, r24	; 0x80056a <uxPendedTicks>
    11dc:	80 91 6a 05 	lds	r24, 0x056A	; 0x80056a <uxPendedTicks>
    11e0:	81 11       	cpse	r24, r1
    11e2:	f0 cf       	rjmp	.-32     	; 0x11c4 <xTaskResumeAll+0x9e>
    11e4:	80 91 69 05 	lds	r24, 0x0569	; 0x800569 <xYieldPending>
    11e8:	81 30       	cpi	r24, 0x01	; 1
    11ea:	31 f4       	brne	.+12     	; 0x11f8 <xTaskResumeAll+0xd2>
    11ec:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
    11f0:	81 e0       	ldi	r24, 0x01	; 1
    11f2:	03 c0       	rjmp	.+6      	; 0x11fa <xTaskResumeAll+0xd4>
    11f4:	80 e0       	ldi	r24, 0x00	; 0
    11f6:	01 c0       	rjmp	.+2      	; 0x11fa <xTaskResumeAll+0xd4>
    11f8:	80 e0       	ldi	r24, 0x00	; 0
    11fa:	0f 90       	pop	r0
    11fc:	0f be       	out	0x3f, r0	; 63
    11fe:	df 91       	pop	r29
    1200:	cf 91       	pop	r28
    1202:	1f 91       	pop	r17
    1204:	0f 91       	pop	r16
    1206:	08 95       	ret

00001208 <vTaskDelay>:
    1208:	cf 93       	push	r28
    120a:	df 93       	push	r29
    120c:	ec 01       	movw	r28, r24
    120e:	89 2b       	or	r24, r25
    1210:	a9 f0       	breq	.+42     	; 0x123c <vTaskDelay+0x34>
    1212:	0e 94 d1 07 	call	0xfa2	; 0xfa2 <vTaskSuspendAll>
    1216:	80 91 6d 05 	lds	r24, 0x056D	; 0x80056d <xTickCount>
    121a:	90 91 6e 05 	lds	r25, 0x056E	; 0x80056e <xTickCount+0x1>
    121e:	c8 0f       	add	r28, r24
    1220:	d9 1f       	adc	r29, r25
    1222:	80 91 e1 05 	lds	r24, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    1226:	90 91 e2 05 	lds	r25, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    122a:	02 96       	adiw	r24, 0x02	; 2
    122c:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
    1230:	ce 01       	movw	r24, r28
    1232:	0e 94 b7 06 	call	0xd6e	; 0xd6e <prvAddCurrentTaskToDelayedList>
    1236:	0e 94 93 08 	call	0x1126	; 0x1126 <xTaskResumeAll>
    123a:	01 c0       	rjmp	.+2      	; 0x123e <vTaskDelay+0x36>
    123c:	80 e0       	ldi	r24, 0x00	; 0
    123e:	81 11       	cpse	r24, r1
    1240:	02 c0       	rjmp	.+4      	; 0x1246 <vTaskDelay+0x3e>
    1242:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
    1246:	df 91       	pop	r29
    1248:	cf 91       	pop	r28
    124a:	08 95       	ret

0000124c <prvCheckTasksWaitingTermination>:
    124c:	cf 93       	push	r28
    124e:	df 93       	push	r29
    1250:	24 c0       	rjmp	.+72     	; 0x129a <prvCheckTasksWaitingTermination+0x4e>
    1252:	0e 94 d1 07 	call	0xfa2	; 0xfa2 <vTaskSuspendAll>
    1256:	c0 91 71 05 	lds	r28, 0x0571	; 0x800571 <xTasksWaitingTermination>
    125a:	0e 94 93 08 	call	0x1126	; 0x1126 <xTaskResumeAll>
    125e:	cc 23       	and	r28, r28
    1260:	e1 f0       	breq	.+56     	; 0x129a <prvCheckTasksWaitingTermination+0x4e>
    1262:	0f b6       	in	r0, 0x3f	; 63
    1264:	f8 94       	cli
    1266:	0f 92       	push	r0
    1268:	e0 91 76 05 	lds	r30, 0x0576	; 0x800576 <xTasksWaitingTermination+0x5>
    126c:	f0 91 77 05 	lds	r31, 0x0577	; 0x800577 <xTasksWaitingTermination+0x6>
    1270:	c6 81       	ldd	r28, Z+6	; 0x06
    1272:	d7 81       	ldd	r29, Z+7	; 0x07
    1274:	ce 01       	movw	r24, r28
    1276:	02 96       	adiw	r24, 0x02	; 2
    1278:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
    127c:	80 91 6f 05 	lds	r24, 0x056F	; 0x80056f <uxCurrentNumberOfTasks>
    1280:	81 50       	subi	r24, 0x01	; 1
    1282:	80 93 6f 05 	sts	0x056F, r24	; 0x80056f <uxCurrentNumberOfTasks>
    1286:	80 91 70 05 	lds	r24, 0x0570	; 0x800570 <uxTasksDeleted>
    128a:	81 50       	subi	r24, 0x01	; 1
    128c:	80 93 70 05 	sts	0x0570, r24	; 0x800570 <uxTasksDeleted>
    1290:	0f 90       	pop	r0
    1292:	0f be       	out	0x3f, r0	; 63
    1294:	ce 01       	movw	r24, r28
    1296:	0e 94 42 06 	call	0xc84	; 0xc84 <prvDeleteTCB>
    129a:	80 91 70 05 	lds	r24, 0x0570	; 0x800570 <uxTasksDeleted>
    129e:	81 11       	cpse	r24, r1
    12a0:	d8 cf       	rjmp	.-80     	; 0x1252 <prvCheckTasksWaitingTermination+0x6>
    12a2:	df 91       	pop	r29
    12a4:	cf 91       	pop	r28
    12a6:	08 95       	ret

000012a8 <prvIdleTask>:
    12a8:	0e 94 26 09 	call	0x124c	; 0x124c <prvCheckTasksWaitingTermination>
    12ac:	80 91 99 05 	lds	r24, 0x0599	; 0x800599 <pxReadyTasksLists>
    12b0:	82 30       	cpi	r24, 0x02	; 2
    12b2:	d0 f3       	brcs	.-12     	; 0x12a8 <prvIdleTask>
    12b4:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
    12b8:	f7 cf       	rjmp	.-18     	; 0x12a8 <prvIdleTask>

000012ba <vTaskSwitchContext>:
    12ba:	80 91 66 05 	lds	r24, 0x0566	; 0x800566 <uxSchedulerSuspended>
    12be:	88 23       	and	r24, r24
    12c0:	21 f0       	breq	.+8      	; 0x12ca <vTaskSwitchContext+0x10>
    12c2:	81 e0       	ldi	r24, 0x01	; 1
    12c4:	80 93 69 05 	sts	0x0569, r24	; 0x800569 <xYieldPending>
    12c8:	08 95       	ret
    12ca:	10 92 69 05 	sts	0x0569, r1	; 0x800569 <xYieldPending>
    12ce:	05 c0       	rjmp	.+10     	; 0x12da <vTaskSwitchContext+0x20>
    12d0:	80 91 6c 05 	lds	r24, 0x056C	; 0x80056c <uxTopReadyPriority>
    12d4:	81 50       	subi	r24, 0x01	; 1
    12d6:	80 93 6c 05 	sts	0x056C, r24	; 0x80056c <uxTopReadyPriority>
    12da:	80 91 6c 05 	lds	r24, 0x056C	; 0x80056c <uxTopReadyPriority>
    12de:	90 e0       	ldi	r25, 0x00	; 0
    12e0:	fc 01       	movw	r30, r24
    12e2:	ee 0f       	add	r30, r30
    12e4:	ff 1f       	adc	r31, r31
    12e6:	ee 0f       	add	r30, r30
    12e8:	ff 1f       	adc	r31, r31
    12ea:	ee 0f       	add	r30, r30
    12ec:	ff 1f       	adc	r31, r31
    12ee:	8e 0f       	add	r24, r30
    12f0:	9f 1f       	adc	r25, r31
    12f2:	fc 01       	movw	r30, r24
    12f4:	e7 56       	subi	r30, 0x67	; 103
    12f6:	fa 4f       	sbci	r31, 0xFA	; 250
    12f8:	80 81       	ld	r24, Z
    12fa:	88 23       	and	r24, r24
    12fc:	49 f3       	breq	.-46     	; 0x12d0 <vTaskSwitchContext+0x16>
    12fe:	80 91 6c 05 	lds	r24, 0x056C	; 0x80056c <uxTopReadyPriority>
    1302:	90 e0       	ldi	r25, 0x00	; 0
    1304:	9c 01       	movw	r18, r24
    1306:	22 0f       	add	r18, r18
    1308:	33 1f       	adc	r19, r19
    130a:	22 0f       	add	r18, r18
    130c:	33 1f       	adc	r19, r19
    130e:	22 0f       	add	r18, r18
    1310:	33 1f       	adc	r19, r19
    1312:	28 0f       	add	r18, r24
    1314:	39 1f       	adc	r19, r25
    1316:	d9 01       	movw	r26, r18
    1318:	a7 56       	subi	r26, 0x67	; 103
    131a:	ba 4f       	sbci	r27, 0xFA	; 250
    131c:	11 96       	adiw	r26, 0x01	; 1
    131e:	ed 91       	ld	r30, X+
    1320:	fc 91       	ld	r31, X
    1322:	12 97       	sbiw	r26, 0x02	; 2
    1324:	02 80       	ldd	r0, Z+2	; 0x02
    1326:	f3 81       	ldd	r31, Z+3	; 0x03
    1328:	e0 2d       	mov	r30, r0
    132a:	12 96       	adiw	r26, 0x02	; 2
    132c:	fc 93       	st	X, r31
    132e:	ee 93       	st	-X, r30
    1330:	11 97       	sbiw	r26, 0x01	; 1
    1332:	24 56       	subi	r18, 0x64	; 100
    1334:	3a 4f       	sbci	r19, 0xFA	; 250
    1336:	e2 17       	cp	r30, r18
    1338:	f3 07       	cpc	r31, r19
    133a:	29 f4       	brne	.+10     	; 0x1346 <vTaskSwitchContext+0x8c>
    133c:	22 81       	ldd	r18, Z+2	; 0x02
    133e:	33 81       	ldd	r19, Z+3	; 0x03
    1340:	fd 01       	movw	r30, r26
    1342:	32 83       	std	Z+2, r19	; 0x02
    1344:	21 83       	std	Z+1, r18	; 0x01
    1346:	fc 01       	movw	r30, r24
    1348:	ee 0f       	add	r30, r30
    134a:	ff 1f       	adc	r31, r31
    134c:	ee 0f       	add	r30, r30
    134e:	ff 1f       	adc	r31, r31
    1350:	ee 0f       	add	r30, r30
    1352:	ff 1f       	adc	r31, r31
    1354:	8e 0f       	add	r24, r30
    1356:	9f 1f       	adc	r25, r31
    1358:	fc 01       	movw	r30, r24
    135a:	e7 56       	subi	r30, 0x67	; 103
    135c:	fa 4f       	sbci	r31, 0xFA	; 250
    135e:	01 80       	ldd	r0, Z+1	; 0x01
    1360:	f2 81       	ldd	r31, Z+2	; 0x02
    1362:	e0 2d       	mov	r30, r0
    1364:	86 81       	ldd	r24, Z+6	; 0x06
    1366:	97 81       	ldd	r25, Z+7	; 0x07
    1368:	90 93 e2 05 	sts	0x05E2, r25	; 0x8005e2 <pxCurrentTCB+0x1>
    136c:	80 93 e1 05 	sts	0x05E1, r24	; 0x8005e1 <pxCurrentTCB>
    1370:	08 95       	ret

00001372 <vTaskPlaceOnEventList>:
    1372:	cf 93       	push	r28
    1374:	df 93       	push	r29
    1376:	eb 01       	movw	r28, r22
    1378:	60 91 e1 05 	lds	r22, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    137c:	70 91 e2 05 	lds	r23, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    1380:	64 5f       	subi	r22, 0xF4	; 244
    1382:	7f 4f       	sbci	r23, 0xFF	; 255
    1384:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInsert>
    1388:	80 91 e1 05 	lds	r24, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    138c:	90 91 e2 05 	lds	r25, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    1390:	02 96       	adiw	r24, 0x02	; 2
    1392:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
    1396:	80 91 6d 05 	lds	r24, 0x056D	; 0x80056d <xTickCount>
    139a:	90 91 6e 05 	lds	r25, 0x056E	; 0x80056e <xTickCount+0x1>
    139e:	8c 0f       	add	r24, r28
    13a0:	9d 1f       	adc	r25, r29
    13a2:	0e 94 b7 06 	call	0xd6e	; 0xd6e <prvAddCurrentTaskToDelayedList>
    13a6:	df 91       	pop	r29
    13a8:	cf 91       	pop	r28
    13aa:	08 95       	ret

000013ac <vTaskPlaceOnUnorderedEventList>:
    13ac:	cf 93       	push	r28
    13ae:	df 93       	push	r29
    13b0:	ea 01       	movw	r28, r20
    13b2:	e0 91 e1 05 	lds	r30, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    13b6:	f0 91 e2 05 	lds	r31, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    13ba:	70 68       	ori	r23, 0x80	; 128
    13bc:	75 87       	std	Z+13, r23	; 0x0d
    13be:	64 87       	std	Z+12, r22	; 0x0c
    13c0:	60 91 e1 05 	lds	r22, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    13c4:	70 91 e2 05 	lds	r23, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    13c8:	64 5f       	subi	r22, 0xF4	; 244
    13ca:	7f 4f       	sbci	r23, 0xFF	; 255
    13cc:	0e 94 9c 01 	call	0x338	; 0x338 <vListInsertEnd>
    13d0:	80 91 e1 05 	lds	r24, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    13d4:	90 91 e2 05 	lds	r25, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    13d8:	02 96       	adiw	r24, 0x02	; 2
    13da:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
    13de:	80 91 6d 05 	lds	r24, 0x056D	; 0x80056d <xTickCount>
    13e2:	90 91 6e 05 	lds	r25, 0x056E	; 0x80056e <xTickCount+0x1>
    13e6:	8c 0f       	add	r24, r28
    13e8:	9d 1f       	adc	r25, r29
    13ea:	0e 94 b7 06 	call	0xd6e	; 0xd6e <prvAddCurrentTaskToDelayedList>
    13ee:	df 91       	pop	r29
    13f0:	cf 91       	pop	r28
    13f2:	08 95       	ret

000013f4 <xTaskRemoveFromEventList>:
    13f4:	0f 93       	push	r16
    13f6:	1f 93       	push	r17
    13f8:	cf 93       	push	r28
    13fa:	df 93       	push	r29
    13fc:	dc 01       	movw	r26, r24
    13fe:	15 96       	adiw	r26, 0x05	; 5
    1400:	ed 91       	ld	r30, X+
    1402:	fc 91       	ld	r31, X
    1404:	16 97       	sbiw	r26, 0x06	; 6
    1406:	c6 81       	ldd	r28, Z+6	; 0x06
    1408:	d7 81       	ldd	r29, Z+7	; 0x07
    140a:	8e 01       	movw	r16, r28
    140c:	04 5f       	subi	r16, 0xF4	; 244
    140e:	1f 4f       	sbci	r17, 0xFF	; 255
    1410:	c8 01       	movw	r24, r16
    1412:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
    1416:	80 91 66 05 	lds	r24, 0x0566	; 0x800566 <uxSchedulerSuspended>
    141a:	81 11       	cpse	r24, r1
    141c:	1c c0       	rjmp	.+56     	; 0x1456 <xTaskRemoveFromEventList+0x62>
    141e:	0a 50       	subi	r16, 0x0A	; 10
    1420:	11 09       	sbc	r17, r1
    1422:	c8 01       	movw	r24, r16
    1424:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
    1428:	8e 89       	ldd	r24, Y+22	; 0x16
    142a:	90 91 6c 05 	lds	r25, 0x056C	; 0x80056c <uxTopReadyPriority>
    142e:	98 17       	cp	r25, r24
    1430:	10 f4       	brcc	.+4      	; 0x1436 <xTaskRemoveFromEventList+0x42>
    1432:	80 93 6c 05 	sts	0x056C, r24	; 0x80056c <uxTopReadyPriority>
    1436:	90 e0       	ldi	r25, 0x00	; 0
    1438:	9c 01       	movw	r18, r24
    143a:	22 0f       	add	r18, r18
    143c:	33 1f       	adc	r19, r19
    143e:	22 0f       	add	r18, r18
    1440:	33 1f       	adc	r19, r19
    1442:	22 0f       	add	r18, r18
    1444:	33 1f       	adc	r19, r19
    1446:	82 0f       	add	r24, r18
    1448:	93 1f       	adc	r25, r19
    144a:	b8 01       	movw	r22, r16
    144c:	87 56       	subi	r24, 0x67	; 103
    144e:	9a 4f       	sbci	r25, 0xFA	; 250
    1450:	0e 94 9c 01 	call	0x338	; 0x338 <vListInsertEnd>
    1454:	05 c0       	rjmp	.+10     	; 0x1460 <xTaskRemoveFromEventList+0x6c>
    1456:	b8 01       	movw	r22, r16
    1458:	8a e7       	ldi	r24, 0x7A	; 122
    145a:	95 e0       	ldi	r25, 0x05	; 5
    145c:	0e 94 9c 01 	call	0x338	; 0x338 <vListInsertEnd>
    1460:	9e 89       	ldd	r25, Y+22	; 0x16
    1462:	e0 91 e1 05 	lds	r30, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    1466:	f0 91 e2 05 	lds	r31, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    146a:	86 89       	ldd	r24, Z+22	; 0x16
    146c:	89 17       	cp	r24, r25
    146e:	20 f4       	brcc	.+8      	; 0x1478 <xTaskRemoveFromEventList+0x84>
    1470:	81 e0       	ldi	r24, 0x01	; 1
    1472:	80 93 69 05 	sts	0x0569, r24	; 0x800569 <xYieldPending>
    1476:	01 c0       	rjmp	.+2      	; 0x147a <xTaskRemoveFromEventList+0x86>
    1478:	80 e0       	ldi	r24, 0x00	; 0
    147a:	df 91       	pop	r29
    147c:	cf 91       	pop	r28
    147e:	1f 91       	pop	r17
    1480:	0f 91       	pop	r16
    1482:	08 95       	ret

00001484 <xTaskRemoveFromUnorderedEventList>:
    1484:	0f 93       	push	r16
    1486:	1f 93       	push	r17
    1488:	cf 93       	push	r28
    148a:	df 93       	push	r29
    148c:	70 68       	ori	r23, 0x80	; 128
    148e:	fc 01       	movw	r30, r24
    1490:	71 83       	std	Z+1, r23	; 0x01
    1492:	60 83       	st	Z, r22
    1494:	c6 81       	ldd	r28, Z+6	; 0x06
    1496:	d7 81       	ldd	r29, Z+7	; 0x07
    1498:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
    149c:	8e 01       	movw	r16, r28
    149e:	0e 5f       	subi	r16, 0xFE	; 254
    14a0:	1f 4f       	sbci	r17, 0xFF	; 255
    14a2:	c8 01       	movw	r24, r16
    14a4:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
    14a8:	8e 89       	ldd	r24, Y+22	; 0x16
    14aa:	90 91 6c 05 	lds	r25, 0x056C	; 0x80056c <uxTopReadyPriority>
    14ae:	98 17       	cp	r25, r24
    14b0:	10 f4       	brcc	.+4      	; 0x14b6 <xTaskRemoveFromUnorderedEventList+0x32>
    14b2:	80 93 6c 05 	sts	0x056C, r24	; 0x80056c <uxTopReadyPriority>
    14b6:	90 e0       	ldi	r25, 0x00	; 0
    14b8:	9c 01       	movw	r18, r24
    14ba:	22 0f       	add	r18, r18
    14bc:	33 1f       	adc	r19, r19
    14be:	22 0f       	add	r18, r18
    14c0:	33 1f       	adc	r19, r19
    14c2:	22 0f       	add	r18, r18
    14c4:	33 1f       	adc	r19, r19
    14c6:	82 0f       	add	r24, r18
    14c8:	93 1f       	adc	r25, r19
    14ca:	b8 01       	movw	r22, r16
    14cc:	87 56       	subi	r24, 0x67	; 103
    14ce:	9a 4f       	sbci	r25, 0xFA	; 250
    14d0:	0e 94 9c 01 	call	0x338	; 0x338 <vListInsertEnd>
    14d4:	9e 89       	ldd	r25, Y+22	; 0x16
    14d6:	e0 91 e1 05 	lds	r30, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    14da:	f0 91 e2 05 	lds	r31, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    14de:	86 89       	ldd	r24, Z+22	; 0x16
    14e0:	89 17       	cp	r24, r25
    14e2:	20 f4       	brcc	.+8      	; 0x14ec <xTaskRemoveFromUnorderedEventList+0x68>
    14e4:	81 e0       	ldi	r24, 0x01	; 1
    14e6:	80 93 69 05 	sts	0x0569, r24	; 0x800569 <xYieldPending>
    14ea:	01 c0       	rjmp	.+2      	; 0x14ee <xTaskRemoveFromUnorderedEventList+0x6a>
    14ec:	80 e0       	ldi	r24, 0x00	; 0
    14ee:	df 91       	pop	r29
    14f0:	cf 91       	pop	r28
    14f2:	1f 91       	pop	r17
    14f4:	0f 91       	pop	r16
    14f6:	08 95       	ret

000014f8 <vTaskSetTimeOutState>:
    14f8:	20 91 68 05 	lds	r18, 0x0568	; 0x800568 <xNumOfOverflows>
    14fc:	fc 01       	movw	r30, r24
    14fe:	20 83       	st	Z, r18
    1500:	20 91 6d 05 	lds	r18, 0x056D	; 0x80056d <xTickCount>
    1504:	30 91 6e 05 	lds	r19, 0x056E	; 0x80056e <xTickCount+0x1>
    1508:	32 83       	std	Z+2, r19	; 0x02
    150a:	21 83       	std	Z+1, r18	; 0x01
    150c:	08 95       	ret

0000150e <xTaskCheckForTimeOut>:
    150e:	cf 93       	push	r28
    1510:	df 93       	push	r29
    1512:	fc 01       	movw	r30, r24
    1514:	0f b6       	in	r0, 0x3f	; 63
    1516:	f8 94       	cli
    1518:	0f 92       	push	r0
    151a:	40 91 6d 05 	lds	r20, 0x056D	; 0x80056d <xTickCount>
    151e:	50 91 6e 05 	lds	r21, 0x056E	; 0x80056e <xTickCount+0x1>
    1522:	90 81       	ld	r25, Z
    1524:	80 91 68 05 	lds	r24, 0x0568	; 0x800568 <xNumOfOverflows>
    1528:	98 17       	cp	r25, r24
    152a:	29 f0       	breq	.+10     	; 0x1536 <xTaskCheckForTimeOut+0x28>
    152c:	81 81       	ldd	r24, Z+1	; 0x01
    152e:	92 81       	ldd	r25, Z+2	; 0x02
    1530:	48 17       	cp	r20, r24
    1532:	59 07       	cpc	r21, r25
    1534:	b0 f4       	brcc	.+44     	; 0x1562 <xTaskCheckForTimeOut+0x54>
    1536:	21 81       	ldd	r18, Z+1	; 0x01
    1538:	32 81       	ldd	r19, Z+2	; 0x02
    153a:	ca 01       	movw	r24, r20
    153c:	82 1b       	sub	r24, r18
    153e:	93 0b       	sbc	r25, r19
    1540:	eb 01       	movw	r28, r22
    1542:	a8 81       	ld	r26, Y
    1544:	b9 81       	ldd	r27, Y+1	; 0x01
    1546:	8a 17       	cp	r24, r26
    1548:	9b 07       	cpc	r25, r27
    154a:	68 f4       	brcc	.+26     	; 0x1566 <xTaskCheckForTimeOut+0x58>
    154c:	cf 01       	movw	r24, r30
    154e:	24 1b       	sub	r18, r20
    1550:	35 0b       	sbc	r19, r21
    1552:	2a 0f       	add	r18, r26
    1554:	3b 1f       	adc	r19, r27
    1556:	39 83       	std	Y+1, r19	; 0x01
    1558:	28 83       	st	Y, r18
    155a:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <vTaskSetTimeOutState>
    155e:	80 e0       	ldi	r24, 0x00	; 0
    1560:	03 c0       	rjmp	.+6      	; 0x1568 <xTaskCheckForTimeOut+0x5a>
    1562:	81 e0       	ldi	r24, 0x01	; 1
    1564:	01 c0       	rjmp	.+2      	; 0x1568 <xTaskCheckForTimeOut+0x5a>
    1566:	81 e0       	ldi	r24, 0x01	; 1
    1568:	0f 90       	pop	r0
    156a:	0f be       	out	0x3f, r0	; 63
    156c:	df 91       	pop	r29
    156e:	cf 91       	pop	r28
    1570:	08 95       	ret

00001572 <vTaskMissedYield>:
    1572:	81 e0       	ldi	r24, 0x01	; 1
    1574:	80 93 69 05 	sts	0x0569, r24	; 0x800569 <xYieldPending>
    1578:	08 95       	ret

0000157a <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    157a:	0f 93       	push	r16
    157c:	1f 93       	push	r17
    157e:	cf 93       	push	r28
    1580:	df 93       	push	r29
    1582:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    1584:	89 2b       	or	r24, r25
    1586:	09 f4       	brne	.+2      	; 0x158a <vTaskPriorityInherit+0x10>
    1588:	55 c0       	rjmp	.+170    	; 0x1634 <vTaskPriorityInherit+0xba>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    158a:	26 89       	ldd	r18, Z+22	; 0x16
    158c:	a0 91 e1 05 	lds	r26, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    1590:	b0 91 e2 05 	lds	r27, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    1594:	56 96       	adiw	r26, 0x16	; 22
    1596:	8c 91       	ld	r24, X
    1598:	28 17       	cp	r18, r24
    159a:	08 f0       	brcs	.+2      	; 0x159e <vTaskPriorityInherit+0x24>
    159c:	4b c0       	rjmp	.+150    	; 0x1634 <vTaskPriorityInherit+0xba>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    159e:	84 85       	ldd	r24, Z+12	; 0x0c
    15a0:	95 85       	ldd	r25, Z+13	; 0x0d
    15a2:	99 23       	and	r25, r25
    15a4:	64 f0       	brlt	.+24     	; 0x15be <vTaskPriorityInherit+0x44>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    15a6:	a0 91 e1 05 	lds	r26, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    15aa:	b0 91 e2 05 	lds	r27, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    15ae:	56 96       	adiw	r26, 0x16	; 22
    15b0:	3c 91       	ld	r19, X
    15b2:	88 e0       	ldi	r24, 0x08	; 8
    15b4:	90 e0       	ldi	r25, 0x00	; 0
    15b6:	83 1b       	sub	r24, r19
    15b8:	91 09       	sbc	r25, r1
    15ba:	95 87       	std	Z+13, r25	; 0x0d
    15bc:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    15be:	82 85       	ldd	r24, Z+10	; 0x0a
    15c0:	93 85       	ldd	r25, Z+11	; 0x0b
    15c2:	30 e0       	ldi	r19, 0x00	; 0
    15c4:	a9 01       	movw	r20, r18
    15c6:	44 0f       	add	r20, r20
    15c8:	55 1f       	adc	r21, r21
    15ca:	44 0f       	add	r20, r20
    15cc:	55 1f       	adc	r21, r21
    15ce:	44 0f       	add	r20, r20
    15d0:	55 1f       	adc	r21, r21
    15d2:	24 0f       	add	r18, r20
    15d4:	35 1f       	adc	r19, r21
    15d6:	27 56       	subi	r18, 0x67	; 103
    15d8:	3a 4f       	sbci	r19, 0xFA	; 250
    15da:	82 17       	cp	r24, r18
    15dc:	93 07       	cpc	r25, r19
    15de:	19 f5       	brne	.+70     	; 0x1626 <vTaskPriorityInherit+0xac>
    15e0:	8f 01       	movw	r16, r30
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    15e2:	ef 01       	movw	r28, r30
    15e4:	22 96       	adiw	r28, 0x02	; 2
    15e6:	ce 01       	movw	r24, r28
    15e8:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    15ec:	e0 91 e1 05 	lds	r30, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    15f0:	f0 91 e2 05 	lds	r31, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    15f4:	86 89       	ldd	r24, Z+22	; 0x16
    15f6:	f8 01       	movw	r30, r16
    15f8:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    15fa:	90 91 6c 05 	lds	r25, 0x056C	; 0x80056c <uxTopReadyPriority>
    15fe:	98 17       	cp	r25, r24
    1600:	10 f4       	brcc	.+4      	; 0x1606 <vTaskPriorityInherit+0x8c>
    1602:	80 93 6c 05 	sts	0x056C, r24	; 0x80056c <uxTopReadyPriority>
    1606:	90 e0       	ldi	r25, 0x00	; 0
    1608:	9c 01       	movw	r18, r24
    160a:	22 0f       	add	r18, r18
    160c:	33 1f       	adc	r19, r19
    160e:	22 0f       	add	r18, r18
    1610:	33 1f       	adc	r19, r19
    1612:	22 0f       	add	r18, r18
    1614:	33 1f       	adc	r19, r19
    1616:	82 0f       	add	r24, r18
    1618:	93 1f       	adc	r25, r19
    161a:	be 01       	movw	r22, r28
    161c:	87 56       	subi	r24, 0x67	; 103
    161e:	9a 4f       	sbci	r25, 0xFA	; 250
    1620:	0e 94 9c 01 	call	0x338	; 0x338 <vListInsertEnd>
    1624:	07 c0       	rjmp	.+14     	; 0x1634 <vTaskPriorityInherit+0xba>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1626:	a0 91 e1 05 	lds	r26, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    162a:	b0 91 e2 05 	lds	r27, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    162e:	56 96       	adiw	r26, 0x16	; 22
    1630:	8c 91       	ld	r24, X
    1632:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1634:	df 91       	pop	r29
    1636:	cf 91       	pop	r28
    1638:	1f 91       	pop	r17
    163a:	0f 91       	pop	r16
    163c:	08 95       	ret

0000163e <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    163e:	0f 93       	push	r16
    1640:	1f 93       	push	r17
    1642:	cf 93       	push	r28
    1644:	df 93       	push	r29
    1646:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    1648:	89 2b       	or	r24, r25
    164a:	79 f1       	breq	.+94     	; 0x16aa <xTaskPriorityDisinherit+0x6c>
		{
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    164c:	86 a5       	ldd	r24, Z+46	; 0x2e
    164e:	81 50       	subi	r24, 0x01	; 1
    1650:	86 a7       	std	Z+46, r24	; 0x2e

			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1652:	26 89       	ldd	r18, Z+22	; 0x16
    1654:	95 a5       	ldd	r25, Z+45	; 0x2d
    1656:	29 17       	cp	r18, r25
    1658:	51 f1       	breq	.+84     	; 0x16ae <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    165a:	81 11       	cpse	r24, r1
    165c:	2a c0       	rjmp	.+84     	; 0x16b2 <xTaskPriorityDisinherit+0x74>
    165e:	ef 01       	movw	r28, r30
				{
					/* The holding task must be the running task to be able to give
					the mutex back.  Remove the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1660:	8f 01       	movw	r16, r30
    1662:	0e 5f       	subi	r16, 0xFE	; 254
    1664:	1f 4f       	sbci	r17, 0xFF	; 255
    1666:	c8 01       	movw	r24, r16
    1668:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the new
					ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    166c:	8d a5       	ldd	r24, Y+45	; 0x2d
    166e:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1670:	28 e0       	ldi	r18, 0x08	; 8
    1672:	30 e0       	ldi	r19, 0x00	; 0
    1674:	28 1b       	sub	r18, r24
    1676:	31 09       	sbc	r19, r1
    1678:	3d 87       	std	Y+13, r19	; 0x0d
    167a:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    167c:	90 91 6c 05 	lds	r25, 0x056C	; 0x80056c <uxTopReadyPriority>
    1680:	98 17       	cp	r25, r24
    1682:	10 f4       	brcc	.+4      	; 0x1688 <xTaskPriorityDisinherit+0x4a>
    1684:	80 93 6c 05 	sts	0x056C, r24	; 0x80056c <uxTopReadyPriority>
    1688:	90 e0       	ldi	r25, 0x00	; 0
    168a:	9c 01       	movw	r18, r24
    168c:	22 0f       	add	r18, r18
    168e:	33 1f       	adc	r19, r19
    1690:	22 0f       	add	r18, r18
    1692:	33 1f       	adc	r19, r19
    1694:	22 0f       	add	r18, r18
    1696:	33 1f       	adc	r19, r19
    1698:	82 0f       	add	r24, r18
    169a:	93 1f       	adc	r25, r19
    169c:	b8 01       	movw	r22, r16
    169e:	87 56       	subi	r24, 0x67	; 103
    16a0:	9a 4f       	sbci	r25, 0xFA	; 250
    16a2:	0e 94 9c 01 	call	0x338	; 0x338 <vListInsertEnd>

					/* Return true to indicate that a context switch is required.
					This is only actually required in the corner case whereby
					multiple mutexes were held and the mutexes were given back
					in an order different to that in which they were taken. */
					xReturn = pdTRUE;
    16a6:	81 e0       	ldi	r24, 0x01	; 1
    16a8:	05 c0       	rjmp	.+10     	; 0x16b4 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    16aa:	80 e0       	ldi	r24, 0x00	; 0
    16ac:	03 c0       	rjmp	.+6      	; 0x16b4 <xTaskPriorityDisinherit+0x76>
    16ae:	80 e0       	ldi	r24, 0x00	; 0
    16b0:	01 c0       	rjmp	.+2      	; 0x16b4 <xTaskPriorityDisinherit+0x76>
    16b2:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    16b4:	df 91       	pop	r29
    16b6:	cf 91       	pop	r28
    16b8:	1f 91       	pop	r17
    16ba:	0f 91       	pop	r16
    16bc:	08 95       	ret

000016be <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    16be:	e0 91 e1 05 	lds	r30, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    16c2:	f0 91 e2 05 	lds	r31, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    16c6:	84 85       	ldd	r24, Z+12	; 0x0c
    16c8:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    16ca:	e0 91 e1 05 	lds	r30, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    16ce:	f0 91 e2 05 	lds	r31, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    16d2:	a0 91 e1 05 	lds	r26, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    16d6:	b0 91 e2 05 	lds	r27, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    16da:	56 96       	adiw	r26, 0x16	; 22
    16dc:	4c 91       	ld	r20, X
    16de:	28 e0       	ldi	r18, 0x08	; 8
    16e0:	30 e0       	ldi	r19, 0x00	; 0
    16e2:	24 1b       	sub	r18, r20
    16e4:	31 09       	sbc	r19, r1
    16e6:	35 87       	std	Z+13, r19	; 0x0d
    16e8:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    16ea:	08 95       	ret

000016ec <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    16ec:	80 91 e1 05 	lds	r24, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    16f0:	90 91 e2 05 	lds	r25, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    16f4:	89 2b       	or	r24, r25
    16f6:	39 f0       	breq	.+14     	; 0x1706 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    16f8:	e0 91 e1 05 	lds	r30, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    16fc:	f0 91 e2 05 	lds	r31, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
    1700:	86 a5       	ldd	r24, Z+46	; 0x2e
    1702:	8f 5f       	subi	r24, 0xFF	; 255
    1704:	86 a7       	std	Z+46, r24	; 0x2e
		}

		return pxCurrentTCB;
    1706:	80 91 e1 05 	lds	r24, 0x05E1	; 0x8005e1 <pxCurrentTCB>
    170a:	90 91 e2 05 	lds	r25, 0x05E2	; 0x8005e2 <pxCurrentTCB+0x1>
	}
    170e:	08 95       	ret

00001710 <LCD_WriteCommand>:
	
	for (u8 i=0; i<Numofcells; ++i)
	{
		LCD_WriteData(' ');
	}
}
    1710:	cf 93       	push	r28
    1712:	c8 2f       	mov	r28, r24
    1714:	60 e0       	ldi	r22, 0x00	; 0
    1716:	81 e0       	ldi	r24, 0x01	; 1
    1718:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    171c:	6c 2f       	mov	r22, r28
    171e:	66 1f       	adc	r22, r22
    1720:	66 27       	eor	r22, r22
    1722:	66 1f       	adc	r22, r22
    1724:	86 e0       	ldi	r24, 0x06	; 6
    1726:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    172a:	c6 fb       	bst	r28, 6
    172c:	66 27       	eor	r22, r22
    172e:	60 f9       	bld	r22, 0
    1730:	85 e0       	ldi	r24, 0x05	; 5
    1732:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    1736:	c5 fb       	bst	r28, 5
    1738:	66 27       	eor	r22, r22
    173a:	60 f9       	bld	r22, 0
    173c:	84 e0       	ldi	r24, 0x04	; 4
    173e:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    1742:	c4 fb       	bst	r28, 4
    1744:	66 27       	eor	r22, r22
    1746:	60 f9       	bld	r22, 0
    1748:	83 e0       	ldi	r24, 0x03	; 3
    174a:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    174e:	61 e0       	ldi	r22, 0x01	; 1
    1750:	82 e0       	ldi	r24, 0x02	; 2
    1752:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    1756:	8f e9       	ldi	r24, 0x9F	; 159
    1758:	9f e0       	ldi	r25, 0x0F	; 15
    175a:	01 97       	sbiw	r24, 0x01	; 1
    175c:	f1 f7       	brne	.-4      	; 0x175a <LCD_WriteCommand+0x4a>
    175e:	00 c0       	rjmp	.+0      	; 0x1760 <LCD_WriteCommand+0x50>
    1760:	00 00       	nop
    1762:	60 e0       	ldi	r22, 0x00	; 0
    1764:	82 e0       	ldi	r24, 0x02	; 2
    1766:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    176a:	8f e9       	ldi	r24, 0x9F	; 159
    176c:	9f e0       	ldi	r25, 0x0F	; 15
    176e:	01 97       	sbiw	r24, 0x01	; 1
    1770:	f1 f7       	brne	.-4      	; 0x176e <LCD_WriteCommand+0x5e>
    1772:	00 c0       	rjmp	.+0      	; 0x1774 <LCD_WriteCommand+0x64>
    1774:	00 00       	nop
    1776:	c3 fb       	bst	r28, 3
    1778:	66 27       	eor	r22, r22
    177a:	60 f9       	bld	r22, 0
    177c:	86 e0       	ldi	r24, 0x06	; 6
    177e:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    1782:	c2 fb       	bst	r28, 2
    1784:	66 27       	eor	r22, r22
    1786:	60 f9       	bld	r22, 0
    1788:	85 e0       	ldi	r24, 0x05	; 5
    178a:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    178e:	c1 fb       	bst	r28, 1
    1790:	66 27       	eor	r22, r22
    1792:	60 f9       	bld	r22, 0
    1794:	84 e0       	ldi	r24, 0x04	; 4
    1796:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    179a:	6c 2f       	mov	r22, r28
    179c:	61 70       	andi	r22, 0x01	; 1
    179e:	83 e0       	ldi	r24, 0x03	; 3
    17a0:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    17a4:	61 e0       	ldi	r22, 0x01	; 1
    17a6:	82 e0       	ldi	r24, 0x02	; 2
    17a8:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    17ac:	8f e9       	ldi	r24, 0x9F	; 159
    17ae:	9f e0       	ldi	r25, 0x0F	; 15
    17b0:	01 97       	sbiw	r24, 0x01	; 1
    17b2:	f1 f7       	brne	.-4      	; 0x17b0 <LCD_WriteCommand+0xa0>
    17b4:	00 c0       	rjmp	.+0      	; 0x17b6 <LCD_WriteCommand+0xa6>
    17b6:	00 00       	nop
    17b8:	60 e0       	ldi	r22, 0x00	; 0
    17ba:	82 e0       	ldi	r24, 0x02	; 2
    17bc:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    17c0:	8f e9       	ldi	r24, 0x9F	; 159
    17c2:	9f e0       	ldi	r25, 0x0F	; 15
    17c4:	01 97       	sbiw	r24, 0x01	; 1
    17c6:	f1 f7       	brne	.-4      	; 0x17c4 <LCD_WriteCommand+0xb4>
    17c8:	00 c0       	rjmp	.+0      	; 0x17ca <LCD_WriteCommand+0xba>
    17ca:	00 00       	nop
    17cc:	cf 91       	pop	r28
    17ce:	08 95       	ret

000017d0 <LCD_WriteData>:
    17d0:	cf 93       	push	r28
    17d2:	c8 2f       	mov	r28, r24
    17d4:	61 e0       	ldi	r22, 0x01	; 1
    17d6:	81 e0       	ldi	r24, 0x01	; 1
    17d8:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    17dc:	6c 2f       	mov	r22, r28
    17de:	66 1f       	adc	r22, r22
    17e0:	66 27       	eor	r22, r22
    17e2:	66 1f       	adc	r22, r22
    17e4:	86 e0       	ldi	r24, 0x06	; 6
    17e6:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    17ea:	c6 fb       	bst	r28, 6
    17ec:	66 27       	eor	r22, r22
    17ee:	60 f9       	bld	r22, 0
    17f0:	85 e0       	ldi	r24, 0x05	; 5
    17f2:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    17f6:	c5 fb       	bst	r28, 5
    17f8:	66 27       	eor	r22, r22
    17fa:	60 f9       	bld	r22, 0
    17fc:	84 e0       	ldi	r24, 0x04	; 4
    17fe:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    1802:	c4 fb       	bst	r28, 4
    1804:	66 27       	eor	r22, r22
    1806:	60 f9       	bld	r22, 0
    1808:	83 e0       	ldi	r24, 0x03	; 3
    180a:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    180e:	61 e0       	ldi	r22, 0x01	; 1
    1810:	82 e0       	ldi	r24, 0x02	; 2
    1812:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    1816:	8f e9       	ldi	r24, 0x9F	; 159
    1818:	9f e0       	ldi	r25, 0x0F	; 15
    181a:	01 97       	sbiw	r24, 0x01	; 1
    181c:	f1 f7       	brne	.-4      	; 0x181a <LCD_WriteData+0x4a>
    181e:	00 c0       	rjmp	.+0      	; 0x1820 <LCD_WriteData+0x50>
    1820:	00 00       	nop
    1822:	60 e0       	ldi	r22, 0x00	; 0
    1824:	82 e0       	ldi	r24, 0x02	; 2
    1826:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    182a:	8f e9       	ldi	r24, 0x9F	; 159
    182c:	9f e0       	ldi	r25, 0x0F	; 15
    182e:	01 97       	sbiw	r24, 0x01	; 1
    1830:	f1 f7       	brne	.-4      	; 0x182e <LCD_WriteData+0x5e>
    1832:	00 c0       	rjmp	.+0      	; 0x1834 <LCD_WriteData+0x64>
    1834:	00 00       	nop
    1836:	c3 fb       	bst	r28, 3
    1838:	66 27       	eor	r22, r22
    183a:	60 f9       	bld	r22, 0
    183c:	86 e0       	ldi	r24, 0x06	; 6
    183e:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    1842:	c2 fb       	bst	r28, 2
    1844:	66 27       	eor	r22, r22
    1846:	60 f9       	bld	r22, 0
    1848:	85 e0       	ldi	r24, 0x05	; 5
    184a:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    184e:	c1 fb       	bst	r28, 1
    1850:	66 27       	eor	r22, r22
    1852:	60 f9       	bld	r22, 0
    1854:	84 e0       	ldi	r24, 0x04	; 4
    1856:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    185a:	6c 2f       	mov	r22, r28
    185c:	61 70       	andi	r22, 0x01	; 1
    185e:	83 e0       	ldi	r24, 0x03	; 3
    1860:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    1864:	61 e0       	ldi	r22, 0x01	; 1
    1866:	82 e0       	ldi	r24, 0x02	; 2
    1868:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    186c:	8f e9       	ldi	r24, 0x9F	; 159
    186e:	9f e0       	ldi	r25, 0x0F	; 15
    1870:	01 97       	sbiw	r24, 0x01	; 1
    1872:	f1 f7       	brne	.-4      	; 0x1870 <LCD_WriteData+0xa0>
    1874:	00 c0       	rjmp	.+0      	; 0x1876 <LCD_WriteData+0xa6>
    1876:	00 00       	nop
    1878:	60 e0       	ldi	r22, 0x00	; 0
    187a:	82 e0       	ldi	r24, 0x02	; 2
    187c:	0e 94 cf 10 	call	0x219e	; 0x219e <DIO_WritePin>
    1880:	8f e9       	ldi	r24, 0x9F	; 159
    1882:	9f e0       	ldi	r25, 0x0F	; 15
    1884:	01 97       	sbiw	r24, 0x01	; 1
    1886:	f1 f7       	brne	.-4      	; 0x1884 <LCD_WriteData+0xb4>
    1888:	00 c0       	rjmp	.+0      	; 0x188a <LCD_WriteData+0xba>
    188a:	00 00       	nop
    188c:	cf 91       	pop	r28
    188e:	08 95       	ret

00001890 <LCD_Init>:
    1890:	2f e7       	ldi	r18, 0x7F	; 127
    1892:	88 e3       	ldi	r24, 0x38	; 56
    1894:	91 e0       	ldi	r25, 0x01	; 1
    1896:	21 50       	subi	r18, 0x01	; 1
    1898:	80 40       	sbci	r24, 0x00	; 0
    189a:	90 40       	sbci	r25, 0x00	; 0
    189c:	e1 f7       	brne	.-8      	; 0x1896 <LCD_Init+0x6>
    189e:	00 c0       	rjmp	.+0      	; 0x18a0 <LCD_Init+0x10>
    18a0:	00 00       	nop
    18a2:	82 e0       	ldi	r24, 0x02	; 2
    18a4:	0e 94 88 0b 	call	0x1710	; 0x1710 <LCD_WriteCommand>
    18a8:	8f ec       	ldi	r24, 0xCF	; 207
    18aa:	97 e0       	ldi	r25, 0x07	; 7
    18ac:	01 97       	sbiw	r24, 0x01	; 1
    18ae:	f1 f7       	brne	.-4      	; 0x18ac <LCD_Init+0x1c>
    18b0:	00 c0       	rjmp	.+0      	; 0x18b2 <LCD_Init+0x22>
    18b2:	00 00       	nop
    18b4:	88 e2       	ldi	r24, 0x28	; 40
    18b6:	0e 94 88 0b 	call	0x1710	; 0x1710 <LCD_WriteCommand>
    18ba:	8f ec       	ldi	r24, 0xCF	; 207
    18bc:	97 e0       	ldi	r25, 0x07	; 7
    18be:	01 97       	sbiw	r24, 0x01	; 1
    18c0:	f1 f7       	brne	.-4      	; 0x18be <LCD_Init+0x2e>
    18c2:	00 c0       	rjmp	.+0      	; 0x18c4 <LCD_Init+0x34>
    18c4:	00 00       	nop
    18c6:	8c e0       	ldi	r24, 0x0C	; 12
    18c8:	0e 94 88 0b 	call	0x1710	; 0x1710 <LCD_WriteCommand>
    18cc:	8f ec       	ldi	r24, 0xCF	; 207
    18ce:	97 e0       	ldi	r25, 0x07	; 7
    18d0:	01 97       	sbiw	r24, 0x01	; 1
    18d2:	f1 f7       	brne	.-4      	; 0x18d0 <LCD_Init+0x40>
    18d4:	00 c0       	rjmp	.+0      	; 0x18d6 <LCD_Init+0x46>
    18d6:	00 00       	nop
    18d8:	81 e0       	ldi	r24, 0x01	; 1
    18da:	0e 94 88 0b 	call	0x1710	; 0x1710 <LCD_WriteCommand>
    18de:	8f e3       	ldi	r24, 0x3F	; 63
    18e0:	9c e9       	ldi	r25, 0x9C	; 156
    18e2:	01 97       	sbiw	r24, 0x01	; 1
    18e4:	f1 f7       	brne	.-4      	; 0x18e2 <LCD_Init+0x52>
    18e6:	00 c0       	rjmp	.+0      	; 0x18e8 <LCD_Init+0x58>
    18e8:	00 00       	nop
    18ea:	86 e0       	ldi	r24, 0x06	; 6
    18ec:	0e 94 88 0b 	call	0x1710	; 0x1710 <LCD_WriteCommand>
    18f0:	80 e8       	ldi	r24, 0x80	; 128
    18f2:	0e 94 88 0b 	call	0x1710	; 0x1710 <LCD_WriteCommand>
    18f6:	08 95       	ret

000018f8 <LCD_WriteChar>:
    18f8:	0e 94 e8 0b 	call	0x17d0	; 0x17d0 <LCD_WriteData>
    18fc:	08 95       	ret

000018fe <LCD_WriteSentence>:
    18fe:	0f 93       	push	r16
    1900:	1f 93       	push	r17
    1902:	cf 93       	push	r28
    1904:	8c 01       	movw	r16, r24
    1906:	c0 e0       	ldi	r28, 0x00	; 0
    1908:	03 c0       	rjmp	.+6      	; 0x1910 <LCD_WriteSentence+0x12>
    190a:	0e 94 e8 0b 	call	0x17d0	; 0x17d0 <LCD_WriteData>
    190e:	cf 5f       	subi	r28, 0xFF	; 255
    1910:	f8 01       	movw	r30, r16
    1912:	ec 0f       	add	r30, r28
    1914:	f1 1d       	adc	r31, r1
    1916:	80 81       	ld	r24, Z
    1918:	81 11       	cpse	r24, r1
    191a:	f7 cf       	rjmp	.-18     	; 0x190a <LCD_WriteSentence+0xc>
    191c:	cf 91       	pop	r28
    191e:	1f 91       	pop	r17
    1920:	0f 91       	pop	r16
    1922:	08 95       	ret

00001924 <LCD_WriteNumber>:
    1924:	2f 92       	push	r2
    1926:	3f 92       	push	r3
    1928:	4f 92       	push	r4
    192a:	5f 92       	push	r5
    192c:	6f 92       	push	r6
    192e:	7f 92       	push	r7
    1930:	8f 92       	push	r8
    1932:	9f 92       	push	r9
    1934:	af 92       	push	r10
    1936:	bf 92       	push	r11
    1938:	cf 92       	push	r12
    193a:	df 92       	push	r13
    193c:	ef 92       	push	r14
    193e:	ff 92       	push	r15
    1940:	0f 93       	push	r16
    1942:	1f 93       	push	r17
    1944:	cf 93       	push	r28
    1946:	df 93       	push	r29
    1948:	cd b7       	in	r28, 0x3d	; 61
    194a:	de b7       	in	r29, 0x3e	; 62
    194c:	67 97       	sbiw	r28, 0x17	; 23
    194e:	0f b6       	in	r0, 0x3f	; 63
    1950:	f8 94       	cli
    1952:	de bf       	out	0x3e, r29	; 62
    1954:	0f be       	out	0x3f, r0	; 63
    1956:	cd bf       	out	0x3d, r28	; 61
    1958:	2d 8b       	std	Y+21, r18	; 0x15
    195a:	3e 8b       	std	Y+22, r19	; 0x16
    195c:	74 2e       	mov	r7, r20
    195e:	65 2e       	mov	r6, r21
    1960:	56 2e       	mov	r5, r22
    1962:	47 2e       	mov	r4, r23
    1964:	38 2e       	mov	r3, r24
    1966:	29 2e       	mov	r2, r25
    1968:	a0 e0       	ldi	r26, 0x00	; 0
    196a:	0e 94 ea 12 	call	0x25d4	; 0x25d4 <__cmpdi2_s8>
    196e:	19 f4       	brne	.+6      	; 0x1976 <LCD_WriteNumber+0x52>
    1970:	80 e3       	ldi	r24, 0x30	; 48
    1972:	0e 94 e8 0b 	call	0x17d0	; 0x17d0 <LCD_WriteData>
    1976:	2d 89       	ldd	r18, Y+21	; 0x15
    1978:	3e 89       	ldd	r19, Y+22	; 0x16
    197a:	47 2d       	mov	r20, r7
    197c:	56 2d       	mov	r21, r6
    197e:	65 2d       	mov	r22, r5
    1980:	74 2d       	mov	r23, r4
    1982:	83 2d       	mov	r24, r3
    1984:	92 2d       	mov	r25, r2
    1986:	a0 e0       	ldi	r26, 0x00	; 0
    1988:	0e 94 ea 12 	call	0x25d4	; 0x25d4 <__cmpdi2_s8>
    198c:	6c f4       	brge	.+26     	; 0x19a8 <LCD_WriteNumber+0x84>
    198e:	0e 94 a3 12 	call	0x2546	; 0x2546 <__negdi2>
    1992:	2d 8b       	std	Y+21, r18	; 0x15
    1994:	3e 8b       	std	Y+22, r19	; 0x16
    1996:	74 2e       	mov	r7, r20
    1998:	65 2e       	mov	r6, r21
    199a:	56 2e       	mov	r5, r22
    199c:	47 2e       	mov	r4, r23
    199e:	38 2e       	mov	r3, r24
    19a0:	29 2e       	mov	r2, r25
    19a2:	8d e2       	ldi	r24, 0x2D	; 45
    19a4:	0e 94 e8 0b 	call	0x17d0	; 0x17d0 <LCD_WriteData>
    19a8:	81 2c       	mov	r8, r1
    19aa:	34 c0       	rjmp	.+104    	; 0x1a14 <LCD_WriteNumber+0xf0>
    19ac:	81 e0       	ldi	r24, 0x01	; 1
    19ae:	88 0d       	add	r24, r8
    19b0:	8f 8b       	std	Y+23, r24	; 0x17
    19b2:	91 2c       	mov	r9, r1
    19b4:	0f 2e       	mov	r0, r31
    19b6:	fa e0       	ldi	r31, 0x0A	; 10
    19b8:	af 2e       	mov	r10, r31
    19ba:	f0 2d       	mov	r31, r0
    19bc:	b1 2c       	mov	r11, r1
    19be:	c1 2c       	mov	r12, r1
    19c0:	d1 2c       	mov	r13, r1
    19c2:	e1 2c       	mov	r14, r1
    19c4:	f1 2c       	mov	r15, r1
    19c6:	00 e0       	ldi	r16, 0x00	; 0
    19c8:	10 e0       	ldi	r17, 0x00	; 0
    19ca:	2d 89       	ldd	r18, Y+21	; 0x15
    19cc:	3e 89       	ldd	r19, Y+22	; 0x16
    19ce:	47 2d       	mov	r20, r7
    19d0:	56 2d       	mov	r21, r6
    19d2:	65 2d       	mov	r22, r5
    19d4:	74 2d       	mov	r23, r4
    19d6:	83 2d       	mov	r24, r3
    19d8:	92 2d       	mov	r25, r2
    19da:	0e 94 13 12 	call	0x2426	; 0x2426 <__moddi3>
    19de:	e1 e0       	ldi	r30, 0x01	; 1
    19e0:	f0 e0       	ldi	r31, 0x00	; 0
    19e2:	ec 0f       	add	r30, r28
    19e4:	fd 1f       	adc	r31, r29
    19e6:	e8 0d       	add	r30, r8
    19e8:	f9 1d       	adc	r31, r9
    19ea:	20 5d       	subi	r18, 0xD0	; 208
    19ec:	20 83       	st	Z, r18
    19ee:	2d 89       	ldd	r18, Y+21	; 0x15
    19f0:	3e 89       	ldd	r19, Y+22	; 0x16
    19f2:	47 2d       	mov	r20, r7
    19f4:	56 2d       	mov	r21, r6
    19f6:	65 2d       	mov	r22, r5
    19f8:	74 2d       	mov	r23, r4
    19fa:	83 2d       	mov	r24, r3
    19fc:	92 2d       	mov	r25, r2
    19fe:	0e 94 15 12 	call	0x242a	; 0x242a <__divdi3>
    1a02:	2d 8b       	std	Y+21, r18	; 0x15
    1a04:	3e 8b       	std	Y+22, r19	; 0x16
    1a06:	74 2e       	mov	r7, r20
    1a08:	65 2e       	mov	r6, r21
    1a0a:	56 2e       	mov	r5, r22
    1a0c:	47 2e       	mov	r4, r23
    1a0e:	38 2e       	mov	r3, r24
    1a10:	29 2e       	mov	r2, r25
    1a12:	8f 88       	ldd	r8, Y+23	; 0x17
    1a14:	2d 89       	ldd	r18, Y+21	; 0x15
    1a16:	3e 89       	ldd	r19, Y+22	; 0x16
    1a18:	47 2d       	mov	r20, r7
    1a1a:	56 2d       	mov	r21, r6
    1a1c:	65 2d       	mov	r22, r5
    1a1e:	74 2d       	mov	r23, r4
    1a20:	83 2d       	mov	r24, r3
    1a22:	92 2d       	mov	r25, r2
    1a24:	a0 e0       	ldi	r26, 0x00	; 0
    1a26:	0e 94 ea 12 	call	0x25d4	; 0x25d4 <__cmpdi2_s8>
    1a2a:	09 f0       	breq	.+2      	; 0x1a2e <LCD_WriteNumber+0x10a>
    1a2c:	bf cf       	rjmp	.-130    	; 0x19ac <LCD_WriteNumber+0x88>
    1a2e:	0d c0       	rjmp	.+26     	; 0x1a4a <LCD_WriteNumber+0x126>
    1a30:	e8 2d       	mov	r30, r8
    1a32:	f0 e0       	ldi	r31, 0x00	; 0
    1a34:	31 97       	sbiw	r30, 0x01	; 1
    1a36:	81 e0       	ldi	r24, 0x01	; 1
    1a38:	90 e0       	ldi	r25, 0x00	; 0
    1a3a:	8c 0f       	add	r24, r28
    1a3c:	9d 1f       	adc	r25, r29
    1a3e:	e8 0f       	add	r30, r24
    1a40:	f9 1f       	adc	r31, r25
    1a42:	80 81       	ld	r24, Z
    1a44:	0e 94 e8 0b 	call	0x17d0	; 0x17d0 <LCD_WriteData>
    1a48:	8a 94       	dec	r8
    1a4a:	81 10       	cpse	r8, r1
    1a4c:	f1 cf       	rjmp	.-30     	; 0x1a30 <LCD_WriteNumber+0x10c>
    1a4e:	67 96       	adiw	r28, 0x17	; 23
    1a50:	0f b6       	in	r0, 0x3f	; 63
    1a52:	f8 94       	cli
    1a54:	de bf       	out	0x3e, r29	; 62
    1a56:	0f be       	out	0x3f, r0	; 63
    1a58:	cd bf       	out	0x3d, r28	; 61
    1a5a:	df 91       	pop	r29
    1a5c:	cf 91       	pop	r28
    1a5e:	1f 91       	pop	r17
    1a60:	0f 91       	pop	r16
    1a62:	ff 90       	pop	r15
    1a64:	ef 90       	pop	r14
    1a66:	df 90       	pop	r13
    1a68:	cf 90       	pop	r12
    1a6a:	bf 90       	pop	r11
    1a6c:	af 90       	pop	r10
    1a6e:	9f 90       	pop	r9
    1a70:	8f 90       	pop	r8
    1a72:	7f 90       	pop	r7
    1a74:	6f 90       	pop	r6
    1a76:	5f 90       	pop	r5
    1a78:	4f 90       	pop	r4
    1a7a:	3f 90       	pop	r3
    1a7c:	2f 90       	pop	r2
    1a7e:	08 95       	ret

00001a80 <LCD_GoTo>:
    1a80:	81 11       	cpse	r24, r1
    1a82:	07 c0       	rjmp	.+14     	; 0x1a92 <LCD_GoTo+0x12>
    1a84:	60 31       	cpi	r22, 0x10	; 16
    1a86:	68 f4       	brcc	.+26     	; 0x1aa2 <LCD_GoTo+0x22>
    1a88:	80 e8       	ldi	r24, 0x80	; 128
    1a8a:	86 0f       	add	r24, r22
    1a8c:	0e 94 88 0b 	call	0x1710	; 0x1710 <LCD_WriteCommand>
    1a90:	08 95       	ret
    1a92:	81 30       	cpi	r24, 0x01	; 1
    1a94:	31 f4       	brne	.+12     	; 0x1aa2 <LCD_GoTo+0x22>
    1a96:	60 31       	cpi	r22, 0x10	; 16
    1a98:	20 f4       	brcc	.+8      	; 0x1aa2 <LCD_GoTo+0x22>
    1a9a:	80 ec       	ldi	r24, 0xC0	; 192
    1a9c:	86 0f       	add	r24, r22
    1a9e:	0e 94 88 0b 	call	0x1710	; 0x1710 <LCD_WriteCommand>
    1aa2:	08 95       	ret

00001aa4 <LCD_GoToWriteString>:

void LCD_GoToWriteString(u8 line,u8 cell,u8*str)
{
    1aa4:	cf 93       	push	r28
    1aa6:	df 93       	push	r29
    1aa8:	ea 01       	movw	r28, r20
	LCD_GoTo(line,cell);
    1aaa:	0e 94 40 0d 	call	0x1a80	; 0x1a80 <LCD_GoTo>
	LCD_WriteSentence(str);
    1aae:	ce 01       	movw	r24, r28
    1ab0:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_WriteSentence>
}
    1ab4:	df 91       	pop	r29
    1ab6:	cf 91       	pop	r28
    1ab8:	08 95       	ret

00001aba <LM35_GetTemp>:


u16 LM35_GetTemp(void)
{
	u16 Temp;
	u16 volt = ADC_Get_Voltage(LM35_CHANNEL);
    1aba:	80 e0       	ldi	r24, 0x00	; 0
    1abc:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <ADC_Get_Voltage>
	
	Temp = volt;
	
	return Temp;
}
    1ac0:	08 95       	ret

00001ac2 <T_UserInput>:
	}
}


void T_UserInput(void *param)
{
    1ac2:	cf 93       	push	r28
    1ac4:	df 93       	push	r29
    1ac6:	1f 92       	push	r1
    1ac8:	cd b7       	in	r28, 0x3d	; 61
    1aca:	de b7       	in	r29, 0x3e	; 62
	u8 data = 0;
    1acc:	19 82       	std	Y+1, r1	; 0x01
	u16 recTTemp = 0;
    1ace:	00 e0       	ldi	r16, 0x00	; 0
    1ad0:	10 e0       	ldi	r17, 0x00	; 0
	while(1)
	{
		if (UART_Receive_PeriodicCheck(&data))
    1ad2:	ce 01       	movw	r24, r28
    1ad4:	01 96       	adiw	r24, 0x01	; 1
    1ad6:	0e 94 fd 11 	call	0x23fa	; 0x23fa <UART_Receive_PeriodicCheck>
    1ada:	88 23       	and	r24, r24
    1adc:	09 f4       	brne	.+2      	; 0x1ae0 <T_UserInput+0x1e>
    1ade:	9d c0       	rjmp	.+314    	; 0x1c1a <T_UserInput+0x158>
		{
			switch(TAS.SystemState)
    1ae0:	80 91 ef 05 	lds	r24, 0x05EF	; 0x8005ef <TAS>
    1ae4:	81 30       	cpi	r24, 0x01	; 1
    1ae6:	d1 f1       	breq	.+116    	; 0x1b5c <T_UserInput+0x9a>
    1ae8:	20 f0       	brcs	.+8      	; 0x1af2 <T_UserInput+0x30>
    1aea:	82 30       	cpi	r24, 0x02	; 2
    1aec:	09 f4       	brne	.+2      	; 0x1af0 <T_UserInput+0x2e>
    1aee:	49 c0       	rjmp	.+146    	; 0x1b82 <T_UserInput+0xc0>
    1af0:	94 c0       	rjmp	.+296    	; 0x1c1a <T_UserInput+0x158>
			{
				case MAIN_S:
				     if (data == 'C')
    1af2:	89 81       	ldd	r24, Y+1	; 0x01
    1af4:	83 34       	cpi	r24, 0x43	; 67
    1af6:	81 f4       	brne	.+32     	; 0x1b18 <T_UserInput+0x56>
				     {
						 TAS.SystemState = CONFIG_S;
    1af8:	82 e0       	ldi	r24, 0x02	; 2
    1afa:	80 93 ef 05 	sts	0x05EF, r24	; 0x8005ef <TAS>
						 digitcounter = 0;
    1afe:	10 92 ee 05 	sts	0x05EE, r1	; 0x8005ee <digitcounter>
						 recTTemp = 0;
						 xEventGroupSetBits(egEvents , E_ConfigScreen);
    1b02:	64 e0       	ldi	r22, 0x04	; 4
    1b04:	70 e0       	ldi	r23, 0x00	; 0
    1b06:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <egEvents>
    1b0a:	90 91 e6 05 	lds	r25, 0x05E6	; 0x8005e6 <egEvents+0x1>
    1b0e:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
				case MAIN_S:
				     if (data == 'C')
				     {
						 TAS.SystemState = CONFIG_S;
						 digitcounter = 0;
						 recTTemp = 0;
    1b12:	00 e0       	ldi	r16, 0x00	; 0
    1b14:	10 e0       	ldi	r17, 0x00	; 0
    1b16:	81 c0       	rjmp	.+258    	; 0x1c1a <T_UserInput+0x158>
						 xEventGroupSetBits(egEvents , E_ConfigScreen);
				     }
					 else if (data == 'T')
    1b18:	84 35       	cpi	r24, 0x54	; 84
    1b1a:	09 f0       	breq	.+2      	; 0x1b1e <T_UserInput+0x5c>
    1b1c:	7e c0       	rjmp	.+252    	; 0x1c1a <T_UserInput+0x158>
					 {
						 if (TAS.AlarmStatus == 'E')
    1b1e:	80 91 f2 05 	lds	r24, 0x05F2	; 0x8005f2 <TAS+0x3>
    1b22:	85 34       	cpi	r24, 0x45	; 69
    1b24:	21 f4       	brne	.+8      	; 0x1b2e <T_UserInput+0x6c>
						 {
							 TAS.AlarmStatus = 'D';
    1b26:	84 e4       	ldi	r24, 0x44	; 68
    1b28:	80 93 f2 05 	sts	0x05F2, r24	; 0x8005f2 <TAS+0x3>
    1b2c:	03 c0       	rjmp	.+6      	; 0x1b34 <T_UserInput+0x72>
						 }
						 else
						 {
							 TAS.AlarmStatus = 'E';
    1b2e:	85 e4       	ldi	r24, 0x45	; 69
    1b30:	80 93 f2 05 	sts	0x05F2, r24	; 0x8005f2 <TAS+0x3>
						 }
						 xEventGroupSetBits(egEvents , E_ASUpdated);
    1b34:	60 e4       	ldi	r22, 0x40	; 64
    1b36:	70 e0       	ldi	r23, 0x00	; 0
    1b38:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <egEvents>
    1b3c:	90 91 e6 05 	lds	r25, 0x05E6	; 0x8005e6 <egEvents+0x1>
    1b40:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
						 xSemaphoreGive(bsCheck);
    1b44:	20 e0       	ldi	r18, 0x00	; 0
    1b46:	40 e0       	ldi	r20, 0x00	; 0
    1b48:	50 e0       	ldi	r21, 0x00	; 0
    1b4a:	60 e0       	ldi	r22, 0x00	; 0
    1b4c:	70 e0       	ldi	r23, 0x00	; 0
    1b4e:	80 91 eb 05 	lds	r24, 0x05EB	; 0x8005eb <bsCheck>
    1b52:	90 91 ec 05 	lds	r25, 0x05EC	; 0x8005ec <bsCheck+0x1>
    1b56:	0e 94 af 04 	call	0x95e	; 0x95e <xQueueGenericSend>
    1b5a:	5f c0       	rjmp	.+190    	; 0x1c1a <T_UserInput+0x158>
						 
					 }
					 break;
					 
				case ALARM_S:
				     if (data == 'S')
    1b5c:	89 81       	ldd	r24, Y+1	; 0x01
    1b5e:	83 35       	cpi	r24, 0x53	; 83
    1b60:	09 f0       	breq	.+2      	; 0x1b64 <T_UserInput+0xa2>
    1b62:	5b c0       	rjmp	.+182    	; 0x1c1a <T_UserInput+0x158>
				     {
						 TAS.AlarmStatus = 'D';
    1b64:	84 e4       	ldi	r24, 0x44	; 68
    1b66:	80 93 f2 05 	sts	0x05F2, r24	; 0x8005f2 <TAS+0x3>
						 xSemaphoreGive(bsCheck);
    1b6a:	20 e0       	ldi	r18, 0x00	; 0
    1b6c:	40 e0       	ldi	r20, 0x00	; 0
    1b6e:	50 e0       	ldi	r21, 0x00	; 0
    1b70:	60 e0       	ldi	r22, 0x00	; 0
    1b72:	70 e0       	ldi	r23, 0x00	; 0
    1b74:	80 91 eb 05 	lds	r24, 0x05EB	; 0x8005eb <bsCheck>
    1b78:	90 91 ec 05 	lds	r25, 0x05EC	; 0x8005ec <bsCheck+0x1>
    1b7c:	0e 94 af 04 	call	0x95e	; 0x95e <xQueueGenericSend>
    1b80:	4c c0       	rjmp	.+152    	; 0x1c1a <T_UserInput+0x158>
				     }
					 break;
				case CONFIG_S:
				     if (data == 'O')
    1b82:	89 81       	ldd	r24, Y+1	; 0x01
    1b84:	8f 34       	cpi	r24, 0x4F	; 79
    1b86:	c1 f4       	brne	.+48     	; 0x1bb8 <T_UserInput+0xf6>
				     {
						 TAS.TTemp = recTTemp;
    1b88:	ef ee       	ldi	r30, 0xEF	; 239
    1b8a:	f5 e0       	ldi	r31, 0x05	; 5
    1b8c:	02 83       	std	Z+2, r16	; 0x02
						 TAS.SystemState = MAIN_S;
    1b8e:	10 82       	st	Z, r1
						 xEventGroupSetBits(egEvents , 
    1b90:	62 e6       	ldi	r22, 0x62	; 98
    1b92:	70 e0       	ldi	r23, 0x00	; 0
    1b94:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <egEvents>
    1b98:	90 91 e6 05 	lds	r25, 0x05E6	; 0x8005e6 <egEvents+0x1>
    1b9c:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
						              E_MainScreen|E_TTempUpdated|E_TTempUpdated|E_ASUpdated);
						 xSemaphoreGive(bsCheck);
    1ba0:	20 e0       	ldi	r18, 0x00	; 0
    1ba2:	40 e0       	ldi	r20, 0x00	; 0
    1ba4:	50 e0       	ldi	r21, 0x00	; 0
    1ba6:	60 e0       	ldi	r22, 0x00	; 0
    1ba8:	70 e0       	ldi	r23, 0x00	; 0
    1baa:	80 91 eb 05 	lds	r24, 0x05EB	; 0x8005eb <bsCheck>
    1bae:	90 91 ec 05 	lds	r25, 0x05EC	; 0x8005ec <bsCheck+0x1>
    1bb2:	0e 94 af 04 	call	0x95e	; 0x95e <xQueueGenericSend>
    1bb6:	31 c0       	rjmp	.+98     	; 0x1c1a <T_UserInput+0x158>
				     }
					 else if (data == 'C')
    1bb8:	83 34       	cpi	r24, 0x43	; 67
    1bba:	59 f4       	brne	.+22     	; 0x1bd2 <T_UserInput+0x110>
					 {
						 TAS.SystemState = MAIN_S;
    1bbc:	10 92 ef 05 	sts	0x05EF, r1	; 0x8005ef <TAS>
						 xEventGroupSetBits(egEvents , 
    1bc0:	62 e6       	ldi	r22, 0x62	; 98
    1bc2:	70 e0       	ldi	r23, 0x00	; 0
    1bc4:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <egEvents>
    1bc8:	90 91 e6 05 	lds	r25, 0x05E6	; 0x8005e6 <egEvents+0x1>
    1bcc:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
    1bd0:	24 c0       	rjmp	.+72     	; 0x1c1a <T_UserInput+0x158>
						              E_MainScreen|E_TTempUpdated|E_TTempUpdated|E_ASUpdated);
					 }
					 else if (data>='0'&&data<='9'&&digitcounter<3)
    1bd2:	90 ed       	ldi	r25, 0xD0	; 208
    1bd4:	98 0f       	add	r25, r24
    1bd6:	9a 30       	cpi	r25, 0x0A	; 10
    1bd8:	00 f5       	brcc	.+64     	; 0x1c1a <T_UserInput+0x158>
    1bda:	90 91 ee 05 	lds	r25, 0x05EE	; 0x8005ee <digitcounter>
    1bde:	93 30       	cpi	r25, 0x03	; 3
    1be0:	e0 f4       	brcc	.+56     	; 0x1c1a <T_UserInput+0x158>
					 {
						 digitcounter++;
    1be2:	9f 5f       	subi	r25, 0xFF	; 255
    1be4:	90 93 ee 05 	sts	0x05EE, r25	; 0x8005ee <digitcounter>
						 recTTemp = recTTemp*10 + (data-'0');
    1be8:	98 01       	movw	r18, r16
    1bea:	22 0f       	add	r18, r18
    1bec:	33 1f       	adc	r19, r19
    1bee:	00 0f       	add	r16, r16
    1bf0:	11 1f       	adc	r17, r17
    1bf2:	00 0f       	add	r16, r16
    1bf4:	11 1f       	adc	r17, r17
    1bf6:	00 0f       	add	r16, r16
    1bf8:	11 1f       	adc	r17, r17
    1bfa:	02 0f       	add	r16, r18
    1bfc:	13 1f       	adc	r17, r19
    1bfe:	08 0f       	add	r16, r24
    1c00:	11 1d       	adc	r17, r1
    1c02:	00 53       	subi	r16, 0x30	; 48
    1c04:	11 09       	sbc	r17, r1
						 digitvalue = data;
    1c06:	80 93 ed 05 	sts	0x05ED, r24	; 0x8005ed <digitvalue>
						 xEventGroupSetBits(egEvents , E_TConfigUpdated); 
    1c0a:	60 e8       	ldi	r22, 0x80	; 128
    1c0c:	70 e0       	ldi	r23, 0x00	; 0
    1c0e:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <egEvents>
    1c12:	90 91 e6 05 	lds	r25, 0x05E6	; 0x8005e6 <egEvents+0x1>
    1c16:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
					 }
					 break;
			}
		}
		vTaskDelay(10);
    1c1a:	8a e0       	ldi	r24, 0x0A	; 10
    1c1c:	90 e0       	ldi	r25, 0x00	; 0
    1c1e:	0e 94 04 09 	call	0x1208	; 0x1208 <vTaskDelay>
	}
    1c22:	57 cf       	rjmp	.-338    	; 0x1ad2 <T_UserInput+0x10>

00001c24 <T_GetTemp>:
{	
	u16 NewTemp = 0;
	
	while(1)
	{                                                              
		NewTemp = LM35_GetTemp();
    1c24:	0e 94 5d 0d 	call	0x1aba	; 0x1aba <LM35_GetTemp>
		
		if (NewTemp != TAS.CTemp)
    1c28:	20 91 f0 05 	lds	r18, 0x05F0	; 0x8005f0 <TAS+0x1>
    1c2c:	30 e0       	ldi	r19, 0x00	; 0
    1c2e:	82 17       	cp	r24, r18
    1c30:	93 07       	cpc	r25, r19
    1c32:	21 f0       	breq	.+8      	; 0x1c3c <T_GetTemp+0x18>
		{
			TAS.CTemp = NewTemp;
    1c34:	ef ee       	ldi	r30, 0xEF	; 239
    1c36:	f5 e0       	ldi	r31, 0x05	; 5
    1c38:	81 83       	std	Z+1, r24	; 0x01
			if (TAS.SystemState = MAIN_S)
    1c3a:	10 82       	st	Z, r1
				xSemaphoreGive(bsCheck);
				xEventGroupSetBits(egEvents , E_CTempUpdated);
			}
		}
		
		vTaskDelay(100);
    1c3c:	84 e6       	ldi	r24, 0x64	; 100
    1c3e:	90 e0       	ldi	r25, 0x00	; 0
    1c40:	0e 94 04 09 	call	0x1208	; 0x1208 <vTaskDelay>
	}
    1c44:	ef cf       	rjmp	.-34     	; 0x1c24 <T_GetTemp>

00001c46 <T_CheckTemp>:
void T_CheckTemp(void *param)
{
	while(1)
	{
		
		if (xSemaphoreTake(bsCheck , portMAX_DELAY))
    1c46:	20 e0       	ldi	r18, 0x00	; 0
    1c48:	4f ef       	ldi	r20, 0xFF	; 255
    1c4a:	5f ef       	ldi	r21, 0xFF	; 255
    1c4c:	60 e0       	ldi	r22, 0x00	; 0
    1c4e:	70 e0       	ldi	r23, 0x00	; 0
    1c50:	80 91 eb 05 	lds	r24, 0x05EB	; 0x8005eb <bsCheck>
    1c54:	90 91 ec 05 	lds	r25, 0x05EC	; 0x8005ec <bsCheck+0x1>
    1c58:	0e 94 41 05 	call	0xa82	; 0xa82 <xQueueGenericReceive>
    1c5c:	88 23       	and	r24, r24
    1c5e:	99 f3       	breq	.-26     	; 0x1c46 <T_CheckTemp>
		{
			if (TAS.SystemState == MAIN_S && TAS.CTemp>=TAS.TTemp && TAS.AlarmStatus == 'E')
    1c60:	80 91 ef 05 	lds	r24, 0x05EF	; 0x8005ef <TAS>
    1c64:	81 11       	cpse	r24, r1
    1c66:	1e c0       	rjmp	.+60     	; 0x1ca4 <T_CheckTemp+0x5e>
    1c68:	ef ee       	ldi	r30, 0xEF	; 239
    1c6a:	f5 e0       	ldi	r31, 0x05	; 5
    1c6c:	21 81       	ldd	r18, Z+1	; 0x01
    1c6e:	92 81       	ldd	r25, Z+2	; 0x02
    1c70:	29 17       	cp	r18, r25
    1c72:	c0 f0       	brcs	.+48     	; 0x1ca4 <T_CheckTemp+0x5e>
    1c74:	90 91 f2 05 	lds	r25, 0x05F2	; 0x8005f2 <TAS+0x3>
    1c78:	95 34       	cpi	r25, 0x45	; 69
    1c7a:	a1 f4       	brne	.+40     	; 0x1ca4 <T_CheckTemp+0x5e>
			{
				TAS.SystemState = ALARM_S;
    1c7c:	81 e0       	ldi	r24, 0x01	; 1
    1c7e:	80 93 ef 05 	sts	0x05EF, r24	; 0x8005ef <TAS>
				xEventGroupSetBits(egEvents , E_Alarm); //trigger the T_Alarm task
    1c82:	61 e0       	ldi	r22, 0x01	; 1
    1c84:	70 e0       	ldi	r23, 0x00	; 0
    1c86:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <egEvents>
    1c8a:	90 91 e6 05 	lds	r25, 0x05E6	; 0x8005e6 <egEvents+0x1>
    1c8e:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
				xEventGroupSetBits(egEvents , E_AlarmScreen); //trigger the T_Display task
    1c92:	68 e0       	ldi	r22, 0x08	; 8
    1c94:	70 e0       	ldi	r23, 0x00	; 0
    1c96:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <egEvents>
    1c9a:	90 91 e6 05 	lds	r25, 0x05E6	; 0x8005e6 <egEvents+0x1>
    1c9e:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
    1ca2:	d1 cf       	rjmp	.-94     	; 0x1c46 <T_CheckTemp>
			}
			else if (TAS.SystemState == ALARM_S && (TAS.CTemp<TAS.TTemp||TAS.AlarmStatus == 'D'))
    1ca4:	81 30       	cpi	r24, 0x01	; 1
    1ca6:	79 f6       	brne	.-98     	; 0x1c46 <T_CheckTemp>
    1ca8:	ef ee       	ldi	r30, 0xEF	; 239
    1caa:	f5 e0       	ldi	r31, 0x05	; 5
    1cac:	91 81       	ldd	r25, Z+1	; 0x01
    1cae:	82 81       	ldd	r24, Z+2	; 0x02
    1cb0:	98 17       	cp	r25, r24
    1cb2:	20 f0       	brcs	.+8      	; 0x1cbc <T_CheckTemp+0x76>
    1cb4:	80 91 f2 05 	lds	r24, 0x05F2	; 0x8005f2 <TAS+0x3>
    1cb8:	84 34       	cpi	r24, 0x44	; 68
    1cba:	29 f6       	brne	.-118    	; 0x1c46 <T_CheckTemp>
			{
				TAS.SystemState = MAIN_S;
    1cbc:	10 92 ef 05 	sts	0x05EF, r1	; 0x8005ef <TAS>
				xEventGroupClearBits(egEvents , E_Alarm);
    1cc0:	61 e0       	ldi	r22, 0x01	; 1
    1cc2:	70 e0       	ldi	r23, 0x00	; 0
    1cc4:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <egEvents>
    1cc8:	90 91 e6 05 	lds	r25, 0x05E6	; 0x8005e6 <egEvents+0x1>
    1ccc:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <xEventGroupClearBits>
				
				/* For T_Display task */
				xEventGroupSetBits(egEvents , 
    1cd0:	62 e6       	ldi	r22, 0x62	; 98
    1cd2:	70 e0       	ldi	r23, 0x00	; 0
    1cd4:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <egEvents>
    1cd8:	90 91 e6 05 	lds	r25, 0x05E6	; 0x8005e6 <egEvents+0x1>
    1cdc:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
    1ce0:	b2 cf       	rjmp	.-156    	; 0x1c46 <T_CheckTemp>

00001ce2 <T_Display>:
void T_Display(void *param)
{
	
	while(1)
	{
		ebBits = xEventGroupWaitBits(egEvents , E_DispEvents , 1 , 0 , portMAX_DELAY);
    1ce2:	0f ef       	ldi	r16, 0xFF	; 255
    1ce4:	1f ef       	ldi	r17, 0xFF	; 255
    1ce6:	20 e0       	ldi	r18, 0x00	; 0
    1ce8:	41 e0       	ldi	r20, 0x01	; 1
    1cea:	6f e7       	ldi	r22, 0x7F	; 127
    1cec:	70 e0       	ldi	r23, 0x00	; 0
    1cee:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <egEvents>
    1cf2:	90 91 e6 05 	lds	r25, 0x05E6	; 0x8005e6 <egEvents+0x1>
    1cf6:	0e 94 6f 00 	call	0xde	; 0xde <xEventGroupWaitBits>
    1cfa:	80 93 e3 05 	sts	0x05E3, r24	; 0x8005e3 <ebBits>
    1cfe:	90 93 e4 05 	sts	0x05E4, r25	; 0x8005e4 <ebBits+0x1>
		if (ebBits & E_MainScreen)
    1d02:	81 ff       	sbrs	r24, 1
    1d04:	0c c0       	rjmp	.+24     	; 0x1d1e <T_Display+0x3c>
		{
			LCD_GoToWriteString(0 , 0 , DISP_MAIN_L0);
    1d06:	47 e6       	ldi	r20, 0x67	; 103
    1d08:	50 e0       	ldi	r21, 0x00	; 0
    1d0a:	60 e0       	ldi	r22, 0x00	; 0
    1d0c:	80 e0       	ldi	r24, 0x00	; 0
    1d0e:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <LCD_GoToWriteString>
			LCD_GoToWriteString(1 , 0 , DISP_MAIN_L1);
    1d12:	4c e7       	ldi	r20, 0x7C	; 124
    1d14:	50 e0       	ldi	r21, 0x00	; 0
    1d16:	60 e0       	ldi	r22, 0x00	; 0
    1d18:	81 e0       	ldi	r24, 0x01	; 1
    1d1a:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <LCD_GoToWriteString>
		}
		if (ebBits & E_AlarmScreen)
    1d1e:	80 91 e3 05 	lds	r24, 0x05E3	; 0x8005e3 <ebBits>
    1d22:	83 ff       	sbrs	r24, 3
    1d24:	0c c0       	rjmp	.+24     	; 0x1d3e <T_Display+0x5c>
		{
			LCD_GoToWriteString(0 , 0 , DISP_ALARM_L0);
    1d26:	41 e9       	ldi	r20, 0x91	; 145
    1d28:	50 e0       	ldi	r21, 0x00	; 0
    1d2a:	60 e0       	ldi	r22, 0x00	; 0
    1d2c:	80 e0       	ldi	r24, 0x00	; 0
    1d2e:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <LCD_GoToWriteString>
			LCD_GoToWriteString(1 , 0 , DISP_ALARM_L1);
    1d32:	46 ea       	ldi	r20, 0xA6	; 166
    1d34:	50 e0       	ldi	r21, 0x00	; 0
    1d36:	60 e0       	ldi	r22, 0x00	; 0
    1d38:	81 e0       	ldi	r24, 0x01	; 1
    1d3a:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <LCD_GoToWriteString>
		}
		if (ebBits & E_ConfigScreen)
    1d3e:	80 91 e3 05 	lds	r24, 0x05E3	; 0x8005e3 <ebBits>
    1d42:	82 ff       	sbrs	r24, 2
    1d44:	0c c0       	rjmp	.+24     	; 0x1d5e <T_Display+0x7c>
		{
			LCD_GoToWriteString(0 , 0 , DISP_CONFIG_L0);
    1d46:	4b eb       	ldi	r20, 0xBB	; 187
    1d48:	50 e0       	ldi	r21, 0x00	; 0
    1d4a:	60 e0       	ldi	r22, 0x00	; 0
    1d4c:	80 e0       	ldi	r24, 0x00	; 0
    1d4e:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <LCD_GoToWriteString>
			LCD_GoToWriteString(1 , 0 , DISP_CONFIG_L1);
    1d52:	40 ed       	ldi	r20, 0xD0	; 208
    1d54:	50 e0       	ldi	r21, 0x00	; 0
    1d56:	60 e0       	ldi	r22, 0x00	; 0
    1d58:	81 e0       	ldi	r24, 0x01	; 1
    1d5a:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <LCD_GoToWriteString>
		}
		if (ebBits & E_CTempUpdated)
    1d5e:	80 91 e3 05 	lds	r24, 0x05E3	; 0x8005e3 <ebBits>
    1d62:	84 ff       	sbrs	r24, 4
    1d64:	0f c0       	rjmp	.+30     	; 0x1d84 <T_Display+0xa2>
		{
			LCD_GoTo(DISP_CTEMP_ROW , DISP_CTEMP_COL);
    1d66:	63 e0       	ldi	r22, 0x03	; 3
    1d68:	80 e0       	ldi	r24, 0x00	; 0
    1d6a:	0e 94 40 0d 	call	0x1a80	; 0x1a80 <LCD_GoTo>
			LCD_WriteNumber(TAS.CTemp);
    1d6e:	20 91 f0 05 	lds	r18, 0x05F0	; 0x8005f0 <TAS+0x1>
    1d72:	30 e0       	ldi	r19, 0x00	; 0
    1d74:	40 e0       	ldi	r20, 0x00	; 0
    1d76:	50 e0       	ldi	r21, 0x00	; 0
    1d78:	60 e0       	ldi	r22, 0x00	; 0
    1d7a:	70 e0       	ldi	r23, 0x00	; 0
    1d7c:	80 e0       	ldi	r24, 0x00	; 0
    1d7e:	90 e0       	ldi	r25, 0x00	; 0
    1d80:	0e 94 92 0c 	call	0x1924	; 0x1924 <LCD_WriteNumber>
		}
		if (ebBits & E_TTempUpdated)
    1d84:	80 91 e3 05 	lds	r24, 0x05E3	; 0x8005e3 <ebBits>
    1d88:	85 ff       	sbrs	r24, 5
    1d8a:	0f c0       	rjmp	.+30     	; 0x1daa <T_Display+0xc8>
		{
			LCD_GoTo(DISP_TTEMP_ROW , DISP_TTEMP_COL);
    1d8c:	69 e0       	ldi	r22, 0x09	; 9
    1d8e:	80 e0       	ldi	r24, 0x00	; 0
    1d90:	0e 94 40 0d 	call	0x1a80	; 0x1a80 <LCD_GoTo>
			LCD_WriteNumber(TAS.TTemp);
    1d94:	20 91 f1 05 	lds	r18, 0x05F1	; 0x8005f1 <TAS+0x2>
    1d98:	30 e0       	ldi	r19, 0x00	; 0
    1d9a:	40 e0       	ldi	r20, 0x00	; 0
    1d9c:	50 e0       	ldi	r21, 0x00	; 0
    1d9e:	60 e0       	ldi	r22, 0x00	; 0
    1da0:	70 e0       	ldi	r23, 0x00	; 0
    1da2:	80 e0       	ldi	r24, 0x00	; 0
    1da4:	90 e0       	ldi	r25, 0x00	; 0
    1da6:	0e 94 92 0c 	call	0x1924	; 0x1924 <LCD_WriteNumber>
		}
		if (ebBits & E_TConfigUpdated)
    1daa:	80 91 e3 05 	lds	r24, 0x05E3	; 0x8005e3 <ebBits>
    1dae:	87 ff       	sbrs	r24, 7
    1db0:	0a c0       	rjmp	.+20     	; 0x1dc6 <T_Display+0xe4>
		{
			LCD_GoTo(DISP_TTEMP_ROW , DISP_TTEMP_COL+digitcounter);
    1db2:	60 91 ee 05 	lds	r22, 0x05EE	; 0x8005ee <digitcounter>
    1db6:	67 5f       	subi	r22, 0xF7	; 247
    1db8:	80 e0       	ldi	r24, 0x00	; 0
    1dba:	0e 94 40 0d 	call	0x1a80	; 0x1a80 <LCD_GoTo>
			LCD_WriteChar(digitvalue);
    1dbe:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <digitvalue>
    1dc2:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <LCD_WriteChar>
		}
		if (ebBits & E_ASUpdated)
    1dc6:	80 91 e3 05 	lds	r24, 0x05E3	; 0x8005e3 <ebBits>
    1dca:	86 ff       	sbrs	r24, 6
    1dcc:	8a cf       	rjmp	.-236    	; 0x1ce2 <T_Display>
		{
			LCD_GoTo(DISP_AS_ROW , DISP_AS_COL);
    1dce:	60 e1       	ldi	r22, 0x10	; 16
    1dd0:	80 e0       	ldi	r24, 0x00	; 0
    1dd2:	0e 94 40 0d 	call	0x1a80	; 0x1a80 <LCD_GoTo>
			LCD_WriteChar(TAS.AlarmStatus);
    1dd6:	80 91 f2 05 	lds	r24, 0x05F2	; 0x8005f2 <TAS+0x3>
    1dda:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <LCD_WriteChar>
    1dde:	81 cf       	rjmp	.-254    	; 0x1ce2 <T_Display>

00001de0 <T_SetAlaram>:
void T_SetAlaram(void *param)
{
	
	while(1)
	{
		ebBits = xEventGroupWaitBits(egEvents , E_Alarm , 0 , 0 , portMAX_DELAY);
    1de0:	0f ef       	ldi	r16, 0xFF	; 255
    1de2:	1f ef       	ldi	r17, 0xFF	; 255
    1de4:	20 e0       	ldi	r18, 0x00	; 0
    1de6:	40 e0       	ldi	r20, 0x00	; 0
    1de8:	61 e0       	ldi	r22, 0x01	; 1
    1dea:	70 e0       	ldi	r23, 0x00	; 0
    1dec:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <egEvents>
    1df0:	90 91 e6 05 	lds	r25, 0x05E6	; 0x8005e6 <egEvents+0x1>
    1df4:	0e 94 6f 00 	call	0xde	; 0xde <xEventGroupWaitBits>
    1df8:	80 93 e3 05 	sts	0x05E3, r24	; 0x8005e3 <ebBits>
    1dfc:	90 93 e4 05 	sts	0x05E4, r25	; 0x8005e4 <ebBits+0x1>
		if (ebBits & (E_Alarm))
    1e00:	80 ff       	sbrs	r24, 0
    1e02:	ee cf       	rjmp	.-36     	; 0x1de0 <T_SetAlaram>
		{
			DIO_TogglePin(PINA_6);
    1e04:	86 e0       	ldi	r24, 0x06	; 6
    1e06:	0e 94 54 11 	call	0x22a8	; 0x22a8 <DIO_TogglePin>
			vTaskDelay(500);
    1e0a:	84 ef       	ldi	r24, 0xF4	; 244
    1e0c:	91 e0       	ldi	r25, 0x01	; 1
    1e0e:	0e 94 04 09 	call	0x1208	; 0x1208 <vTaskDelay>
    1e12:	e6 cf       	rjmp	.-52     	; 0x1de0 <T_SetAlaram>

00001e14 <System_Init>:
}

void System_Init()
{
	/* init system parameters */
	TAS.SystemState = MAIN_S;
    1e14:	ef ee       	ldi	r30, 0xEF	; 239
    1e16:	f5 e0       	ldi	r31, 0x05	; 5
    1e18:	10 82       	st	Z, r1
	TAS.AlarmStatus = 'E';
    1e1a:	85 e4       	ldi	r24, 0x45	; 69
    1e1c:	83 83       	std	Z+3, r24	; 0x03
	TAS.CTemp = 0;
    1e1e:	11 82       	std	Z+1, r1	; 0x01
	TAS.TTemp = 30;
    1e20:	8e e1       	ldi	r24, 0x1E	; 30
    1e22:	82 83       	std	Z+2, r24	; 0x02
	
	DIO_Init();
    1e24:	0e 94 bf 10 	call	0x217e	; 0x217e <DIO_Init>
	UART_Init();
    1e28:	0e 94 95 11 	call	0x232a	; 0x232a <UART_Init>
	LCD_Init();
    1e2c:	0e 94 48 0c 	call	0x1890	; 0x1890 <LCD_Init>
	ADC_Init(ADC_VCC , divfact64);
    1e30:	66 e0       	ldi	r22, 0x06	; 6
    1e32:	81 e0       	ldi	r24, 0x01	; 1
    1e34:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <ADC_Init>
	UART_SendString("System start \r\n");
    1e38:	85 ee       	ldi	r24, 0xE5	; 229
    1e3a:	90 e0       	ldi	r25, 0x00	; 0
    1e3c:	0e 94 06 12 	call	0x240c	; 0x240c <UART_SendString>
    1e40:	08 95       	ret

00001e42 <main>:
TAS_t     TAS; 
u8 digitcounter;
u8 digitvalue;
int main(void)
{
	System_Init();
    1e42:	0e 94 0a 0f 	call	0x1e14	; 0x1e14 <System_Init>
	
	/* create tasks */
	xTaskCreate(&T_Display    , NULL , 150 , NULL , 1 , NULL);
    1e46:	a1 2c       	mov	r10, r1
    1e48:	b1 2c       	mov	r11, r1
    1e4a:	c1 2c       	mov	r12, r1
    1e4c:	d1 2c       	mov	r13, r1
    1e4e:	e1 2c       	mov	r14, r1
    1e50:	f1 2c       	mov	r15, r1
    1e52:	01 e0       	ldi	r16, 0x01	; 1
    1e54:	20 e0       	ldi	r18, 0x00	; 0
    1e56:	30 e0       	ldi	r19, 0x00	; 0
    1e58:	46 e9       	ldi	r20, 0x96	; 150
    1e5a:	50 e0       	ldi	r21, 0x00	; 0
    1e5c:	60 e0       	ldi	r22, 0x00	; 0
    1e5e:	70 e0       	ldi	r23, 0x00	; 0
    1e60:	81 e7       	ldi	r24, 0x71	; 113
    1e62:	9e e0       	ldi	r25, 0x0E	; 14
    1e64:	0e 94 ee 06 	call	0xddc	; 0xddc <xTaskGenericCreate>
	xTaskCreate(&T_GetTemp    , NULL , 150 , NULL , 2 , NULL);
    1e68:	02 e0       	ldi	r16, 0x02	; 2
    1e6a:	20 e0       	ldi	r18, 0x00	; 0
    1e6c:	30 e0       	ldi	r19, 0x00	; 0
    1e6e:	46 e9       	ldi	r20, 0x96	; 150
    1e70:	50 e0       	ldi	r21, 0x00	; 0
    1e72:	60 e0       	ldi	r22, 0x00	; 0
    1e74:	70 e0       	ldi	r23, 0x00	; 0
    1e76:	82 e1       	ldi	r24, 0x12	; 18
    1e78:	9e e0       	ldi	r25, 0x0E	; 14
    1e7a:	0e 94 ee 06 	call	0xddc	; 0xddc <xTaskGenericCreate>
	xTaskCreate(&T_UserInput  , NULL , 150 , NULL , 3 , NULL);
    1e7e:	03 e0       	ldi	r16, 0x03	; 3
    1e80:	20 e0       	ldi	r18, 0x00	; 0
    1e82:	30 e0       	ldi	r19, 0x00	; 0
    1e84:	46 e9       	ldi	r20, 0x96	; 150
    1e86:	50 e0       	ldi	r21, 0x00	; 0
    1e88:	60 e0       	ldi	r22, 0x00	; 0
    1e8a:	70 e0       	ldi	r23, 0x00	; 0
    1e8c:	81 e6       	ldi	r24, 0x61	; 97
    1e8e:	9d e0       	ldi	r25, 0x0D	; 13
    1e90:	0e 94 ee 06 	call	0xddc	; 0xddc <xTaskGenericCreate>
	xTaskCreate(&T_CheckTemp  , NULL , 150 , NULL , 4 , NULL);
    1e94:	04 e0       	ldi	r16, 0x04	; 4
    1e96:	20 e0       	ldi	r18, 0x00	; 0
    1e98:	30 e0       	ldi	r19, 0x00	; 0
    1e9a:	46 e9       	ldi	r20, 0x96	; 150
    1e9c:	50 e0       	ldi	r21, 0x00	; 0
    1e9e:	60 e0       	ldi	r22, 0x00	; 0
    1ea0:	70 e0       	ldi	r23, 0x00	; 0
    1ea2:	83 e2       	ldi	r24, 0x23	; 35
    1ea4:	9e e0       	ldi	r25, 0x0E	; 14
    1ea6:	0e 94 ee 06 	call	0xddc	; 0xddc <xTaskGenericCreate>
	xTaskCreate(&T_SetAlaram  , NULL , 100 , NULL , 5 , NULL);
    1eaa:	05 e0       	ldi	r16, 0x05	; 5
    1eac:	20 e0       	ldi	r18, 0x00	; 0
    1eae:	30 e0       	ldi	r19, 0x00	; 0
    1eb0:	44 e6       	ldi	r20, 0x64	; 100
    1eb2:	50 e0       	ldi	r21, 0x00	; 0
    1eb4:	60 e0       	ldi	r22, 0x00	; 0
    1eb6:	70 e0       	ldi	r23, 0x00	; 0
    1eb8:	80 ef       	ldi	r24, 0xF0	; 240
    1eba:	9e e0       	ldi	r25, 0x0E	; 14
    1ebc:	0e 94 ee 06 	call	0xddc	; 0xddc <xTaskGenericCreate>
	
	egEvents = xEventGroupCreate();
    1ec0:	0e 94 5c 00 	call	0xb8	; 0xb8 <xEventGroupCreate>
    1ec4:	90 93 e6 05 	sts	0x05E6, r25	; 0x8005e6 <egEvents+0x1>
    1ec8:	80 93 e5 05 	sts	0x05E5, r24	; 0x8005e5 <egEvents>
	bsCheck = xSemaphoreCreateBinary();
    1ecc:	43 e0       	ldi	r20, 0x03	; 3
    1ece:	60 e0       	ldi	r22, 0x00	; 0
    1ed0:	81 e0       	ldi	r24, 0x01	; 1
    1ed2:	0e 94 81 04 	call	0x902	; 0x902 <xQueueGenericCreate>
    1ed6:	90 93 ec 05 	sts	0x05EC, r25	; 0x8005ec <bsCheck+0x1>
    1eda:	80 93 eb 05 	sts	0x05EB, r24	; 0x8005eb <bsCheck>

	/* start os */
	vTaskStartScheduler();
    1ede:	0e 94 a6 07 	call	0xf4c	; 0xf4c <vTaskStartScheduler>
    1ee2:	ff cf       	rjmp	.-2      	; 0x1ee2 <main+0xa0>

00001ee4 <ADC_Init>:
	u16 adc_val = ADC_Read(channel);
	
	volt = ((u32)adc_val*5000) / 1024;
	
	return volt;
}
    1ee4:	81 30       	cpi	r24, 0x01	; 1
    1ee6:	59 f0       	breq	.+22     	; 0x1efe <ADC_Init+0x1a>
    1ee8:	18 f0       	brcs	.+6      	; 0x1ef0 <ADC_Init+0xc>
    1eea:	82 30       	cpi	r24, 0x02	; 2
    1eec:	79 f0       	breq	.+30     	; 0x1f0c <ADC_Init+0x28>
    1eee:	14 c0       	rjmp	.+40     	; 0x1f18 <ADC_Init+0x34>
    1ef0:	87 b1       	in	r24, 0x07	; 7
    1ef2:	8f 7b       	andi	r24, 0xBF	; 191
    1ef4:	87 b9       	out	0x07, r24	; 7
    1ef6:	87 b1       	in	r24, 0x07	; 7
    1ef8:	8f 77       	andi	r24, 0x7F	; 127
    1efa:	87 b9       	out	0x07, r24	; 7
    1efc:	0d c0       	rjmp	.+26     	; 0x1f18 <ADC_Init+0x34>
    1efe:	87 b1       	in	r24, 0x07	; 7
    1f00:	80 64       	ori	r24, 0x40	; 64
    1f02:	87 b9       	out	0x07, r24	; 7
    1f04:	87 b1       	in	r24, 0x07	; 7
    1f06:	8f 77       	andi	r24, 0x7F	; 127
    1f08:	87 b9       	out	0x07, r24	; 7
    1f0a:	06 c0       	rjmp	.+12     	; 0x1f18 <ADC_Init+0x34>
    1f0c:	87 b1       	in	r24, 0x07	; 7
    1f0e:	80 64       	ori	r24, 0x40	; 64
    1f10:	87 b9       	out	0x07, r24	; 7
    1f12:	87 b1       	in	r24, 0x07	; 7
    1f14:	80 68       	ori	r24, 0x80	; 128
    1f16:	87 b9       	out	0x07, r24	; 7
    1f18:	86 b1       	in	r24, 0x06	; 6
    1f1a:	88 7f       	andi	r24, 0xF8	; 248
    1f1c:	86 b9       	out	0x06, r24	; 6
    1f1e:	86 b1       	in	r24, 0x06	; 6
    1f20:	68 2b       	or	r22, r24
    1f22:	66 b9       	out	0x06, r22	; 6
    1f24:	87 b1       	in	r24, 0x07	; 7
    1f26:	8f 7d       	andi	r24, 0xDF	; 223
    1f28:	87 b9       	out	0x07, r24	; 7
    1f2a:	86 b1       	in	r24, 0x06	; 6
    1f2c:	80 68       	ori	r24, 0x80	; 128
    1f2e:	86 b9       	out	0x06, r24	; 6
    1f30:	08 95       	ret

00001f32 <ADC_Read>:
    1f32:	97 b1       	in	r25, 0x07	; 7
    1f34:	90 7e       	andi	r25, 0xE0	; 224
    1f36:	89 2b       	or	r24, r25
    1f38:	87 b9       	out	0x07, r24	; 7
    1f3a:	86 b1       	in	r24, 0x06	; 6
    1f3c:	80 64       	ori	r24, 0x40	; 64
    1f3e:	86 b9       	out	0x06, r24	; 6
    1f40:	36 99       	sbic	0x06, 6	; 6
    1f42:	fe cf       	rjmp	.-4      	; 0x1f40 <ADC_Read+0xe>
    1f44:	84 b1       	in	r24, 0x04	; 4
    1f46:	95 b1       	in	r25, 0x05	; 5
    1f48:	08 95       	ret

00001f4a <ADC_Get_Voltage>:

u16 ADC_Get_Voltage(ADC_Channel_type channel)
{
	u16 volt;
	u16 adc_val = ADC_Read(channel);
    1f4a:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <ADC_Read>
	
	volt = ((u32)adc_val*5) / 1024;
    1f4e:	ac 01       	movw	r20, r24
    1f50:	60 e0       	ldi	r22, 0x00	; 0
    1f52:	70 e0       	ldi	r23, 0x00	; 0
    1f54:	db 01       	movw	r26, r22
    1f56:	ca 01       	movw	r24, r20
    1f58:	88 0f       	add	r24, r24
    1f5a:	99 1f       	adc	r25, r25
    1f5c:	aa 1f       	adc	r26, r26
    1f5e:	bb 1f       	adc	r27, r27
    1f60:	88 0f       	add	r24, r24
    1f62:	99 1f       	adc	r25, r25
    1f64:	aa 1f       	adc	r26, r26
    1f66:	bb 1f       	adc	r27, r27
    1f68:	84 0f       	add	r24, r20
    1f6a:	95 1f       	adc	r25, r21
    1f6c:	a6 1f       	adc	r26, r22
    1f6e:	b7 1f       	adc	r27, r23
    1f70:	07 2e       	mov	r0, r23
    1f72:	7a e0       	ldi	r23, 0x0A	; 10
    1f74:	b6 95       	lsr	r27
    1f76:	a7 95       	ror	r26
    1f78:	97 95       	ror	r25
    1f7a:	87 95       	ror	r24
    1f7c:	7a 95       	dec	r23
    1f7e:	d1 f7       	brne	.-12     	; 0x1f74 <ADC_Get_Voltage+0x2a>
    1f80:	70 2d       	mov	r23, r0
	
	return volt;
}
    1f82:	08 95       	ret

00001f84 <DIO_InitPin>:
		case PD:
		volt = READ_BIT(PIND_REG,pin_num);
		break;
	}
	return volt;
}
    1f84:	98 2f       	mov	r25, r24
    1f86:	96 95       	lsr	r25
    1f88:	96 95       	lsr	r25
    1f8a:	96 95       	lsr	r25
    1f8c:	87 70       	andi	r24, 0x07	; 7
    1f8e:	61 30       	cpi	r22, 0x01	; 1
    1f90:	09 f4       	brne	.+2      	; 0x1f94 <DIO_InitPin+0x10>
    1f92:	55 c0       	rjmp	.+170    	; 0x203e <DIO_InitPin+0xba>
    1f94:	20 f0       	brcs	.+8      	; 0x1f9e <DIO_InitPin+0x1a>
    1f96:	62 30       	cpi	r22, 0x02	; 2
    1f98:	09 f4       	brne	.+2      	; 0x1f9c <DIO_InitPin+0x18>
    1f9a:	a1 c0       	rjmp	.+322    	; 0x20de <DIO_InitPin+0x15a>
    1f9c:	08 95       	ret
    1f9e:	91 30       	cpi	r25, 0x01	; 1
    1fa0:	c1 f0       	breq	.+48     	; 0x1fd2 <DIO_InitPin+0x4e>
    1fa2:	28 f0       	brcs	.+10     	; 0x1fae <DIO_InitPin+0x2a>
    1fa4:	92 30       	cpi	r25, 0x02	; 2
    1fa6:	39 f1       	breq	.+78     	; 0x1ff6 <DIO_InitPin+0x72>
    1fa8:	93 30       	cpi	r25, 0x03	; 3
    1faa:	b9 f1       	breq	.+110    	; 0x201a <DIO_InitPin+0x96>
    1fac:	08 95       	ret
    1fae:	4a b3       	in	r20, 0x1a	; 26
    1fb0:	21 e0       	ldi	r18, 0x01	; 1
    1fb2:	30 e0       	ldi	r19, 0x00	; 0
    1fb4:	b9 01       	movw	r22, r18
    1fb6:	02 c0       	rjmp	.+4      	; 0x1fbc <DIO_InitPin+0x38>
    1fb8:	66 0f       	add	r22, r22
    1fba:	77 1f       	adc	r23, r23
    1fbc:	8a 95       	dec	r24
    1fbe:	e2 f7       	brpl	.-8      	; 0x1fb8 <DIO_InitPin+0x34>
    1fc0:	cb 01       	movw	r24, r22
    1fc2:	94 2f       	mov	r25, r20
    1fc4:	98 2b       	or	r25, r24
    1fc6:	9a bb       	out	0x1a, r25	; 26
    1fc8:	9b b3       	in	r25, 0x1b	; 27
    1fca:	80 95       	com	r24
    1fcc:	89 23       	and	r24, r25
    1fce:	8b bb       	out	0x1b, r24	; 27
    1fd0:	08 95       	ret
    1fd2:	47 b3       	in	r20, 0x17	; 23
    1fd4:	21 e0       	ldi	r18, 0x01	; 1
    1fd6:	30 e0       	ldi	r19, 0x00	; 0
    1fd8:	b9 01       	movw	r22, r18
    1fda:	02 c0       	rjmp	.+4      	; 0x1fe0 <DIO_InitPin+0x5c>
    1fdc:	66 0f       	add	r22, r22
    1fde:	77 1f       	adc	r23, r23
    1fe0:	8a 95       	dec	r24
    1fe2:	e2 f7       	brpl	.-8      	; 0x1fdc <DIO_InitPin+0x58>
    1fe4:	cb 01       	movw	r24, r22
    1fe6:	94 2f       	mov	r25, r20
    1fe8:	98 2b       	or	r25, r24
    1fea:	97 bb       	out	0x17, r25	; 23
    1fec:	98 b3       	in	r25, 0x18	; 24
    1fee:	80 95       	com	r24
    1ff0:	89 23       	and	r24, r25
    1ff2:	88 bb       	out	0x18, r24	; 24
    1ff4:	08 95       	ret
    1ff6:	44 b3       	in	r20, 0x14	; 20
    1ff8:	21 e0       	ldi	r18, 0x01	; 1
    1ffa:	30 e0       	ldi	r19, 0x00	; 0
    1ffc:	b9 01       	movw	r22, r18
    1ffe:	02 c0       	rjmp	.+4      	; 0x2004 <DIO_InitPin+0x80>
    2000:	66 0f       	add	r22, r22
    2002:	77 1f       	adc	r23, r23
    2004:	8a 95       	dec	r24
    2006:	e2 f7       	brpl	.-8      	; 0x2000 <DIO_InitPin+0x7c>
    2008:	cb 01       	movw	r24, r22
    200a:	94 2f       	mov	r25, r20
    200c:	98 2b       	or	r25, r24
    200e:	94 bb       	out	0x14, r25	; 20
    2010:	95 b3       	in	r25, 0x15	; 21
    2012:	80 95       	com	r24
    2014:	89 23       	and	r24, r25
    2016:	85 bb       	out	0x15, r24	; 21
    2018:	08 95       	ret
    201a:	41 b3       	in	r20, 0x11	; 17
    201c:	21 e0       	ldi	r18, 0x01	; 1
    201e:	30 e0       	ldi	r19, 0x00	; 0
    2020:	b9 01       	movw	r22, r18
    2022:	02 c0       	rjmp	.+4      	; 0x2028 <DIO_InitPin+0xa4>
    2024:	66 0f       	add	r22, r22
    2026:	77 1f       	adc	r23, r23
    2028:	8a 95       	dec	r24
    202a:	e2 f7       	brpl	.-8      	; 0x2024 <DIO_InitPin+0xa0>
    202c:	cb 01       	movw	r24, r22
    202e:	94 2f       	mov	r25, r20
    2030:	98 2b       	or	r25, r24
    2032:	91 bb       	out	0x11, r25	; 17
    2034:	92 b3       	in	r25, 0x12	; 18
    2036:	80 95       	com	r24
    2038:	89 23       	and	r24, r25
    203a:	82 bb       	out	0x12, r24	; 18
    203c:	08 95       	ret
    203e:	91 30       	cpi	r25, 0x01	; 1
    2040:	c1 f0       	breq	.+48     	; 0x2072 <DIO_InitPin+0xee>
    2042:	28 f0       	brcs	.+10     	; 0x204e <DIO_InitPin+0xca>
    2044:	92 30       	cpi	r25, 0x02	; 2
    2046:	39 f1       	breq	.+78     	; 0x2096 <DIO_InitPin+0x112>
    2048:	93 30       	cpi	r25, 0x03	; 3
    204a:	b9 f1       	breq	.+110    	; 0x20ba <DIO_InitPin+0x136>
    204c:	08 95       	ret
    204e:	4a b3       	in	r20, 0x1a	; 26
    2050:	21 e0       	ldi	r18, 0x01	; 1
    2052:	30 e0       	ldi	r19, 0x00	; 0
    2054:	b9 01       	movw	r22, r18
    2056:	02 c0       	rjmp	.+4      	; 0x205c <DIO_InitPin+0xd8>
    2058:	66 0f       	add	r22, r22
    205a:	77 1f       	adc	r23, r23
    205c:	8a 95       	dec	r24
    205e:	e2 f7       	brpl	.-8      	; 0x2058 <DIO_InitPin+0xd4>
    2060:	cb 01       	movw	r24, r22
    2062:	80 95       	com	r24
    2064:	94 2f       	mov	r25, r20
    2066:	98 23       	and	r25, r24
    2068:	9a bb       	out	0x1a, r25	; 26
    206a:	9b b3       	in	r25, 0x1b	; 27
    206c:	89 23       	and	r24, r25
    206e:	8b bb       	out	0x1b, r24	; 27
    2070:	08 95       	ret
    2072:	47 b3       	in	r20, 0x17	; 23
    2074:	21 e0       	ldi	r18, 0x01	; 1
    2076:	30 e0       	ldi	r19, 0x00	; 0
    2078:	b9 01       	movw	r22, r18
    207a:	02 c0       	rjmp	.+4      	; 0x2080 <DIO_InitPin+0xfc>
    207c:	66 0f       	add	r22, r22
    207e:	77 1f       	adc	r23, r23
    2080:	8a 95       	dec	r24
    2082:	e2 f7       	brpl	.-8      	; 0x207c <DIO_InitPin+0xf8>
    2084:	cb 01       	movw	r24, r22
    2086:	80 95       	com	r24
    2088:	94 2f       	mov	r25, r20
    208a:	98 23       	and	r25, r24
    208c:	97 bb       	out	0x17, r25	; 23
    208e:	98 b3       	in	r25, 0x18	; 24
    2090:	89 23       	and	r24, r25
    2092:	88 bb       	out	0x18, r24	; 24
    2094:	08 95       	ret
    2096:	44 b3       	in	r20, 0x14	; 20
    2098:	21 e0       	ldi	r18, 0x01	; 1
    209a:	30 e0       	ldi	r19, 0x00	; 0
    209c:	b9 01       	movw	r22, r18
    209e:	02 c0       	rjmp	.+4      	; 0x20a4 <DIO_InitPin+0x120>
    20a0:	66 0f       	add	r22, r22
    20a2:	77 1f       	adc	r23, r23
    20a4:	8a 95       	dec	r24
    20a6:	e2 f7       	brpl	.-8      	; 0x20a0 <DIO_InitPin+0x11c>
    20a8:	cb 01       	movw	r24, r22
    20aa:	80 95       	com	r24
    20ac:	94 2f       	mov	r25, r20
    20ae:	98 23       	and	r25, r24
    20b0:	94 bb       	out	0x14, r25	; 20
    20b2:	95 b3       	in	r25, 0x15	; 21
    20b4:	89 23       	and	r24, r25
    20b6:	85 bb       	out	0x15, r24	; 21
    20b8:	08 95       	ret
    20ba:	41 b3       	in	r20, 0x11	; 17
    20bc:	21 e0       	ldi	r18, 0x01	; 1
    20be:	30 e0       	ldi	r19, 0x00	; 0
    20c0:	b9 01       	movw	r22, r18
    20c2:	02 c0       	rjmp	.+4      	; 0x20c8 <DIO_InitPin+0x144>
    20c4:	66 0f       	add	r22, r22
    20c6:	77 1f       	adc	r23, r23
    20c8:	8a 95       	dec	r24
    20ca:	e2 f7       	brpl	.-8      	; 0x20c4 <DIO_InitPin+0x140>
    20cc:	cb 01       	movw	r24, r22
    20ce:	80 95       	com	r24
    20d0:	94 2f       	mov	r25, r20
    20d2:	98 23       	and	r25, r24
    20d4:	91 bb       	out	0x11, r25	; 17
    20d6:	92 b3       	in	r25, 0x12	; 18
    20d8:	89 23       	and	r24, r25
    20da:	82 bb       	out	0x12, r24	; 18
    20dc:	08 95       	ret
    20de:	91 30       	cpi	r25, 0x01	; 1
    20e0:	c1 f0       	breq	.+48     	; 0x2112 <DIO_InitPin+0x18e>
    20e2:	28 f0       	brcs	.+10     	; 0x20ee <DIO_InitPin+0x16a>
    20e4:	92 30       	cpi	r25, 0x02	; 2
    20e6:	39 f1       	breq	.+78     	; 0x2136 <DIO_InitPin+0x1b2>
    20e8:	93 30       	cpi	r25, 0x03	; 3
    20ea:	b9 f1       	breq	.+110    	; 0x215a <DIO_InitPin+0x1d6>
    20ec:	08 95       	ret
    20ee:	4a b3       	in	r20, 0x1a	; 26
    20f0:	21 e0       	ldi	r18, 0x01	; 1
    20f2:	30 e0       	ldi	r19, 0x00	; 0
    20f4:	b9 01       	movw	r22, r18
    20f6:	02 c0       	rjmp	.+4      	; 0x20fc <DIO_InitPin+0x178>
    20f8:	66 0f       	add	r22, r22
    20fa:	77 1f       	adc	r23, r23
    20fc:	8a 95       	dec	r24
    20fe:	e2 f7       	brpl	.-8      	; 0x20f8 <DIO_InitPin+0x174>
    2100:	cb 01       	movw	r24, r22
    2102:	96 2f       	mov	r25, r22
    2104:	90 95       	com	r25
    2106:	94 23       	and	r25, r20
    2108:	9a bb       	out	0x1a, r25	; 26
    210a:	9b b3       	in	r25, 0x1b	; 27
    210c:	89 2b       	or	r24, r25
    210e:	8b bb       	out	0x1b, r24	; 27
    2110:	08 95       	ret
    2112:	47 b3       	in	r20, 0x17	; 23
    2114:	21 e0       	ldi	r18, 0x01	; 1
    2116:	30 e0       	ldi	r19, 0x00	; 0
    2118:	b9 01       	movw	r22, r18
    211a:	02 c0       	rjmp	.+4      	; 0x2120 <DIO_InitPin+0x19c>
    211c:	66 0f       	add	r22, r22
    211e:	77 1f       	adc	r23, r23
    2120:	8a 95       	dec	r24
    2122:	e2 f7       	brpl	.-8      	; 0x211c <DIO_InitPin+0x198>
    2124:	cb 01       	movw	r24, r22
    2126:	96 2f       	mov	r25, r22
    2128:	90 95       	com	r25
    212a:	94 23       	and	r25, r20
    212c:	97 bb       	out	0x17, r25	; 23
    212e:	98 b3       	in	r25, 0x18	; 24
    2130:	89 2b       	or	r24, r25
    2132:	88 bb       	out	0x18, r24	; 24
    2134:	08 95       	ret
    2136:	44 b3       	in	r20, 0x14	; 20
    2138:	21 e0       	ldi	r18, 0x01	; 1
    213a:	30 e0       	ldi	r19, 0x00	; 0
    213c:	b9 01       	movw	r22, r18
    213e:	02 c0       	rjmp	.+4      	; 0x2144 <DIO_InitPin+0x1c0>
    2140:	66 0f       	add	r22, r22
    2142:	77 1f       	adc	r23, r23
    2144:	8a 95       	dec	r24
    2146:	e2 f7       	brpl	.-8      	; 0x2140 <DIO_InitPin+0x1bc>
    2148:	cb 01       	movw	r24, r22
    214a:	96 2f       	mov	r25, r22
    214c:	90 95       	com	r25
    214e:	94 23       	and	r25, r20
    2150:	94 bb       	out	0x14, r25	; 20
    2152:	95 b3       	in	r25, 0x15	; 21
    2154:	89 2b       	or	r24, r25
    2156:	85 bb       	out	0x15, r24	; 21
    2158:	08 95       	ret
    215a:	41 b3       	in	r20, 0x11	; 17
    215c:	21 e0       	ldi	r18, 0x01	; 1
    215e:	30 e0       	ldi	r19, 0x00	; 0
    2160:	b9 01       	movw	r22, r18
    2162:	02 c0       	rjmp	.+4      	; 0x2168 <DIO_InitPin+0x1e4>
    2164:	66 0f       	add	r22, r22
    2166:	77 1f       	adc	r23, r23
    2168:	8a 95       	dec	r24
    216a:	e2 f7       	brpl	.-8      	; 0x2164 <DIO_InitPin+0x1e0>
    216c:	cb 01       	movw	r24, r22
    216e:	96 2f       	mov	r25, r22
    2170:	90 95       	com	r25
    2172:	94 23       	and	r25, r20
    2174:	91 bb       	out	0x11, r25	; 17
    2176:	92 b3       	in	r25, 0x12	; 18
    2178:	89 2b       	or	r24, r25
    217a:	82 bb       	out	0x12, r24	; 18
    217c:	08 95       	ret

0000217e <DIO_Init>:
    217e:	cf 93       	push	r28
    2180:	c0 e0       	ldi	r28, 0x00	; 0
    2182:	09 c0       	rjmp	.+18     	; 0x2196 <DIO_Init+0x18>
    2184:	ec 2f       	mov	r30, r28
    2186:	f0 e0       	ldi	r31, 0x00	; 0
    2188:	eb 50       	subi	r30, 0x0B	; 11
    218a:	ff 4f       	sbci	r31, 0xFF	; 255
    218c:	60 81       	ld	r22, Z
    218e:	8c 2f       	mov	r24, r28
    2190:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <DIO_InitPin>
    2194:	cf 5f       	subi	r28, 0xFF	; 255
    2196:	c0 32       	cpi	r28, 0x20	; 32
    2198:	a8 f3       	brcs	.-22     	; 0x2184 <DIO_Init+0x6>
    219a:	cf 91       	pop	r28
    219c:	08 95       	ret

0000219e <DIO_WritePin>:
    219e:	98 2f       	mov	r25, r24
    21a0:	96 95       	lsr	r25
    21a2:	96 95       	lsr	r25
    21a4:	96 95       	lsr	r25
    21a6:	87 70       	andi	r24, 0x07	; 7
    21a8:	61 11       	cpse	r22, r1
    21aa:	40 c0       	rjmp	.+128    	; 0x222c <DIO_WritePin+0x8e>
    21ac:	91 30       	cpi	r25, 0x01	; 1
    21ae:	a1 f0       	breq	.+40     	; 0x21d8 <DIO_WritePin+0x3a>
    21b0:	28 f0       	brcs	.+10     	; 0x21bc <DIO_WritePin+0x1e>
    21b2:	92 30       	cpi	r25, 0x02	; 2
    21b4:	f9 f0       	breq	.+62     	; 0x21f4 <DIO_WritePin+0x56>
    21b6:	93 30       	cpi	r25, 0x03	; 3
    21b8:	59 f1       	breq	.+86     	; 0x2210 <DIO_WritePin+0x72>
    21ba:	08 95       	ret
    21bc:	4b b3       	in	r20, 0x1b	; 27
    21be:	21 e0       	ldi	r18, 0x01	; 1
    21c0:	30 e0       	ldi	r19, 0x00	; 0
    21c2:	b9 01       	movw	r22, r18
    21c4:	02 c0       	rjmp	.+4      	; 0x21ca <DIO_WritePin+0x2c>
    21c6:	66 0f       	add	r22, r22
    21c8:	77 1f       	adc	r23, r23
    21ca:	8a 95       	dec	r24
    21cc:	e2 f7       	brpl	.-8      	; 0x21c6 <DIO_WritePin+0x28>
    21ce:	cb 01       	movw	r24, r22
    21d0:	80 95       	com	r24
    21d2:	84 23       	and	r24, r20
    21d4:	8b bb       	out	0x1b, r24	; 27
    21d6:	08 95       	ret
    21d8:	48 b3       	in	r20, 0x18	; 24
    21da:	21 e0       	ldi	r18, 0x01	; 1
    21dc:	30 e0       	ldi	r19, 0x00	; 0
    21de:	b9 01       	movw	r22, r18
    21e0:	02 c0       	rjmp	.+4      	; 0x21e6 <DIO_WritePin+0x48>
    21e2:	66 0f       	add	r22, r22
    21e4:	77 1f       	adc	r23, r23
    21e6:	8a 95       	dec	r24
    21e8:	e2 f7       	brpl	.-8      	; 0x21e2 <DIO_WritePin+0x44>
    21ea:	cb 01       	movw	r24, r22
    21ec:	80 95       	com	r24
    21ee:	84 23       	and	r24, r20
    21f0:	88 bb       	out	0x18, r24	; 24
    21f2:	08 95       	ret
    21f4:	45 b3       	in	r20, 0x15	; 21
    21f6:	21 e0       	ldi	r18, 0x01	; 1
    21f8:	30 e0       	ldi	r19, 0x00	; 0
    21fa:	b9 01       	movw	r22, r18
    21fc:	02 c0       	rjmp	.+4      	; 0x2202 <DIO_WritePin+0x64>
    21fe:	66 0f       	add	r22, r22
    2200:	77 1f       	adc	r23, r23
    2202:	8a 95       	dec	r24
    2204:	e2 f7       	brpl	.-8      	; 0x21fe <DIO_WritePin+0x60>
    2206:	cb 01       	movw	r24, r22
    2208:	80 95       	com	r24
    220a:	84 23       	and	r24, r20
    220c:	85 bb       	out	0x15, r24	; 21
    220e:	08 95       	ret
    2210:	42 b3       	in	r20, 0x12	; 18
    2212:	21 e0       	ldi	r18, 0x01	; 1
    2214:	30 e0       	ldi	r19, 0x00	; 0
    2216:	b9 01       	movw	r22, r18
    2218:	02 c0       	rjmp	.+4      	; 0x221e <DIO_WritePin+0x80>
    221a:	66 0f       	add	r22, r22
    221c:	77 1f       	adc	r23, r23
    221e:	8a 95       	dec	r24
    2220:	e2 f7       	brpl	.-8      	; 0x221a <DIO_WritePin+0x7c>
    2222:	cb 01       	movw	r24, r22
    2224:	80 95       	com	r24
    2226:	84 23       	and	r24, r20
    2228:	82 bb       	out	0x12, r24	; 18
    222a:	08 95       	ret
    222c:	61 30       	cpi	r22, 0x01	; 1
    222e:	d9 f5       	brne	.+118    	; 0x22a6 <DIO_WritePin+0x108>
    2230:	91 30       	cpi	r25, 0x01	; 1
    2232:	99 f0       	breq	.+38     	; 0x225a <DIO_WritePin+0xbc>
    2234:	28 f0       	brcs	.+10     	; 0x2240 <DIO_WritePin+0xa2>
    2236:	92 30       	cpi	r25, 0x02	; 2
    2238:	e9 f0       	breq	.+58     	; 0x2274 <DIO_WritePin+0xd6>
    223a:	93 30       	cpi	r25, 0x03	; 3
    223c:	41 f1       	breq	.+80     	; 0x228e <DIO_WritePin+0xf0>
    223e:	08 95       	ret
    2240:	4b b3       	in	r20, 0x1b	; 27
    2242:	21 e0       	ldi	r18, 0x01	; 1
    2244:	30 e0       	ldi	r19, 0x00	; 0
    2246:	b9 01       	movw	r22, r18
    2248:	02 c0       	rjmp	.+4      	; 0x224e <DIO_WritePin+0xb0>
    224a:	66 0f       	add	r22, r22
    224c:	77 1f       	adc	r23, r23
    224e:	8a 95       	dec	r24
    2250:	e2 f7       	brpl	.-8      	; 0x224a <DIO_WritePin+0xac>
    2252:	cb 01       	movw	r24, r22
    2254:	84 2b       	or	r24, r20
    2256:	8b bb       	out	0x1b, r24	; 27
    2258:	08 95       	ret
    225a:	48 b3       	in	r20, 0x18	; 24
    225c:	21 e0       	ldi	r18, 0x01	; 1
    225e:	30 e0       	ldi	r19, 0x00	; 0
    2260:	b9 01       	movw	r22, r18
    2262:	02 c0       	rjmp	.+4      	; 0x2268 <DIO_WritePin+0xca>
    2264:	66 0f       	add	r22, r22
    2266:	77 1f       	adc	r23, r23
    2268:	8a 95       	dec	r24
    226a:	e2 f7       	brpl	.-8      	; 0x2264 <DIO_WritePin+0xc6>
    226c:	cb 01       	movw	r24, r22
    226e:	84 2b       	or	r24, r20
    2270:	88 bb       	out	0x18, r24	; 24
    2272:	08 95       	ret
    2274:	45 b3       	in	r20, 0x15	; 21
    2276:	21 e0       	ldi	r18, 0x01	; 1
    2278:	30 e0       	ldi	r19, 0x00	; 0
    227a:	b9 01       	movw	r22, r18
    227c:	02 c0       	rjmp	.+4      	; 0x2282 <DIO_WritePin+0xe4>
    227e:	66 0f       	add	r22, r22
    2280:	77 1f       	adc	r23, r23
    2282:	8a 95       	dec	r24
    2284:	e2 f7       	brpl	.-8      	; 0x227e <DIO_WritePin+0xe0>
    2286:	cb 01       	movw	r24, r22
    2288:	84 2b       	or	r24, r20
    228a:	85 bb       	out	0x15, r24	; 21
    228c:	08 95       	ret
    228e:	42 b3       	in	r20, 0x12	; 18
    2290:	21 e0       	ldi	r18, 0x01	; 1
    2292:	30 e0       	ldi	r19, 0x00	; 0
    2294:	b9 01       	movw	r22, r18
    2296:	02 c0       	rjmp	.+4      	; 0x229c <DIO_WritePin+0xfe>
    2298:	66 0f       	add	r22, r22
    229a:	77 1f       	adc	r23, r23
    229c:	8a 95       	dec	r24
    229e:	e2 f7       	brpl	.-8      	; 0x2298 <DIO_WritePin+0xfa>
    22a0:	cb 01       	movw	r24, r22
    22a2:	84 2b       	or	r24, r20
    22a4:	82 bb       	out	0x12, r24	; 18
    22a6:	08 95       	ret

000022a8 <DIO_TogglePin>:

void DIO_TogglePin(DIO_Pin_type pin)
{
	DIO_Port_type port = pin/8;
    22a8:	98 2f       	mov	r25, r24
    22aa:	96 95       	lsr	r25
    22ac:	96 95       	lsr	r25
    22ae:	96 95       	lsr	r25
	u8 pin_num  = pin % 8;
    22b0:	87 70       	andi	r24, 0x07	; 7
	switch (port)
    22b2:	91 30       	cpi	r25, 0x01	; 1
    22b4:	99 f0       	breq	.+38     	; 0x22dc <DIO_TogglePin+0x34>
    22b6:	28 f0       	brcs	.+10     	; 0x22c2 <DIO_TogglePin+0x1a>
    22b8:	92 30       	cpi	r25, 0x02	; 2
    22ba:	e9 f0       	breq	.+58     	; 0x22f6 <DIO_TogglePin+0x4e>
    22bc:	93 30       	cpi	r25, 0x03	; 3
    22be:	41 f1       	breq	.+80     	; 0x2310 <DIO_TogglePin+0x68>
    22c0:	08 95       	ret
	{
		case PA:
		TOG_BIT(PORTA_REG,pin_num);
    22c2:	4b b3       	in	r20, 0x1b	; 27
    22c4:	21 e0       	ldi	r18, 0x01	; 1
    22c6:	30 e0       	ldi	r19, 0x00	; 0
    22c8:	b9 01       	movw	r22, r18
    22ca:	02 c0       	rjmp	.+4      	; 0x22d0 <DIO_TogglePin+0x28>
    22cc:	66 0f       	add	r22, r22
    22ce:	77 1f       	adc	r23, r23
    22d0:	8a 95       	dec	r24
    22d2:	e2 f7       	brpl	.-8      	; 0x22cc <DIO_TogglePin+0x24>
    22d4:	cb 01       	movw	r24, r22
    22d6:	84 27       	eor	r24, r20
    22d8:	8b bb       	out	0x1b, r24	; 27
		break;
    22da:	08 95       	ret
		case PB:
		TOG_BIT(PORTB_REG,pin_num);
    22dc:	48 b3       	in	r20, 0x18	; 24
    22de:	21 e0       	ldi	r18, 0x01	; 1
    22e0:	30 e0       	ldi	r19, 0x00	; 0
    22e2:	b9 01       	movw	r22, r18
    22e4:	02 c0       	rjmp	.+4      	; 0x22ea <DIO_TogglePin+0x42>
    22e6:	66 0f       	add	r22, r22
    22e8:	77 1f       	adc	r23, r23
    22ea:	8a 95       	dec	r24
    22ec:	e2 f7       	brpl	.-8      	; 0x22e6 <DIO_TogglePin+0x3e>
    22ee:	cb 01       	movw	r24, r22
    22f0:	84 27       	eor	r24, r20
    22f2:	88 bb       	out	0x18, r24	; 24
		break;
    22f4:	08 95       	ret
		case PC:
		TOG_BIT(PORTC_REG,pin_num);
    22f6:	45 b3       	in	r20, 0x15	; 21
    22f8:	21 e0       	ldi	r18, 0x01	; 1
    22fa:	30 e0       	ldi	r19, 0x00	; 0
    22fc:	b9 01       	movw	r22, r18
    22fe:	02 c0       	rjmp	.+4      	; 0x2304 <DIO_TogglePin+0x5c>
    2300:	66 0f       	add	r22, r22
    2302:	77 1f       	adc	r23, r23
    2304:	8a 95       	dec	r24
    2306:	e2 f7       	brpl	.-8      	; 0x2300 <DIO_TogglePin+0x58>
    2308:	cb 01       	movw	r24, r22
    230a:	84 27       	eor	r24, r20
    230c:	85 bb       	out	0x15, r24	; 21
		break;
    230e:	08 95       	ret
		case PD:
		TOG_BIT(PORTD_REG,pin_num);
    2310:	42 b3       	in	r20, 0x12	; 18
    2312:	21 e0       	ldi	r18, 0x01	; 1
    2314:	30 e0       	ldi	r19, 0x00	; 0
    2316:	b9 01       	movw	r22, r18
    2318:	02 c0       	rjmp	.+4      	; 0x231e <DIO_TogglePin+0x76>
    231a:	66 0f       	add	r22, r22
    231c:	77 1f       	adc	r23, r23
    231e:	8a 95       	dec	r24
    2320:	e2 f7       	brpl	.-8      	; 0x231a <DIO_TogglePin+0x72>
    2322:	cb 01       	movw	r24, r22
    2324:	84 27       	eor	r24, r20
    2326:	82 bb       	out	0x12, r24	; 18
    2328:	08 95       	ret

0000232a <UART_Init>:
{
	/*RXC flag is set when the UART receive data so  wait until this flag is set to one
	and it will CLRed by hardware when u read the data*/
	while(!(READ_BIT(UCSRA,RXC)));  
    return UDR;
}
    232a:	8b b1       	in	r24, 0x0b	; 11
    232c:	8d 7f       	andi	r24, 0xFD	; 253
    232e:	8b b9       	out	0x0b, r24	; 11
    2330:	8a b1       	in	r24, 0x0a	; 10
    2332:	8b 7f       	andi	r24, 0xFB	; 251
    2334:	8a b9       	out	0x0a, r24	; 10
    2336:	86 e8       	ldi	r24, 0x86	; 134
    2338:	80 bd       	out	0x20, r24	; 32
    233a:	10 bc       	out	0x20, r1	; 32
    233c:	83 e3       	ldi	r24, 0x33	; 51
    233e:	89 b9       	out	0x09, r24	; 9
    2340:	8a b1       	in	r24, 0x0a	; 10
    2342:	80 61       	ori	r24, 0x10	; 16
    2344:	8a b9       	out	0x0a, r24	; 10
    2346:	8a b1       	in	r24, 0x0a	; 10
    2348:	88 60       	ori	r24, 0x08	; 8
    234a:	8a b9       	out	0x0a, r24	; 10
    234c:	08 95       	ret

0000234e <__vector_13>:
    234e:	1f 92       	push	r1
    2350:	0f 92       	push	r0
    2352:	0f b6       	in	r0, 0x3f	; 63
    2354:	0f 92       	push	r0
    2356:	11 24       	eor	r1, r1
    2358:	2f 93       	push	r18
    235a:	3f 93       	push	r19
    235c:	4f 93       	push	r20
    235e:	5f 93       	push	r21
    2360:	6f 93       	push	r22
    2362:	7f 93       	push	r23
    2364:	8f 93       	push	r24
    2366:	9f 93       	push	r25
    2368:	af 93       	push	r26
    236a:	bf 93       	push	r27
    236c:	ef 93       	push	r30
    236e:	ff 93       	push	r31
    2370:	e0 91 e9 05 	lds	r30, 0x05E9	; 0x8005e9 <UART_RX_Fptr>
    2374:	f0 91 ea 05 	lds	r31, 0x05EA	; 0x8005ea <UART_RX_Fptr+0x1>
    2378:	30 97       	sbiw	r30, 0x00	; 0
    237a:	09 f0       	breq	.+2      	; 0x237e <__vector_13+0x30>
    237c:	09 95       	icall
    237e:	ff 91       	pop	r31
    2380:	ef 91       	pop	r30
    2382:	bf 91       	pop	r27
    2384:	af 91       	pop	r26
    2386:	9f 91       	pop	r25
    2388:	8f 91       	pop	r24
    238a:	7f 91       	pop	r23
    238c:	6f 91       	pop	r22
    238e:	5f 91       	pop	r21
    2390:	4f 91       	pop	r20
    2392:	3f 91       	pop	r19
    2394:	2f 91       	pop	r18
    2396:	0f 90       	pop	r0
    2398:	0f be       	out	0x3f, r0	; 63
    239a:	0f 90       	pop	r0
    239c:	1f 90       	pop	r1
    239e:	18 95       	reti

000023a0 <__vector_15>:
    23a0:	1f 92       	push	r1
    23a2:	0f 92       	push	r0
    23a4:	0f b6       	in	r0, 0x3f	; 63
    23a6:	0f 92       	push	r0
    23a8:	11 24       	eor	r1, r1
    23aa:	2f 93       	push	r18
    23ac:	3f 93       	push	r19
    23ae:	4f 93       	push	r20
    23b0:	5f 93       	push	r21
    23b2:	6f 93       	push	r22
    23b4:	7f 93       	push	r23
    23b6:	8f 93       	push	r24
    23b8:	9f 93       	push	r25
    23ba:	af 93       	push	r26
    23bc:	bf 93       	push	r27
    23be:	ef 93       	push	r30
    23c0:	ff 93       	push	r31
    23c2:	e0 91 e7 05 	lds	r30, 0x05E7	; 0x8005e7 <UART_TX_Fptr>
    23c6:	f0 91 e8 05 	lds	r31, 0x05E8	; 0x8005e8 <UART_TX_Fptr+0x1>
    23ca:	30 97       	sbiw	r30, 0x00	; 0
    23cc:	09 f0       	breq	.+2      	; 0x23d0 <__vector_15+0x30>
    23ce:	09 95       	icall
    23d0:	ff 91       	pop	r31
    23d2:	ef 91       	pop	r30
    23d4:	bf 91       	pop	r27
    23d6:	af 91       	pop	r26
    23d8:	9f 91       	pop	r25
    23da:	8f 91       	pop	r24
    23dc:	7f 91       	pop	r23
    23de:	6f 91       	pop	r22
    23e0:	5f 91       	pop	r21
    23e2:	4f 91       	pop	r20
    23e4:	3f 91       	pop	r19
    23e6:	2f 91       	pop	r18
    23e8:	0f 90       	pop	r0
    23ea:	0f be       	out	0x3f, r0	; 63
    23ec:	0f 90       	pop	r0
    23ee:	1f 90       	pop	r1
    23f0:	18 95       	reti

000023f2 <UART_SendByte>:
    23f2:	5d 9b       	sbis	0x0b, 5	; 11
    23f4:	fe cf       	rjmp	.-4      	; 0x23f2 <UART_SendByte>
    23f6:	8c b9       	out	0x0c, r24	; 12
    23f8:	08 95       	ret

000023fa <UART_Receive_PeriodicCheck>:


u8 UART_Receive_PeriodicCheck(u8*pdata)
{
	u8 status=0;
	if(READ_BIT(UCSRA,RXC))
    23fa:	5f 9b       	sbis	0x0b, 7	; 11
    23fc:	05 c0       	rjmp	.+10     	; 0x2408 <UART_Receive_PeriodicCheck+0xe>
	{
		*pdata=UDR;
    23fe:	2c b1       	in	r18, 0x0c	; 12
    2400:	fc 01       	movw	r30, r24
    2402:	20 83       	st	Z, r18
		status=1;
    2404:	81 e0       	ldi	r24, 0x01	; 1
    2406:	08 95       	ret
	}
	else
	{	status=0;
    2408:	80 e0       	ldi	r24, 0x00	; 0
	}
return status;
}
    240a:	08 95       	ret

0000240c <UART_SendString>:
 */ 

#include "UART_Service.h"
//#include "LCD_Interface.h"
void UART_SendString(u8 *pstr)
{
    240c:	cf 93       	push	r28
    240e:	df 93       	push	r29
    2410:	ec 01       	movw	r28, r24
	while(*pstr != 0)
    2412:	03 c0       	rjmp	.+6      	; 0x241a <UART_SendString+0xe>
	{
		UART_SendByte(*pstr);
    2414:	0e 94 f9 11 	call	0x23f2	; 0x23f2 <UART_SendByte>
		pstr++;
    2418:	21 96       	adiw	r28, 0x01	; 1

#include "UART_Service.h"
//#include "LCD_Interface.h"
void UART_SendString(u8 *pstr)
{
	while(*pstr != 0)
    241a:	88 81       	ld	r24, Y
    241c:	81 11       	cpse	r24, r1
    241e:	fa cf       	rjmp	.-12     	; 0x2414 <UART_SendString+0x8>
	{
		UART_SendByte(*pstr);
		pstr++;
	}
}
    2420:	df 91       	pop	r29
    2422:	cf 91       	pop	r28
    2424:	08 95       	ret

00002426 <__moddi3>:
    2426:	68 94       	set
    2428:	01 c0       	rjmp	.+2      	; 0x242c <__divdi3_moddi3>

0000242a <__divdi3>:
    242a:	e8 94       	clt

0000242c <__divdi3_moddi3>:
    242c:	f9 2f       	mov	r31, r25
    242e:	f1 2b       	or	r31, r17
    2430:	12 f0       	brmi	.+4      	; 0x2436 <__divdi3_moddi3+0xa>
    2432:	0c 94 47 12 	jmp	0x248e	; 0x248e <__udivdi3_umoddi3>
    2436:	a0 e0       	ldi	r26, 0x00	; 0
    2438:	b0 e0       	ldi	r27, 0x00	; 0
    243a:	e1 e2       	ldi	r30, 0x21	; 33
    243c:	f2 e1       	ldi	r31, 0x12	; 18
    243e:	0c 94 b9 12 	jmp	0x2572	; 0x2572 <__prologue_saves__+0xc>
    2442:	09 2e       	mov	r0, r25
    2444:	05 94       	asr	r0
    2446:	22 f4       	brpl	.+8      	; 0x2450 <__divdi3_moddi3+0x24>
    2448:	0e 94 a3 12 	call	0x2546	; 0x2546 <__negdi2>
    244c:	11 23       	and	r17, r17
    244e:	92 f4       	brpl	.+36     	; 0x2474 <__divdi3_moddi3+0x48>
    2450:	f0 e8       	ldi	r31, 0x80	; 128
    2452:	0f 26       	eor	r0, r31
    2454:	ff ef       	ldi	r31, 0xFF	; 255
    2456:	e0 94       	com	r14
    2458:	f0 94       	com	r15
    245a:	00 95       	com	r16
    245c:	10 95       	com	r17
    245e:	b0 94       	com	r11
    2460:	c0 94       	com	r12
    2462:	d0 94       	com	r13
    2464:	a1 94       	neg	r10
    2466:	bf 0a       	sbc	r11, r31
    2468:	cf 0a       	sbc	r12, r31
    246a:	df 0a       	sbc	r13, r31
    246c:	ef 0a       	sbc	r14, r31
    246e:	ff 0a       	sbc	r15, r31
    2470:	0f 0b       	sbc	r16, r31
    2472:	1f 0b       	sbc	r17, r31
    2474:	0e 94 52 12 	call	0x24a4	; 0x24a4 <__udivmod64>
    2478:	07 fc       	sbrc	r0, 7
    247a:	0e 94 a3 12 	call	0x2546	; 0x2546 <__negdi2>
    247e:	cd b7       	in	r28, 0x3d	; 61
    2480:	de b7       	in	r29, 0x3e	; 62
    2482:	ec e0       	ldi	r30, 0x0C	; 12
    2484:	0c 94 d5 12 	jmp	0x25aa	; 0x25aa <__epilogue_restores__+0xc>

00002488 <__umoddi3>:
    2488:	68 94       	set
    248a:	01 c0       	rjmp	.+2      	; 0x248e <__udivdi3_umoddi3>

0000248c <__udivdi3>:
    248c:	e8 94       	clt

0000248e <__udivdi3_umoddi3>:
    248e:	8f 92       	push	r8
    2490:	9f 92       	push	r9
    2492:	cf 93       	push	r28
    2494:	df 93       	push	r29
    2496:	0e 94 52 12 	call	0x24a4	; 0x24a4 <__udivmod64>
    249a:	df 91       	pop	r29
    249c:	cf 91       	pop	r28
    249e:	9f 90       	pop	r9
    24a0:	8f 90       	pop	r8
    24a2:	08 95       	ret

000024a4 <__udivmod64>:
    24a4:	88 24       	eor	r8, r8
    24a6:	99 24       	eor	r9, r9
    24a8:	f4 01       	movw	r30, r8
    24aa:	e4 01       	movw	r28, r8
    24ac:	b0 e4       	ldi	r27, 0x40	; 64
    24ae:	9f 93       	push	r25
    24b0:	aa 27       	eor	r26, r26
    24b2:	9a 15       	cp	r25, r10
    24b4:	8b 04       	cpc	r8, r11
    24b6:	9c 04       	cpc	r9, r12
    24b8:	ed 05       	cpc	r30, r13
    24ba:	fe 05       	cpc	r31, r14
    24bc:	cf 05       	cpc	r28, r15
    24be:	d0 07       	cpc	r29, r16
    24c0:	a1 07       	cpc	r26, r17
    24c2:	98 f4       	brcc	.+38     	; 0x24ea <__udivmod64+0x46>
    24c4:	ad 2f       	mov	r26, r29
    24c6:	dc 2f       	mov	r29, r28
    24c8:	cf 2f       	mov	r28, r31
    24ca:	fe 2f       	mov	r31, r30
    24cc:	e9 2d       	mov	r30, r9
    24ce:	98 2c       	mov	r9, r8
    24d0:	89 2e       	mov	r8, r25
    24d2:	98 2f       	mov	r25, r24
    24d4:	87 2f       	mov	r24, r23
    24d6:	76 2f       	mov	r23, r22
    24d8:	65 2f       	mov	r22, r21
    24da:	54 2f       	mov	r21, r20
    24dc:	43 2f       	mov	r20, r19
    24de:	32 2f       	mov	r19, r18
    24e0:	22 27       	eor	r18, r18
    24e2:	b8 50       	subi	r27, 0x08	; 8
    24e4:	31 f7       	brne	.-52     	; 0x24b2 <__udivmod64+0xe>
    24e6:	bf 91       	pop	r27
    24e8:	27 c0       	rjmp	.+78     	; 0x2538 <__udivmod64+0x94>
    24ea:	1b 2e       	mov	r1, r27
    24ec:	bf 91       	pop	r27
    24ee:	bb 27       	eor	r27, r27
    24f0:	22 0f       	add	r18, r18
    24f2:	33 1f       	adc	r19, r19
    24f4:	44 1f       	adc	r20, r20
    24f6:	55 1f       	adc	r21, r21
    24f8:	66 1f       	adc	r22, r22
    24fa:	77 1f       	adc	r23, r23
    24fc:	88 1f       	adc	r24, r24
    24fe:	99 1f       	adc	r25, r25
    2500:	88 1c       	adc	r8, r8
    2502:	99 1c       	adc	r9, r9
    2504:	ee 1f       	adc	r30, r30
    2506:	ff 1f       	adc	r31, r31
    2508:	cc 1f       	adc	r28, r28
    250a:	dd 1f       	adc	r29, r29
    250c:	aa 1f       	adc	r26, r26
    250e:	bb 1f       	adc	r27, r27
    2510:	8a 14       	cp	r8, r10
    2512:	9b 04       	cpc	r9, r11
    2514:	ec 05       	cpc	r30, r12
    2516:	fd 05       	cpc	r31, r13
    2518:	ce 05       	cpc	r28, r14
    251a:	df 05       	cpc	r29, r15
    251c:	a0 07       	cpc	r26, r16
    251e:	b1 07       	cpc	r27, r17
    2520:	48 f0       	brcs	.+18     	; 0x2534 <__udivmod64+0x90>
    2522:	8a 18       	sub	r8, r10
    2524:	9b 08       	sbc	r9, r11
    2526:	ec 09       	sbc	r30, r12
    2528:	fd 09       	sbc	r31, r13
    252a:	ce 09       	sbc	r28, r14
    252c:	df 09       	sbc	r29, r15
    252e:	a0 0b       	sbc	r26, r16
    2530:	b1 0b       	sbc	r27, r17
    2532:	21 60       	ori	r18, 0x01	; 1
    2534:	1a 94       	dec	r1
    2536:	e1 f6       	brne	.-72     	; 0x24f0 <__udivmod64+0x4c>
    2538:	2e f4       	brtc	.+10     	; 0x2544 <__udivmod64+0xa0>
    253a:	94 01       	movw	r18, r8
    253c:	af 01       	movw	r20, r30
    253e:	be 01       	movw	r22, r28
    2540:	cd 01       	movw	r24, r26
    2542:	00 0c       	add	r0, r0
    2544:	08 95       	ret

00002546 <__negdi2>:
    2546:	60 95       	com	r22
    2548:	70 95       	com	r23
    254a:	80 95       	com	r24
    254c:	90 95       	com	r25
    254e:	30 95       	com	r19
    2550:	40 95       	com	r20
    2552:	50 95       	com	r21
    2554:	21 95       	neg	r18
    2556:	3f 4f       	sbci	r19, 0xFF	; 255
    2558:	4f 4f       	sbci	r20, 0xFF	; 255
    255a:	5f 4f       	sbci	r21, 0xFF	; 255
    255c:	6f 4f       	sbci	r22, 0xFF	; 255
    255e:	7f 4f       	sbci	r23, 0xFF	; 255
    2560:	8f 4f       	sbci	r24, 0xFF	; 255
    2562:	9f 4f       	sbci	r25, 0xFF	; 255
    2564:	08 95       	ret

00002566 <__prologue_saves__>:
    2566:	2f 92       	push	r2
    2568:	3f 92       	push	r3
    256a:	4f 92       	push	r4
    256c:	5f 92       	push	r5
    256e:	6f 92       	push	r6
    2570:	7f 92       	push	r7
    2572:	8f 92       	push	r8
    2574:	9f 92       	push	r9
    2576:	af 92       	push	r10
    2578:	bf 92       	push	r11
    257a:	cf 92       	push	r12
    257c:	df 92       	push	r13
    257e:	ef 92       	push	r14
    2580:	ff 92       	push	r15
    2582:	0f 93       	push	r16
    2584:	1f 93       	push	r17
    2586:	cf 93       	push	r28
    2588:	df 93       	push	r29
    258a:	cd b7       	in	r28, 0x3d	; 61
    258c:	de b7       	in	r29, 0x3e	; 62
    258e:	ca 1b       	sub	r28, r26
    2590:	db 0b       	sbc	r29, r27
    2592:	0f b6       	in	r0, 0x3f	; 63
    2594:	f8 94       	cli
    2596:	de bf       	out	0x3e, r29	; 62
    2598:	0f be       	out	0x3f, r0	; 63
    259a:	cd bf       	out	0x3d, r28	; 61
    259c:	09 94       	ijmp

0000259e <__epilogue_restores__>:
    259e:	2a 88       	ldd	r2, Y+18	; 0x12
    25a0:	39 88       	ldd	r3, Y+17	; 0x11
    25a2:	48 88       	ldd	r4, Y+16	; 0x10
    25a4:	5f 84       	ldd	r5, Y+15	; 0x0f
    25a6:	6e 84       	ldd	r6, Y+14	; 0x0e
    25a8:	7d 84       	ldd	r7, Y+13	; 0x0d
    25aa:	8c 84       	ldd	r8, Y+12	; 0x0c
    25ac:	9b 84       	ldd	r9, Y+11	; 0x0b
    25ae:	aa 84       	ldd	r10, Y+10	; 0x0a
    25b0:	b9 84       	ldd	r11, Y+9	; 0x09
    25b2:	c8 84       	ldd	r12, Y+8	; 0x08
    25b4:	df 80       	ldd	r13, Y+7	; 0x07
    25b6:	ee 80       	ldd	r14, Y+6	; 0x06
    25b8:	fd 80       	ldd	r15, Y+5	; 0x05
    25ba:	0c 81       	ldd	r16, Y+4	; 0x04
    25bc:	1b 81       	ldd	r17, Y+3	; 0x03
    25be:	aa 81       	ldd	r26, Y+2	; 0x02
    25c0:	b9 81       	ldd	r27, Y+1	; 0x01
    25c2:	ce 0f       	add	r28, r30
    25c4:	d1 1d       	adc	r29, r1
    25c6:	0f b6       	in	r0, 0x3f	; 63
    25c8:	f8 94       	cli
    25ca:	de bf       	out	0x3e, r29	; 62
    25cc:	0f be       	out	0x3f, r0	; 63
    25ce:	cd bf       	out	0x3d, r28	; 61
    25d0:	ed 01       	movw	r28, r26
    25d2:	08 95       	ret

000025d4 <__cmpdi2_s8>:
    25d4:	00 24       	eor	r0, r0
    25d6:	a7 fd       	sbrc	r26, 7
    25d8:	00 94       	com	r0
    25da:	2a 17       	cp	r18, r26
    25dc:	30 05       	cpc	r19, r0
    25de:	40 05       	cpc	r20, r0
    25e0:	50 05       	cpc	r21, r0
    25e2:	60 05       	cpc	r22, r0
    25e4:	70 05       	cpc	r23, r0
    25e6:	80 05       	cpc	r24, r0
    25e8:	90 05       	cpc	r25, r0
    25ea:	08 95       	ret

000025ec <memcpy>:
    25ec:	fb 01       	movw	r30, r22
    25ee:	dc 01       	movw	r26, r24
    25f0:	02 c0       	rjmp	.+4      	; 0x25f6 <memcpy+0xa>
    25f2:	01 90       	ld	r0, Z+
    25f4:	0d 92       	st	X+, r0
    25f6:	41 50       	subi	r20, 0x01	; 1
    25f8:	50 40       	sbci	r21, 0x00	; 0
    25fa:	d8 f7       	brcc	.-10     	; 0x25f2 <memcpy+0x6>
    25fc:	08 95       	ret

000025fe <_exit>:
    25fe:	f8 94       	cli

00002600 <__stop_program>:
    2600:	ff cf       	rjmp	.-2      	; 0x2600 <__stop_program>
